{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rodi is a dependency injection container for Python","text":"<pre><code>pip install rodi\n</code></pre>"},{"location":"#rodi-offers","title":"Rodi offers...","text":"<ul> <li>A non-intrusive implementation of dependency injection, that does not   require modifying the classes it handles (no decorators are needed, no   changes in injected classes).</li> <li>A strategy to better organize source code, reduce code repetition, and   improve development experience.</li> <li>Simplified dependency management with automatic resolution and injection of   dependencies, by type annotation in constructors or class properties.</li> <li>A fast implementation that performs code inspections only when necessary, rather than   at each type resolution.</li> <li>A generic code API that can be used with any kind of Python applications.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with Rodi, read the Getting Started guide. To dive straight into instructions on using DI with Rodi, see Registering types.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"about/","title":"About Rodi","text":"<p>Rodi born from the desire of using a <code>non-intrusive</code> implementation of Dependency Injection for Python, that does not require modifying the code of types it resolved using decorators, like most others existing implementations of DI for Python. Type annotations make explicit decorators superfluous as the DI container can inspect the code to obtain all information it needs to resolve types.</p> <p>Rodi is the built-in DI framework in the BlackSheep web framework, although it can be replaced with alternative solutions if desired.</p>"},{"location":"about/#the-projects-home","title":"The project's home","text":"<p>The project is hosted in GitHub, handled following DevOps good practices, and is published to pypi.org.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"async/","title":"Working with async","text":"<p>As explained in Getting Started, Rodi's objective is to simplify constructing objects based on constructors and class properties. Support for async resolution is intentionally out of the scope of the library because constructing objects should be lightweight.</p> <p>This page provides guidelines for working with objects that require asynchronous initialization.</p>"},{"location":"async/#a-common-example","title":"A common example","text":"<p>A common example of this situation are objects that handle TCP/IP connection pooling, such as <code>HTTP</code> clients and database clients. These objects are usually implemented as context managers in Python because they need to implement connection pooling and gracefully close TCP connections when disposed.</p> <p>Python supports <code>asynchronous</code> context managers for this kind of scenario.</p> <p>Consider the following example, of a <code>SendGrid</code> API client to send emails using the SendGrid API, with asynchronous code and using <code>httpx</code>.</p> <pre><code># domain/emails.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n\n# TODO: use Pydantic for the Email object.\n@dataclass\nclass Email:\n    recipients: list[str]\n    sender: str\n    sender_name: str\n    subject: str\n    body: str\n    cc: list[str] = None\n    bcc: list[str] = None\n\n\nclass EmailHandler(ABC):  # interface\n    @abstractmethod\n    async def send(self, email: Email) -&gt; None:\n        pass\n</code></pre> <pre><code># data/apis/sendgrid.py\nimport os\nfrom dataclasses import dataclass\n\nimport httpx\n\nfrom domain.emails import Email, EmailHandler\n\n\n@dataclass\nclass SendGridClientSettings:\n    api_key: str\n\n    @classmethod\n    def from_env(cls):\n        api_key = os.environ.get(\"SENDGRID_API_KEY\")\n        if not api_key:\n            raise ValueError(\"SENDGRID_API_KEY environment variable is required\")\n        return cls(api_key=api_key)\n\n\nclass SendGridClient(EmailHandler):\n    def __init__(\n        self, settings: SendGridClientSettings, http_client: httpx.AsyncClient\n    ):\n        if not settings.api_key:\n            raise ValueError(\"API key is required\")\n        self.http_client = http_client\n        self.api_key = settings.api_key\n\n    async def send(self, email: Email) -&gt; None:\n        response = await self.http_client.post(\n            \"https://api.sendgrid.com/v3/mail/send\",\n            headers={\n                \"Authorization\": f\"Bearer {self.api_key}\",\n                \"Content-Type\": \"application/json\",\n            },\n            json=self.get_body(email),\n        )\n        # Note: in case of error, inspect response.text\n        response.raise_for_status()  # Raise an error for bad responses\n\n    def get_body(self, email: Email) -&gt; dict:\n        return {\n            \"personalizations\": [\n                {\n                    \"to\": [{\"email\": recipient} for recipient in email.recipients],\n                    \"subject\": email.subject,\n                    \"cc\": [{\"email\": cc} for cc in email.cc] if email.cc else None,\n                    \"bcc\": [{\"email\": bcc} for bcc in email.bcc] if email.bcc else None,\n                }\n            ],\n            \"from\": {\"email\": email.sender, \"name\": email.sender_name},\n            \"content\": [{\"type\": \"text/html\", \"value\": email.body}],\n        }\n</code></pre> The official SendGrid Python SDK does not support async. <p>At the time of this writing, the official SendGrid Python SDK does not support <code>async</code>. Its documentation provides a wrong example for <code>async</code> code (see issue #988). The SendGrid REST API is very well documented and comfortable to use! Use a class like the one shown on this page to send emails using SendGrid in async code.</p> <p>The SendGridClient depends on an instance of <code>SendGridClientSettings</code> (providing a SendGrid API Key), and on an instance of <code>httpx.AsyncClient</code> able to make HTTP requests.</p> <p>The code below shows how to register the object that requires asynchronous initialization and use it across the lifetime of your application.</p> <pre><code># main.py\nimport asyncio\nfrom contextlib import asynccontextmanager\n\nimport httpx\nfrom rodi import Container\n\nfrom data.apis.sendgrid import SendGridClient, SendGridClientSettings\nfrom domain.emails import EmailHandler\n\n\n@asynccontextmanager\nasync def register_http_client(container: Container):\n\n    async with httpx.AsyncClient() as http_client:\n        print(\"HTTP client initialized\")\n        container.add_instance(http_client)\n        yield\n\n    print(\"HTTP client disposed\")\n\n\nasync def application_runtime(container: Container):\n    # Entry point for what your application does\n    email_handler = container.resolve(EmailHandler)\n    assert isinstance(email_handler, SendGridClient)\n    assert isinstance(email_handler.http_client, httpx.AsyncClient)\n\n    # We can use the HTTP Client during the lifetime of the Application\n    print(\"All is good! \u2728\")\n\n\ndef sendgrid_settings_factory() -&gt; SendGridClientSettings:\n    return SendGridClientSettings.from_env()\n\n\nasync def main():\n    # Bootstrap code for the application\n    container = Container()\n    container.add_singleton_by_factory(sendgrid_settings_factory)\n    container.add_singleton(EmailHandler, SendGridClient)\n\n    async with register_http_client(container) as http_client:\n        container.add_instance(\n            http_client\n        )  # &lt;-- Configure the HTTP client as singleton\n\n        await application_runtime(container)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>The above code displays the following:</p> <pre><code>$ SENDGRID_API_KEY=\"***\" python main.py\n\nHTTP client initialized\nAll is good! \u2728\nHTTP client disposed\n</code></pre>"},{"location":"async/#considerations","title":"Considerations","text":"<ul> <li>It is not Rodi's responsibility to administer the lifecycle of the application. It is   the responsibility of the code that bootstrap the application, to handle objects that   require asynchronous initialization and disposal.</li> <li>Python's <code>asynccontextmanager</code> is convenient for these scenarios.</li> <li>In the example above, the HTTP Client is configured as singleton to benefit from TCP   connection pooling. It would also be possible to configure it as transient or scoped   service, as long as all instances share the same connection pool. In the case of   <code>httpx</code>,  you can read on this subject here: Why use a Client?.</li> <li>Dependency Injection likes custom classes to describe settings for types,   because registering simple types (<code>str</code>, <code>int</code>, <code>float</code>, etc.) in the container does   not scale and should be avoided.</li> </ul> <p>The next page explains how Rodi handles context managers.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"context-managers/","title":"Context managers","text":"<p>This page describes how to work with Rodi and context managers.</p>"},{"location":"context-managers/#how-rodi-handles-context-managers","title":"How Rodi handles context managers","text":"<p>When a class implements the context manager protocol (<code>__enter__</code>, <code>__exit__</code>), Rodi instantiates the class but does not enter nor exit the instance automatically.</p> <pre><code>from rodi import Container\n\n\nclass A:\n    def __init__(self) -&gt; None:\n        print(\"A created\")\n        self.initialized = False\n        self.disposed = False\n\n    def __enter__(self) -&gt; \"A\":\n        print(\"A initialized\")\n        self.initialized = True\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        self.disposed = True\n        print(\"A destroyed\")\n\n\nclass B:\n    def __init__(self, dependency: A) -&gt; None:\n        self.dependency = dependency\n\n    def do_work(self):\n        with self.dependency:\n            print(\"Do work\")\n\n\ncontainer = Container()\n\ncontainer.register(A)\ncontainer.register(B)\n\nb = container.resolve(B)\n\n# b.dependency is instantiated and provided as is, it is not entered\n# automatically\nassert b.dependency.initialized is False\nassert b.dependency.disposed is False\n\nb.do_work()\nassert b.dependency.initialized is True\nassert b.dependency.disposed is True\n</code></pre> <p>Rodi does not enter and exit contexts.</p> <p>There is no way to unambiguously know the intentions of the developer: should a context be entered automatically and disposed automatically?</p>"},{"location":"context-managers/#async-context-managers","title":"Async context managers","text":"<p>As described above for context managers, Rodi does not handle async context managers in any special way either.</p> <pre><code>import asyncio\n\nfrom rodi import Container\n\n\nclass A:\n    def __init__(self) -&gt; None:\n        print(\"A created\")\n        self.initialized = False\n        self.disposed = False\n\n    async def __aenter__(self) -&gt; \"A\":\n        print(\"A initialized\")\n        self.initialized = True\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        self.disposed = True\n        print(\"A destroyed\")\n\n\nclass B:\n    def __init__(self, dependency: A) -&gt; None:\n        self.dependency = dependency\n\n    async def do_work(self):\n        async with self.dependency:\n            print(\"Do work\")\n\n\ncontainer = Container()\n\ncontainer.register(A)\ncontainer.register(B)\n\nb = container.resolve(B)\nassert b.dependency.initialized is False\nassert b.dependency.disposed is False\n\n\nasyncio.run(b.do_work())\nassert b.dependency.initialized is True\nassert b.dependency.disposed is True\n</code></pre> <p>The next page describes support for Union types in Rodi.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"dependency-inversion/","title":"Dependecy inversion","text":"<p>This page describes how to apply the Dependency Inversion Principle, working with abstract classes, protocols, and generics.</p> <ul> <li> Working with interfaces.</li> <li> Using abstract classes and protocols.</li> <li> Working with generics.</li> </ul>"},{"location":"dependency-inversion/#working-with-interfaces","title":"Working with interfaces","text":"<p>Abstract types are a way to define a common interface for a set of classes. This allows you to write code that works with any class that implements the interface, without needing to know the details of the implementation. When registering a type in a <code>Container</code>, you can specify the base interface which is used as key to resolve concrete types, and the implementation type which is used to create the instance. This is useful when it is desirable to use the same interface for different implementations, or when you want to switch to a different implementation in the future without changing the code that relies on the interface.</p> add_transientadd_singletonadd_scoped <pre><code>from abc import ABC, abstractmethod\nfrom rodi import Container\n\nclass MyInterface(ABC):\n    @abstractmethod\n    def do_something(self) -&gt; str:\n        pass\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\ncontainer = Container()\n\ncontainer.add_transient(MyInterface, MyClass)\n\na1 = container.resolve(MyInterface)\nassert isinstance(a1, MyClass)\nassert a1.do_something() == \"Hello, world!\"\n</code></pre> <pre><code>from abc import ABC, abstractmethod\nfrom rodi import Container\n\nclass MyInterface(ABC):\n    @abstractmethod\n    def do_something(self) -&gt; str:\n        pass\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\ncontainer = Container()\n\ncontainer.add_singleton(MyInterface, MyClass)\n\na1 = container.resolve(MyInterface)\nassert isinstance(a1, MyClass)\nassert a1.do_something() == \"Hello, world!\"\n</code></pre> <pre><code>from abc import ABC, abstractmethod\nfrom rodi import Container\n\nclass MyInterface(ABC):\n    @abstractmethod\n    def do_something(self) -&gt; str:\n        pass\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\ncontainer = Container()\n\ncontainer.add_scoped(MyInterface, MyClass)\n\na1 = container.resolve(MyInterface)\nassert isinstance(a1, MyClass)\nassert a1.do_something() == \"Hello, world!\"\n</code></pre> <p>Using <code>ABC</code> and <code>abstractmethod</code> is not strictly necessary, but it is recommended for defining interfaces. This ensures that any class implementing the interface has the required methods.</p> <p>If you decide on using a normal class to describe the interface, Rodi requires the concrete class to be a subclass of the interface.</p> <p>Otherwise, you can use a <code>Protocol</code> from the <code>typing</code> module to define the interface. In this case, Rodi allows registering a protocol as the interface and a normal class that does not inherit it (which aligns with the original purpose of Python's <code>Protocol</code>).</p> <p>The following examples work:</p> Regular class (requires subclassing)Protocol (does not require subclassing) <pre><code>from rodi import Container\n\n\nclass MyInterface:\n    def do_something(self) -&gt; str:\n        pass\n\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\n\ncontainer = Container()\n\ncontainer.add_transient(MyInterface, MyClass)\n\na1 = container.resolve(MyInterface)\nassert isinstance(a1, MyClass)\nassert a1.do_something() == \"Hello, world!\"\nprint(a1)\n</code></pre> <pre><code>from typing import Protocol\nfrom rodi import Container\n\n\nclass MyInterface(Protocol):\n    def do_something(self) -&gt; str:\n        pass\n\n\nclass MyClass:\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\n\ncontainer = Container()\n\ncontainer.add_transient(MyInterface, MyClass)\n\na1 = container.resolve(MyInterface)\nassert isinstance(a1, MyClass)\nassert a1.do_something() == \"Hello, world!\"\nprint(a1)\n</code></pre> <p>Rodi raises an exception if we try registering a normal class as interface, with a concrete class that does not inherit it.</p> <p>Protocols validation.</p> <p>Rodi does not validate implementations of Protocols. This means that if you register a class that does not implement the methods of the Protocol, Rodi will not raise an exception. Support for Protocols validation might be added in the future, but for now, you should ensure that the classes you register do implement the methods of the Protocol.</p>"},{"location":"dependency-inversion/#note-about-factories","title":"Note about factories","text":"<p>When using factories to define how abstract types are created, ensure the factory's return type annotation specifies the interface.</p> <pre><code>from abc import ABC, abstractmethod\nfrom rodi import Container\n\nclass MyInterface(ABC):\n    @abstractmethod\n    def do_something(self) -&gt; str:\n        pass\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\ndef my_factory() -&gt; MyInterface:\n    return MyClass()\n\ncontainer = Container()\n\ncontainer.add_transient_by_factory(my_factory)\n\na1 = container.resolve(A)\na2 = container.resolve(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre> <p>Note about key types.</p> <p>When working with abstract types, the interface type (or protocol) must always be used as the key type. The implementation type is used to create the instance, but it is not used as a key to resolve the type. This is according to the Dependency Inversion Principle, which states that high-level modules should not depend on low-level modules, but both should depend on abstractions.</p> <p>This is conceptually wrong:</p> <pre><code>class MyInterface(ABC):\n    @abstractmethod\n    def do_something(self) -&gt; str:\n        pass\n\nclass MyClass(MyInterface):\n    def do_something(self) -&gt; str:\n        return \"Hello, world!\"\n\ndef my_factory() -&gt; MyClass:  # &lt;-- No. This is a mistake.\n    return MyClass()\n\ncontainer.add_transient_by_factory(my_factory)  # &lt;-- MyClass is used as Key.\n</code></pre>"},{"location":"dependency-inversion/#working-with-generics","title":"Working with generics","text":"<p>Generic types are supported. The following example provides a meaningful demonstration of generics with <code>TypeVar</code> in a real-world scenario.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Generic, List, TypeVar\n\nfrom rodi import Container\n\nT = TypeVar(\"T\")\n\n\nclass Repository(Generic[T]):  # interface\n    \"\"\"A generic repository for managing entities of type T.\"\"\"\n\n    def __init__(self):\n        self._items: List[T] = []\n\n    def add(self, item: T):\n        \"\"\"Add an item to the repository.\"\"\"\n        self._items.append(item)\n\n    def get_all(self) -&gt; List[T]:\n        \"\"\"Retrieve all items from the repository.\"\"\"\n        return self._items\n\n\n# Define specific entity classes\n@dataclass\nclass Product:\n    id: int\n    name: str\n\n\n@dataclass\nclass Customer:\n    id: int\n    email: str\n    first_name: str\n    last_name: str\n\n\n# Set up the container\ncontainer = Container()\n\n# Register repositories\ncontainer.add_scoped(Repository[Product], Repository)\ncontainer.add_scoped(Repository[Customer], Repository)\n\n# Resolve and use the repositories\nproduct_repo = container.resolve(Repository[Product])\ncustomer_repo = container.resolve(Repository[Customer])\n\n# Add and retrieve products\nproduct_repo.add(Product(1, \"Laptop\"))\nproduct_repo.add(Product(2, \"Smartphone\"))\nprint(product_repo.get_all())\n\n# Add and retrieve customers\ncustomer_repo.add(Customer(1, \"alice@wonderland.it\", \"Alice\", \"WhiteRabbit\"))\ncustomer_repo.add(Customer(1, \"bob@foopower.it\", \"Bob\", \"TheHamster\"))\nprint(customer_repo.get_all())\n</code></pre> <p>The above prints to screen:</p> <pre><code>[Product(id=1, name='Laptop'), Product(id=2, name='Smartphone')]\n[Customer(id=1, email='alice@wonderland.it', first_name='Alice', last_name='WhiteRabbit'), Customer(id=1, email='bob@foopower.it', first_name='Bob', last_name='TheHamster')]\n</code></pre> <p>GenericAlias in Python is not considered a class.</p> <p>Note how the generics <code>Repository[Product]</code> and <code>Repository[Customer]</code> are both configured to be resolved using <code>Repository</code> as concrete type. <code>GenericAlias</code> in Python is not considered an actual class. The following wouldn't work:</p> <pre><code>container.add_scoped(Repository[Product])  # No. \ud83d\udca5\ncontainer.add_scoped(Repository[Customer])  # No. \ud83d\udca5\n</code></pre>"},{"location":"dependency-inversion/#nested-generics","title":"Nested generics","text":"<p>When working with nested generics, ensure that the same type used to describe a dependency is registered in the container.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Generic, List, TypeVar\n\nfrom rodi import Container\n\nT = TypeVar(\"T\")\n\n\nclass DBConnection: ...\n\n\nclass Repository(Generic[T]):\n    db_connection: DBConnection\n\n\nclass Service(Generic[T]):\n    repository: Repository[T]\n\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n\n\nclass ProductsService(Service[Product]):\n    ...\n\n\ncontainer = Container()\n\ncontainer.add_scoped(DBConnection)\ncontainer.add_scoped(Repository[T], Repository)\ncontainer.add_scoped(ProductsService)\n\nservice = container.resolve(ProductsService)\nassert isinstance(service.repository, Repository)\nassert isinstance(service.repository.db_connection, DBConnection)\n</code></pre> <p>The following wouldn't work, because the <code>Container</code> will look exactly for the key <code>Repository[T]</code> when instantiating the <code>ProductsService</code>, not for <code>Repository[Product]</code>:</p> <pre><code>container.add_scoped(Repository[Product], Repository)  # No. \ud83d\udca5\n</code></pre> <p>Note that, in practice, this does not cause any issues at runtime, because of type erasure. For more information, refer to Instantiating generic classes and type erasure.</p> <p>If you need to define a more specialized class for <code>Repository[Product]</code>, because for example you need to define products-specific methods, you can:</p> <ul> <li>Define a <code>ProductsRepository(Repository[Product])</code>.</li> <li>Override the annotation for <code>repository</code> in <code>ProductsService</code>.</li> <li>Register <code>ProductsRepository</code> in the container.</li> </ul> <pre><code>from dataclasses import dataclass\nfrom typing import Generic, TypeVar\n\nfrom rodi import Container\n\nT = TypeVar(\"T\")\n\n\nclass DBConnection: ...\n\n\nclass Repository(Generic[T]):\n    db_connection: DBConnection\n\n\nclass Service(Generic[T]):\n    repository: Repository[T]\n\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n\n\nclass ProductsRepository(Repository[Product]): ...\n\n\nclass ProductsService(Service[Product]):\n    repository: ProductsRepository\n\n\ncontainer = Container()\n\ncontainer.add_scoped(DBConnection)\ncontainer.add_scoped(Repository[T], Repository)\ncontainer.add_scoped(ProductsRepository)\ncontainer.add_scoped(ProductsService)\n\nservice = container.resolve(ProductsService)\nassert isinstance(service.repository, Repository)\nassert isinstance(service.repository, ProductsRepository)\nassert isinstance(service.repository.db_connection, DBConnection)\n</code></pre>"},{"location":"dependency-inversion/#checking-if-a-type-is-registered","title":"Checking if a type is registered","text":"<p>To check if a type is registered in the container, use the <code>__contains__</code> interface:</p> <pre><code>from rodi import Container\n\nclass A: ...\n\nclass B: ...\n\ncontainer = Container()\n\ncontainer.add_transient(A)\n\nassert A in container  # True\nassert B not in container  # True\n</code></pre> <p>This can be useful for supporting alternative ways to register types. For example, test code can register a mock type for a class, and the code under test can check whether an interface is already registered in the container, skipping the registration if it is.</p> <p>The next page explains how to work with async.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"errors/","title":"Errors","text":"<p>This page describes errors and custom exceptions raised by Rodi.</p>"},{"location":"errors/#errors","title":"Errors","text":"Name Description <code>CannotResolveTypeException</code> This error is raised when a type cannot be resolved because it was not registered in the container. <code>CircularDependencyException</code> This error is raised when a circular dependency is detected and cannot be resolved. <code>FactoryMissingContextException</code> This error is raised when a factory function does not have <code>_locals</code>. This generally happens only if classes are defined inside functions and use locals (not a common case). <code>MissingTypeException</code> This error is raised when a factory function does not specify its return type annotation, and the user does not specify the type it returns. <code>OverridingServiceException</code> This error is raised when the user tries to override a type that is already registered in the container."},{"location":"errors/#cannot-resolve-type","title":"Cannot resolve type","text":"<pre><code>from rodi import Container\n\n\nclass A: ...\n\nclass B:\n    dependency: A\n\n\ncontainer = Container()\ncontainer.register(B)\n\ncontainer.resolve(B)  # &lt;-- raises exception \ud83d\udca5\n</code></pre> <p><code>rodi.CannotResolveParameterException: Unable to resolve parameter 'dependency' when resolving 'B'</code></p> <p>All dependencies must be explicitly registered in the container. To resolve the error, register the missing type:</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\nclass B:\n    dependency: A\n\n\ncontainer = Container()\ncontainer.register(A)\ncontainer.register(B)\n\ncontainer.resolve(B)\n</code></pre>"},{"location":"errors/#the-chicken-and-egg-problem","title":"The chicken and egg problem","text":"<p>The following classes have a circular dependency:</p> <pre><code>class Chicken:\n    egg: \"Egg\"\n\n\nclass Egg:\n    chicken: Chicken\n</code></pre> <p>If we try to have Rodi resolve them automatically, we get an error:</p> <pre><code>from rodi import Container\n\n\nclass Chicken:\n    egg: \"Egg\"\n\n\nclass Egg:\n    chicken: Chicken\n\n\ncontainer = Container()\ncontainer.register(Chicken)\ncontainer.register(Egg)\n\n# The following line raises an exception:\nchicken = container.resolve(Chicken)  # \ud83d\udca5\n</code></pre> <p>The raised error is:</p> <p><code>raise CircularDependencyException(chain[0], concrete_type) rodi.CircularDependencyException: A circular dependency was detected for the service of type 'Chicken' for 'Egg'</code>.</p> <p>Rodi cannot infer automatically which type should be instantiated first: Chicken or Egg?</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"getting-started/","title":"Getting started with Rodi","text":"<p>This page introduces the basics of using Rodi, including:</p> <ul> <li> An overview of dependency injection.</li> <li> The use cases Rodi is intended for.</li> </ul>"},{"location":"getting-started/#overview-of-dependency-injection","title":"Overview of dependency injection","text":"<p>Consider the following example:</p> <pre><code>class A:\n    ...\n\n\nclass B:\n    def __init__(self, dependency: A):\n        self.dependency = dependency\n</code></pre> <p>The type <code>B</code> depends upon the type <code>A</code>, because it requires an instance of <code>A</code> in its constructor. In other words, <code>A</code> is a dependency of <code>B</code>.</p> <p>For a more concrete example, consider the following:</p> <pre><code>class ProductsRepository:\n    \"\"\"Provides methods to read, write, and delete products information.\"\"\"\n\n\nclass ProductsService:\n    \"\"\"Provides business logic for managing products.\"\"\"\n\n    def __init__(self, repository: ProductsRepository):\n        self.repository = repository\n</code></pre> <p>The <code>ProductsService</code> requires an instance of <code>ProductsRepository</code>. The former handles business logic, while the latter defines a type responsible for storing, reading, and deleting product information.</p> <p>Imagine we also need to send emails when certain events happen, the <code>ProductsService</code> would likely have an additional dependency:</p> <pre><code>class ProductsService:\n    \"\"\"Provides business logic for managing products.\"\"\"\n\n    def __init__(\n        self,\n        repository: ProductsRepository,\n        email_handler: EmailHandler\n    ):\n        self.repository = repository\n        self.email_handler = email_handler\n</code></pre> <p>Encapsulating the code that performs data access operations (<code>ProductsRepository</code>) and that sends emails (<code>EmailHandler</code>) into dedicated classes is the right approach, as the same functionality can be reused in other services (e.g., OrdersService, AccountsService) without duplicating code.</p> <p>Dependencies could also be instantiated by the classes that need them:</p> <pre><code>class ProductsService:\n    \"\"\"Provides business logic for managing products.\"\"\"\n\n    def __init__(self):\n        self.repository = ProductsRepository()\n        self.email_handler = EmailHandler()\n</code></pre> <p>However, this approach has several limitations.</p> <ul> <li>Scalability Issues: As the application grows, managing dependencies   manually within classes becomes cumbersome. It can lead to duplicated code   and make the system harder to maintain.</li> <li>Tight Coupling: The <code>ProductsService</code> class is tightly coupled to   concrete implementations of its dependencies. This makes it less convenient   to replace <code>ProductsRepository</code> and <code>EmailHandler</code> with different   implementations (e.g., a mock for testing or a different database backend).</li> <li>Reduced Testability: Since dependencies are instantiated within the   class, it is necessary to modify the properties of instances of   <code>ProductsService</code>, to replace them with mocks or stubs during unit testing.</li> <li>Lack of Flexibility: If the application needs to use a different   implementation of <code>ProductsRepository</code> (e.g., for different environments or   configurations), the source code of the <code>ProductsService</code> class must be   modified.</li> <li>Code Duplication: If multiple classes need the same dependency, each   class would need to instantiate it, leading to duplicated code and increased   maintenance overhead.</li> <li>Configuration Management: Managing configuration settings (e.g., database   connection strings or API keys) becomes harder because they are scattered   across multiple classes instead of being centralized.</li> <li>Runtime Flexibility: Instantiating dependencies directly in the class   makes it harder to dynamically change or configure dependencies at runtime   (e.g., switching to a different implementation based on environment   variables).</li> </ul> <p>Alternatively, dependencies could be instantiated at the module level and managed as global variables. Instantiating dependencies as globals at module level is generally not ideal, as it leads to:</p> <ul> <li>Tight Coupling to Global State: When dependencies are global, any part of   the application can access and modify them. This makes the code tightly   coupled to the global state, leading to unpredictable behavior and bugs that   are hard to trace.</li> <li>Reduced Testability: Global dependencies make unit testing difficult   because tests cannot easily isolate or mock dependencies. Each test might   inadvertently affect or be affected by the global state, leading to flaky   tests.</li> </ul> <p>Dependency injection can help addressing the problems listed above.</p>"},{"location":"getting-started/#inversion-of-control","title":"Inversion of Control","text":"<p>Inversion of Control (IoC) is a design principle in which the control of object creation and dependency management is inverted from the class itself to an external entity, such as a framework or container. Instead of a class instantiating its dependencies directly, they are provided to the class from the outside. This promotes loose coupling and enhances testability. Dependency Injection is a common implementation of IoC.</p>"},{"location":"getting-started/#dependency-injection","title":"Dependency Injection","text":"<p>Dependency Injection is a design principle where a class does not create its own dependencies. Instead, the dependencies are provided (or \"injected\") into the class from the outside. This makes the class more flexible, easier to test, and less dependent on specific implementations.</p> <p>If we consider again the classes <code>A</code> and <code>B</code> described earlier, they can be registered and resolved using Rodi this way:</p> <pre><code># example1.py\nclass A:\n    ...\n\n\nclass B:\n    def __init__(self, dependency: A):\n        self.dependency = dependency\n</code></pre> <pre><code># main.py\nfrom example1 import A, B\n\nfrom rodi import Container\n\n\ncontainer = Container()\n\n# register types:\ncontainer.add_transient(A)\ncontainer.add_transient(B)\n\n# resolve B\nexample = container.resolve(B)\n\n# the container automatically resolves dependencies\nassert isinstance(example, B)\nassert isinstance(example.dependency, A)\n</code></pre> <p>Completely non-intrusive.</p> <p>Notice that Rodi is completely non-intrusive and does not require any changes to the source code of the types it handles. This was one of the library's primary design goals.</p> <p>In this example, both <code>A</code> and <code>B</code> are concrete types. Rodi can resolve concrete types without any issues. However, the true power of dependency injection becomes evident when we use abstract types or interfaces to define dependencies. Let's talk about the Dependency Inversion Principle.</p>"},{"location":"getting-started/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>The Dependency Inversion Principle (DIP) is a design principle that says high-level modules (like business logic) should not depend on low-level modules (like database access). Instead, both should depend on abstractions, like interfaces or abstract classes. This makes the code more flexible and easier to change because you can swap out the low-level details without affecting the high-level logic. Inversion of Control aligns with the Dependency Inversion Principle.</p> <p>Consider the following example, of <code>ProductsService</code>, <code>ProductsRepository</code>, and <code>SQLProductsRepository</code>.</p> <pre><code># domain/products.py\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    description: str\n    price: float\n\n\n# Abstraction: ProductsRepository\nclass ProductsRepository(ABC):\n    \"\"\"\n    Abstract base class for product repositories.\n    Defines the interface for data access operations.\n    \"\"\"\n\n    @abstractmethod\n    def get_all_products(self) -&gt; list[Product]:\n        \"\"\"Retrieve all products.\"\"\"\n\n    @abstractmethod\n    def get_product_by_id(self, product_id: int) -&gt; Product | None:\n        \"\"\"Retrieve a product by its ID.\"\"\"\n\n    @abstractmethod\n    def create_product(self, product: Product) -&gt; int:\n        \"\"\"Create a new product.\"\"\"\n\n\n# High-level module: ProductsService\nclass ProductsService:\n    \"\"\"\n    Provides business logic for managing products.\n    Depends on an abstract ProductsRepository.\n    \"\"\"\n\n    def __init__(self, repository: ProductsRepository):\n        self.repository = repository\n\n    def get_all_products(self) -&gt; list[Product]:\n        \"\"\"Retrieve all products.\"\"\"\n        return self.repository.get_all_products()\n\n    def get_product_by_id(self, product_id: int) -&gt; Product | None:\n        \"\"\"Retrieve a product by its ID.\"\"\"\n        return self.repository.get_product_by_id(product_id)\n\n    def create_product(self, product: Product) -&gt; int:\n        \"\"\"Create a new product.\"\"\"\n        return self.repository.create_product(product)\n</code></pre> <pre><code># data/sql/products.py\nfrom domain.products import Product, ProductsRepository\n\n\n# Low-level module: SQLProductsRepository\nclass SQLProductsRepository(ProductsRepository):\n    \"\"\"\n    Concrete implementation of ProductsRepository using a SQL database.\n    \"\"\"\n\n    def __init__(self, db_connection):\n        self.db_connection = db_connection\n\n    def get_all_products(self) -&gt; list[Product]:\n        \"\"\"Retrieve all products from the database.\"\"\"\n        cursor = self.db_connection.cursor()\n        cursor.execute(\"SELECT id, name, description, price FROM products\")\n        rows = cursor.fetchall()\n        return [\n            Product(id=row[0], name=row[1], description=row[2], price=row[3])\n            for row in rows\n        ]\n\n    def get_product_by_id(self, product_id: int) -&gt; Product | None:\n        \"\"\"Retrieve a product by its ID.\"\"\"\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            \"SELECT id, name, description, price FROM products WHERE id = ?\",\n            (product_id,),\n        )\n        row = cursor.fetchone()\n        if row:\n            return Product(id=row[0], name=row[1], description=row[2], price=row[3])\n        return None\n\n    def create_product(self, product: Product) -&gt; int:\n        \"\"\"Insert a new product into the database.\"\"\"\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            \"INSERT INTO products (name, description, price) VALUES (?, ?, ?)\",\n            (product.name, product.description, product.price),\n        )\n        self.db_connection.commit()\n        return cursor.lastrowid\n</code></pre> <p>Explanation:</p> <ul> <li>The abstraction <code>ProductsRepository</code> defines the interface for data   access operations.</li> <li>The high-level class (<code>ProductsService</code>) depends on this abstraction, not   on concrete implementations.</li> <li>The high-level class (<code>ProductsService</code>) implements business logic and   depends on the <code>ProductsRepository</code> abstraction.</li> <li><code>ProductsService</code> does not depend on the details of how data is stored or   retrieved, and it is not concerned with those details.</li> <li>The low-level class (<code>SQLProductsRepository</code>) implements the   <code>ProductsRepository</code> interface using an SQL database.</li> <li>It can be swapped out for another implementation (e.g.,   <code>InMemoryProductsRepository</code>) without modifying the <code>ProductsService</code>.</li> </ul> <pre><code>classDiagram\n    class ProductsRepository {\n        &lt;&lt;interface&gt;&gt;\n        +get_all_products() list~Product~\n        +get_product_by_id(product_id: int) Product | None\n        +create_product(product: Product) int\n    }\n\n    class SQLProductsRepository {\n        +get_all_products() list~Product~\n        +get_product_by_id(product_id: int) Product | None\n        +create_product(product: Product) int\n    }\n\n    class ProductsService {\n        -repository: ProductsRepository\n        +get_all_products() list~Product~\n        +get_product_by_id(product_id: int) Product | None\n        +create_product(product: Product) int\n    }\n\n    ProductsRepository &lt;-- SQLProductsRepository : implements\n    ProductsService --&gt; ProductsRepository : depends on</code></pre> <p>The benefits of DIP are:</p> <ul> <li>Loose Coupling: The <code>ProductsService</code> is decoupled from the specific   implementation of the repository.</li> <li>Flexibility: You can easily replace <code>SQLProductsRepository</code> with another   implementation (e.g., a mock for testing).</li> <li>Testability: The <code>ProductsService</code> can be tested independently by   injecting a mock or stub implementation of <code>ProductsRepository</code>.</li> </ul> <p>To better understand the concept, consider the following example that shows how those classes can be imported and instantiated:</p> <pre><code>import sqlite3\n\nfrom data.sql.products import SQLProductsRepository\nfrom domain.products import Product, ProductsService\n\n# Set up an SQLite database connection\nconnection = sqlite3.connect(\":memory:\")\nconnection.execute(\n    \"\"\"\n    CREATE TABLE products (\n        id INTEGER PRIMARY KEY,\n        name TEXT NOT NULL,\n        description TEXT,\n        price REAL NOT NULL\n    )\n    \"\"\"\n)\n\n# Instantiate the low-level module (SQLProductsRepository)\nsql_repository = SQLProductsRepository(connection)\n\n# Instantiate the high-level module (ProductsService)\nservice = ProductsService(sql_repository)\n\n# Use the service\nnew_product = Product(\n    id=0, name=\"Laptop\", description=\"A powerful laptop\", price=1200.00\n)\nproduct_id = service.create_product(new_product)\nprint(service.get_product_by_id(product_id))\nprint(service.get_all_products())\n</code></pre> <p>As the number of dependencies grow, the code that instantiates objects can easily become hard to maintain. To simplify the management of dependencies and reduce the complexity of object instantiation, we can leverage a dependency injection framework like Rodi.</p>"},{"location":"getting-started/#the-repository-pattern-example","title":"The Repository pattern example","text":"<p>The three classes described above: <code>ProductsService</code>, <code>ProductsRepository</code>, and <code>SQLProductsRepository</code>, can be wired using Rodi this way:</p> <pre><code>import sqlite3\n\nfrom rodi import Container\n\nfrom data.sql.products import SQLProductsRepository\nfrom domain.products import Product, ProductsRepository, ProductsService\n\n\ncontainer = Container()\n\n\ndef connection_factory() -&gt; sqlite3.Connection:\n    \"\"\"Create a new SQLite database connection.\"\"\"\n    conn = sqlite3.connect(\":memory:\")\n    conn.execute(\n        \"\"\"\n        CREATE TABLE products (\n            id INTEGER PRIMARY KEY,\n            name TEXT NOT NULL,\n            description TEXT,\n            price REAL NOT NULL\n        )\n        \"\"\"\n    )\n    return conn\n\n\ncontainer.add_transient_by_factory(connection_factory)\ncontainer.add_alias(\"db_connection\", sqlite3.Connection)\n\ncontainer.add_transient(ProductsRepository, SQLProductsRepository)\ncontainer.add_transient(ProductsService)\n\n\n# Obtain an instance of the service\nservice = container.resolve(ProductsService)\n\n# Use the service\nnew_product = Product(\n    id=0, name=\"Laptop\", description=\"A powerful laptop\", price=1200.00\n)\nproduct_id = service.create_product(new_product)\nprint(service.get_product_by_id(product_id))\nprint(service.get_all_products())\n</code></pre> <p>Some interesting things are happening in this code:</p> <ul> <li>At line 9, an instance of <code>rodi.Container</code> is created. This class is used   to register the types that must be resolved, and to resolve those types.</li> <li>It was not necessary to modify the source code of the classes being handled:   Rodi inspects the code of registered types to know how to resolve them.</li> <li>A factory function is used to define how the instance of <code>sqlite3.Connection</code>   is to be created. This is convenient because the <code>connect</code> method, which   returns an instance of that class, requires a <code>str</code>, and resolving base types   with <code>DI</code> is not a good idea.</li> <li>The factory has a return type annotation: Rodi uses that type annotation   as the key type that is resolved using the factory function. Note that a factory   might declare a more abstract type than the one it returns (following the DIP   principle).</li> <li>Since the constructor of the <code>SQLProductsRepository</code> class does not include a type   annotation for its <code>db_connection</code> dependency, an alias is configured at line 29 to   instruct the container to resolve parameters named <code>db_connection</code> as instances of   <code>sqlite3.Connection</code>. Alternatively, we could have updated the source code of   <code>SQLProductsRepository</code> to include a type annotation in its constructor.</li> <li>At line 31, the abstract type <code>ProductsRepository</code> is registered,   instructing the container to resolve that type with the concrete   implementation <code>SQLProductsRepository</code>. According to the DIP principle,   when registering an abstract type and its implementation, Rodi requires   using the abstract type as key.</li> <li>At line 32, the <code>ProductsService</code> type is also registered, because this is   required to build the graph of dependencies.</li> <li>At line 36, an instance of <code>ProductsService</code> is obtained through DI.   Since this is the first time the <code>Container</code> needs to resolve a type, it runs   code inspections to build the tree of dependencies. These code inspections   are executed only once, unless new types are registered in the same   <code>Container</code>. The container obtains all necessary objects: from the   <code>db_connection</code> and the <code>SQLProductsRepository</code> to resolve the abstract   dependency <code>ProductsRepository</code>, used to instantiate the requested   <code>ProductsService</code>.</li> </ul>"},{"location":"getting-started/#rodis-use-cases","title":"Rodi's use cases","text":"<p>Rodi is designed to simplify objects instantiation and dependency management. It can inspect constructors (<code>__init__</code> methods) and class properties to automatically resolve dependencies.</p> <p>Support for inspecting class properties is intended to reduce code verbosity. Note how in the example below, it is necessary to write three times 'dependency':</p> <pre><code>class A:\n    ...\n\n\nclass B:\n    def __init__(self, dependency: A):\n        self.dependency = dependency\n</code></pre> <p>The same classes can be written this way:</p> <pre><code>class A:\n    ...\n\nclass B:\n    dependency: A\n</code></pre> <p>Rodi would automatically instantiate <code>B</code> and populate its <code>dependency</code> property with an instance of <code>A</code>.</p> <pre><code>graph TD\n    A[Rodi] --&gt; B[Resolves __init__ methods]\n    A --&gt; C[Resolves class properties]</code></pre> Using constructorsUsing class properties <pre><code>from rodi import Container\n\nclass A:\n    ...\n\nclass B:\n    def __init__(self, dependency: A):\n        self.dependency = dependency\n\ncontainer = Container()\n\ncontainer.add_transient(A)\ncontainer.add_transient(B)\n\nexample = container.resolve(B)\nassert isinstance(example, B)\nassert isinstance(example.dependency, A)\n</code></pre> <pre><code>from rodi import Container\n\nclass A:\n    ...\n\nclass B:\n    dependency: A\n\ncontainer = Container()\n\ncontainer.add_transient(A)\ncontainer.add_transient(B)\n\nexample = container.resolve(B)\nassert isinstance(example, B)\nassert isinstance(example.dependency, A)\n</code></pre>"},{"location":"getting-started/#container-lifetime","title":"Container lifetime","text":"<p>The primary use case of Rodi is to instantiate a single <code>Container</code> object, configure it with all required dependencies at application startup, and maintain it in an immutable state throughout the application's lifetime. It is anyway possible to work with multiple containers, and to modify them even after the dependency graph has been built. Modifying a <code>Container</code> after the dependency graph has been built is an anti-pattern and can lead to unexpected behaviour. More details on this subject are provided in the next page.</p>"},{"location":"getting-started/#sync-vs-async","title":"Sync vs Async","text":"<p>Rodi is designed for synchronous code. It intentionally does not provide an asynchronous code API because object constructors should be lightweight and run synchronously. Supporting asynchronous type resolution would introduce performance overhead due to the complexity of asynchronous operations, and the extra machinery they require.</p> <p>Constructors (<code>__init__</code> methods) are typically designed to be lightweight and avoid CPU intensive blocking operations or performing I/O operations.</p>"},{"location":"getting-started/#type-annotations","title":"Type annotations","text":"<p>Rodi can use both type annotations and naming conventions to build graphs of dependencies.</p> <p>Type annotations is the recommended way to keep the code clean and explicit.</p> Using type annotations (recommended)Using naming conventions <pre><code>from rodi import Container\n\nclass A:\n    ...\n\nclass B:\n    def __init__(self, dependency: A):  # &lt;-- with type annotation\n        self.dependency = dependency\n\ncontainer = Container()\n\ncontainer.add_transient(A)\ncontainer.add_transient(B)\n\nexample = container.resolve(B)\nassert isinstance(example, B)\nassert isinstance(example.dependency, A)\n</code></pre> <pre><code>from rodi import Container\n\nclass A:\n    ...\n\nclass B:\n    def __init__(self, dependency):  # &lt;-- no type annotation\n        self.dependency = dependency\n\ncontainer = Container()\n\ncontainer.add_transient(A)\ncontainer.add_alias(\"dependency\", A)  # &lt;-- required to resolve\ncontainer.add_transient(B)\n\nexample = container.resolve(B)\nassert isinstance(example, B)\nassert isinstance(example.dependency, A)\n</code></pre>"},{"location":"getting-started/#automatic-aliases","title":"Automatic aliases","text":"<p>Rodi supports automatic aliases. When a type is registered, the container creates a set of aliases based on the class name. Consider the following example:</p> <pre><code>from rodi import Container\n\n\nclass CatsRepository: ...\n\n\nclass B:\n    def __init__(self, cats_repository):\n        self.cats_repository = cats_repository\n\n\ncontainer = Container()\n\ncontainer.add_transient(CatsRepository)\ncontainer.add_transient(B)\n\nexample = container.resolve(B)\nassert isinstance(example, B)\nassert isinstance(example.cats_repository, CatsRepository)\n</code></pre> <p>Aliases are only used when type annotations are missing. They serve solely as a fallback and always refer to a type that can be resolved.</p> <p>This design decision is based on the assumption that classes usually have names that are distinct enough to be unambiguously identified, even across namespaces.</p> <p>In the example above, the following set of aliases is created for the registered types:</p> <pre><code>{\n  'CatsRepository': {&lt;class '__main__.CatsRepository'&gt;},\n  'catsrepository': {&lt;class '__main__.CatsRepository'&gt;},\n  'cats_repository': {&lt;class '__main__.CatsRepository'&gt;},\n  'B': {&lt;class '__main__.B'&gt;},\n  'b': {&lt;class '__main__.B'&gt;}\n}\n</code></pre> <p>Disabling automatic aliases.</p> <p>Some programmers might dislike the automatic aliasing feature, as it can lead to unexpected behavior if naming conventions are not followed consistently. To disable this feature, set the <code>strict</code> parameter to <code>True</code> when creating the container:</p> <pre><code>container = Container(strict=True)\n</code></pre>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>This page covered the ABCs of Dependency Injection and Rodi. The general concepts presented here apply to others DI frameworks as well.</p> <p>The next page will start diving into Rodi's details, starting with explaining how to register types.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"registering-types/","title":"Registering types","text":"<p>This page dives into more details, covering the following subjects:</p> <ul> <li> Types lifetime.</li> <li> Options to register types.</li> <li> Using factories.</li> <li> Working with simple types.</li> <li> Support for collections.</li> <li> Working with generic types.</li> <li> The <code>Services</code> class.</li> <li> The <code>ContainerProtocol</code>.</li> </ul>"},{"location":"registering-types/#types-lifetime","title":"Types lifetime","text":"<p>Rodi supports three kinds of lifetimes:</p> <ul> <li>Singleton lifetime, for types that must be created only once per container.</li> <li>Transient lifetime, for types that must be created every time they are   requested.</li> <li>Scoped lifetime, for types that must be created once per resolution scope   (e.g. once per HTTP web request, once per user interaction).</li> </ul> <p>The next paragraphs describe each type in detail.</p>"},{"location":"registering-types/#transient-lifetime","title":"Transient lifetime","text":"<p>Transient lifetime is the most common kind for types registered in Rodi. It means that a new instance of a class will be created every time it is requested. The <code>Container</code> class offers three methods to register types with transient lifetime:</p> <ul> <li>register to register a transient type by class.</li> <li>add_transient to register a transient type by class.</li> <li>add_transient_by_factory to register a transient type by factory function.</li> </ul> registeradd_transientadd_transient_by_factory <pre><code>from rodi import Container\n\nclass A:\n    ...\n\ncontainer = Container()\n\ncontainer.register(A)\n\na1 = container.resolve(A)\na2 = container.resolve(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre> <pre><code>from rodi import Container\n\nclass A:\n    ...\n\ncontainer = Container()\n\ncontainer.add_transient(A)\n\na1 = container.resolve(A)\na2 = container.resolve(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre> <pre><code>from rodi import Container\n\nclass A:\n    ...\n\ndef a_factory() -&gt; A:\n    return A()\n\ncontainer = Container()\n\ncontainer.add_transient_by_factory(a_factory)\n\na1 = container.resolve(A)\na2 = container.resolve(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre>"},{"location":"registering-types/#singleton-lifetime","title":"Singleton lifetime","text":"<p>The singleton lifetime is used for types that should be instantiated only once per container's dependency graph. The <code>Container</code> class offers three methods to register types with singleton lifetime:</p> <ul> <li>register to register a singleton type by class and instance.</li> <li>add_instance to register a singleton using an instance.</li> <li>add_singleton to register a singleton type by class.</li> <li>add_singleton_by_factory to register a singleton type by factory function.</li> </ul> registeradd_instanceadd_singletonadd_singleton_by_factory <pre><code>from rodi import Container\n\nclass A: ...\n\ncontainer = Container()\n\ncontainer.register(A, instance=A())\n\na1 = container.resolve(A)\na2 = container.resolve(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre> <pre><code>from rodi import Container\n\nclass Cat:\n    def __init__(self, name: str):\n        self.name = name\n\ncontainer = Container()\n\ncontainer.add_instance(Cat(\"Tom\"))\n\nexample = container.resolve(Cat)\nassert isinstance(example, Cat)\nassert example.name == \"Tom\"\n</code></pre> <pre><code>from rodi import Container\n\nclass Cat:\n  pass\n\ncontainer = Container()\n\ncontainer.add_singleton(Cat)\n\nexample = container.resolve(Cat)\nassert isinstance(example, Cat)\n</code></pre> <pre><code>from rodi import Container\n\nclass Cat:\n    def __init__(self, name: str):\n        self.name = name\n\ncontainer = Container()\n\ndef cat_factory() -&gt; Cat:\n    return Cat(\"Tom\")\n\ncontainer.add_singleton_by_factory(Cat)\n\nexample = container.resolve(Cat)\nassert isinstance(example, Cat)\nassert example.name == \"Tom\"\n</code></pre> <p>Container lifecycle.</p> <p>If you modify the <code>Container</code> after the dependency tree has been created, for example registering a new type after any type has been resolved, all created singletons are discarded and will be recreated when requested again. Modifying the <code>Container</code> during the lifetime of the application is an anti-pattern, and should be avoided. It also forces the container to repeat code inspections, causing a performance fee.</p> <p>To avoid exposing the mutable <code>container</code>, use the <code>container.build_provider()</code> method, which returns an instance of <code>Services</code> that can only be used to resolve types, without modifying the tree graph. The <code>Services</code> class still offers a <code>set</code> method, which can only be used to add new singletons to the set of types that can be instantiated.</p>"},{"location":"registering-types/#scoped-lifetime","title":"Scoped lifetime","text":"<p>The scoped lifetime is used for types that should be instantiated only once per container's resolution call. The <code>Container</code> class offers two methods to register types with scoped lifetime:</p> <ul> <li>add_scoped to register a scoped type by class.</li> <li>add_scoped_by_factory to register a scoped type by factory function.</li> </ul> add_scopedadd_scoped_by_factory <pre><code>from rodi import Container\n\nclass A:\n    ...\n\nclass B:\n    context: A\n\nclass C:\n    context: A\n    dependency: B\n\ncontainer = Container()\n\ncontainer.add_scoped(A)\ncontainer.add_scoped(B)\ncontainer.add_scoped(C)\n\nc1 = container.resolve(C)  # A is created only once for both B and C\nassert isinstance(c1, C)\nassert isinstance(c1.dependency, B)\nassert isinstance(c1.context, A)\nassert c1.context is c1.dependency.context\n\nc2 = container.resolve(C)\nassert isinstance(c2, C)\nassert isinstance(c2.dependency, B)\nassert isinstance(c2.context, A)\nassert c2.context is c2.dependency.context\n\nassert c1.context is not c2.context\n</code></pre> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\nclass B:\n    context: A\n\n\nclass C:\n    context: A\n    dependency: B\n\n\ndef a_factory() -&gt; A:\n    return A()\n\n\ncontainer = Container()\n\ncontainer.add_scoped_by_factory(a_factory)\ncontainer.add_scoped(B)\ncontainer.add_scoped(C)\n\nc1 = container.resolve(C)  # A is created only once for both B and C\nassert isinstance(c1, C)\nassert isinstance(c1.dependency, B)\nassert isinstance(c1.context, A)\nassert c1.context is c1.dependency.context\n\nc2 = container.resolve(C)\nassert isinstance(c2, C)\nassert isinstance(c2.dependency, B)\nassert isinstance(c2.context, A)\nassert c2.context is c2.dependency.context\n\nassert c1.context is not c2.context\n</code></pre>"},{"location":"registering-types/#using-factories","title":"Using factories","text":"<p>add_transient_by_factory, add_singleton_by_factory, and add_scoped_by_factory accept a function that returns an instance of the type to register.</p> <p>Valid function signatures include:</p> <ul> <li><code>def factory():</code></li> <li><code>def factory(context: rodi.ActivationScope):</code></li> <li><code>def factory(context: rodi.ActivationScope, activating_type: type):</code></li> </ul> <p>The context is the current activation scope, and grants access to the set of scoped services and to the <code>ServiceProvider</code> object under construction. The <code>activating_type</code> is the type that is being activated and required resolving the service. This can be useful in some scenarios, when the returned object must vary depending on the type that required it.</p> <pre><code>from rodi import ActivationScope, Container\n\n\nclass A: ...\n\nclass B:\n    friend: A\n\nclass C: ...\n\ncontainer = Container()\n\n\ndef a_factory(context, activating_type) -&gt; A:\n    assert isinstance(context, ActivationScope)\n    assert activating_type is B\n\n    # You can obtain other types using `context.provider.get`\n    # (if they can be resolved)\n    c = context.provider.get(C)\n    assert isinstance(c, C)\n\n    return A()\n\n\ncontainer.add_transient_by_factory(a_factory)\ncontainer.add_transient(B)\ncontainer.add_transient(C)\n\nb = container.resolve(B)\nassert isinstance(b.friend, A)\n</code></pre>"},{"location":"registering-types/#working-with-simple-types","title":"Working with simple types","text":"<p>Dependency Injection loves custom types. Consider the following example:</p> <pre><code>class Example:\n    def __init__(self, api_key: str):\n        if not api_key:\n            raise ValueError(\"API key is required\")\n        self.api_key = settings.api_key\n</code></pre> <p>The <code>Example</code> class depends on a <code>str</code>. We could register a <code>str</code> singleton in our DI container, but it wouldn't make sense. Some other class might require a <code>str</code> dependency, and we would be out of options to resolve them. All types that require a simple type passed to their constructor are best configured using a factory function.</p> <pre><code>def example_factory() -&gt; Example:\n    return Example(os.environ.get(\"API_KEY\"))\n</code></pre> <p>In many cases, it is advisable to define custom types to group settings consisting of simple types into dedicated classes.</p> <p>For example:</p> <pre><code>@dataclass\nclass SendGridClientSettings:\n    api_key: str\n\n\nclass SendGridClient(EmailHandler):\n    settings: SendGridClientSettings\n    http_client: httpx.AsyncClient\n</code></pre> <p>This approach has the following benefits:</p> <ul> <li>A factory can be used to obtain the settings class.</li> <li>The more complex type can be resolved using less verbose methods that inspect   its constructor or class properties.</li> </ul>"},{"location":"registering-types/#support-for-collections","title":"Support for collections","text":"<p>Rodi supports registering and resolving collections.</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\nclass B:\n    friends: list[A]\n\n\ndef friends_factory() -&gt; list[A]:\n    return [A(), A()]\n\n\ncontainer = Container()\n\ncontainer.add_transient_by_factory(friends_factory)\ncontainer.add_transient(B)\n\nb = container.resolve(B)\nprint(b.friends)\nassert isinstance(b.friends, list)\nassert isinstance(b.friends[0], A)\nassert isinstance(b.friends[1], A)\n</code></pre> <p>Other containers such as <code>dict</code>, <code>set</code>, <code>Iterable</code>, <code>Mapping</code>, <code>Sequence</code>, <code>Tuple</code> are also supported.</p>"},{"location":"registering-types/#the-services-class","title":"The Services class","text":"<p>The <code>Container</code> class in Rodi can be used to register and resolve types, and it is mutable (new types can be registered at any time). This design decision was driven by the desire to keep the code API as simple as possible, and to enable the possibility to replace the Rodi's container with alternative implementations of dependency injection.</p> <p>Although the container is mutable, it is generally recommended to use it in the following way:</p> <ul> <li>Register all types in the container during application startup.</li> <li>Resolve types at runtime without registering new ones.</li> </ul> <p>It can be undesirable to expose the mutable <code>Container</code> to the application code, as it can lead to unexpected behavior. For this reason, the <code>Container</code> class provides a method called <code>build_provider</code>, which returns a read-only interface that can be used to resolve types, but not to register new ones (with the exception of the <code>set</code> method, which allows adding new singletons without altering the existing dependency tree).</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\ncontainer = Container()\n\ncontainer.add_transient(A)\n\nprovider = container.build_provider()\n\na1 = provider.get(A)\na2 = provider.get(A)\nassert isinstance(a1, A)\nassert isinstance(a2, A)\nassert a1 is not a2\n</code></pre>"},{"location":"registering-types/#the-containerprotocol","title":"The ContainerProtocol","text":"<p>Rodi defines a protocol for the <code>Container</code> class, named <code>ContainerProtocol</code>. This protocol defines a generic interface of the container, which includes methods for registering and resolving types, as well as checking if a type is configured in the container.</p> <p>The purpose of this protocol is to support replacing Rodi with alternative implementations of dependency injection in code that requires basic container functionality. The protocol is defined as follows:</p> <pre><code>class ContainerProtocol(Protocol):\n    \"\"\"\n    Generic interface of DI Container that can register and resolve services,\n    and tell if a type is configured.\n    \"\"\"\n\n    def register(self, obj_type: Union[Type, str], *args, **kwargs):\n        \"\"\"Registers a type in the container, with optional arguments.\"\"\"\n\n    def resolve(self, obj_type: Union[Type[T], str], *args, **kwargs) -&gt; T:\n        \"\"\"Activates an instance of the given type, with optional arguments.\"\"\"\n\n    def __contains__(self, item) -&gt; bool:\n        \"\"\"\n        Returns a value indicating whether a given type is configured in this\n        container.\n        \"\"\"\n</code></pre> <p>Since some features, like Service Lifetime are specific to Rodi (some alternative implementations only support transient and singleton lifetimes), the protocol does not define methods for registering types with different lifetimes. The protocol only defines unopinionated methods to <code>register</code> and <code>resolve</code> types, and to check if a type is configured.</p> <p>Interoperability.</p> <p>If you author code that relies on a Dependency Injection container and you want to support different implementations, you would need to decide on a common interface, or Protocol, required by your code. The <code>ContainerProtocol</code> interface was originally thought for this purpose.</p>"},{"location":"registering-types/#next-steps","title":"Next steps","text":"<p>All examples on this page show how to register and resolve concrete classes. The next page describes how to apply the Dependency Inversion Principle, how to work with abstract classes, protocols, and generics.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"},{"location":"union-types/","title":"Union types","text":"<p>This page describes support for Union types in Rodi.</p> <ul> <li> Optional dependencies.</li> <li> Union types dependencies.</li> </ul>"},{"location":"union-types/#optional-dependencies","title":"Optional dependencies","text":"<p>It is uncommon for types resolved with dependency injection to have optional dependencies, however this scenario is supported by Rodi.</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\nclass B:\n    dependency: A | None\n\n\ncontainer = Container()\ncontainer.register(A | None, A)\ncontainer.register(B)\n\nb = container.resolve(B)\nassert isinstance(b.dependency, A)\n</code></pre> <p>Optional types keys.</p> <p>Beware that if you specify a T dependency as optional, the key type used to resolve the dependency becomes the T | None and it is not just T.</p> <p>A factory function can be used to define logic that determines how the dependency must be resolved:</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\nclass B:\n    dependency: A | None\n\n\ndef a_factory() -&gt; A | None:\n    # TODO: implement logic that determines what to return\n    return None\n\n\ncontainer = Container()\ncontainer.add_transient_by_factory(a_factory)\ncontainer.register(B)\n\nb = container.resolve(B)\nassert b.dependency is None\n</code></pre>"},{"location":"union-types/#union-dependencies","title":"Union dependencies","text":"<p>Union types are also supported:</p> <pre><code>from rodi import Container\n\n\nclass A: ...\n\n\nclass B: ...\n\n\nclass C:\n    dependency: A | B\n\n\ndef ab_factory() -&gt; A | B:\n    # TODO: implement logic that determines what to return\n    return A()\n\n\ncontainer = Container()\ncontainer.add_transient_by_factory(ab_factory)\ncontainer.register(C)\n\nc = container.resolve(C)\nassert isinstance(c.dependency, A)\n</code></pre> <p>Union types keys.</p> <p>Beware that if you specify a union dependency such as T | U the key type used to resolve the dependency is T | U. Trying to use T or U singularly causes a <code>CannotResolveTypeException</code>.</p> <p>The next page provides an overview of errors raised by Rodi.</p> <p>Last modified on: 2025-04-13 14:25:25</p>RP"}]}