{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BlackSheep is an asynchronous web framework to build event-based web applications with Python.","text":"<pre><code>pip install blacksheep\n</code></pre>"},{"location":"#blacksheep-offers","title":"BlackSheep offers...","text":"<ul> <li>A rich code API, based on dependency injection and inspired by Flask and   ASP.NET Core.</li> <li>A typing-friendly codebase, which enables a comfortable development   experience thanks to hints when coding with IDEs.</li> <li>Built-in generation of OpenAPI Documentation, supporting version 3, YAML, and   JSON.</li> <li>A cross-platform framework, using the most modern versions of Python.</li> <li>Good performance.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with BlackSheep, read these tutorials:</p> <ul> <li>Basics</li> <li>The MVC template</li> </ul>"},{"location":"#versions","title":"Versions","text":"<p>The documentation here refers to the current version of the web framework. For the documentation of the first version of the framework, use the links below:</p> <p>Version 1</p><p>The documentation of version 1 of the web framework is published at <code>/blacksheep/v1/</code> </p> <p>Migrating from v1 to v2</p><p>Go to the summary of changes between version 1 and version 2 of the web framework.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"about/","title":"About BlackSheep","text":"<p>BlackSheep is a web framework for Python asyncio designed to facilitate the implementation of stateless APIs and general-purpose web applications. It is inspired by Flask and ASP.NET Core; it recreates several features from both these web frameworks. The concept of automatic binding of request parameters by the request handler's signature and dependency injection of required services (as it happens in ASP.NET Core) is what makes BlackSheep unique today, in the context of Python web frameworks.</p> <p>The project, like several other web frameworks for Python, is the fruit of the creative ferment around Yury Selivanov\u2019s work, and the article uvloop: Blazing fast Python networking from 2016.</p> <p>The project originally included an implementation of HTTP Server, but this was removed, and the web framework was abstracted from an exact HTTP Server and made compatible with ASGI HTTP Servers. This was a good move because the effort on the project can stay focused on higher-level features, while benefitting from the existing ecosystem and help from the Python community in implementing HTTP Servers (e.g. support for HTTP2).</p>"},{"location":"about/#the-projects-home","title":"The project's home","text":"<p>The project is hosted in GitHub, handled following DevOps good practices, features 100% code coverage, and is published to pypi.org.</p> <p> </p>"},{"location":"about/#why-the-name-blacksheep","title":"Why the name BlackSheep","text":"<p>The name BlackSheep was chosen for two reasons:</p> <ul> <li>to refer to the \"black sheep\" idiom, used to describe one who is unlike   other members of a family, group, or organization, sometimes due to   intentional   rebelliousness -   especially for the choice of giving so much importance to dependency   injection (which is not very popular in Python community, or was not   popular when BlackSheep was started), asynchronous coding and type   annotations (which are still debated upon in Python community, or were   debated upon when BlackSheep was started), and for being a Python web   framework inspired by ASP.NET\u00a0Core.</li> <li>as a tribute to the song The Sinking Belle (Black Sheep) of the album   Altar, by Boris and   Sunn\u00a0O))).</li> </ul> <p>Last modified on: 2025-04-01 23:22:49</p>RPEW"},{"location":"anti-request-forgery/","title":"Preventing Cross-Site Request Forgery (XSRF/CSRF)","text":"<p>Cross-site request forgery, also known as XSRF or CSRF, is a kind of attack that exploits situations in which browsers automatically include credentials in web requests.</p> <p>Examples of such situations are:</p> <ul> <li>Cookies are automatically included in web requests, so if an application uses   cookie-based authentication, credentials are sent automatically.</li> <li>After a user signs in with Basic or Digest authentication, the browser   automatically sends the credentials until the session ends.</li> </ul> <p>If a web application uses cookie-based authentication or other features that cause credentials to be automatically included in web requests, it requires anti-forgery measures.</p> <p>BlackSheep implements built-in support for anti-request-forgery validation, this page describes how to use it.</p> <p>Options using HTML5 Storage.</p> <p>Applications that store access tokens (for example JWTs) in the HTML5 storage and include them in <code>Authorization: Bearer {...}</code> headers, are not vulnerable to CSRF and do not require anti-forgery measures.</p>"},{"location":"anti-request-forgery/#how-to-use-the-built-in-anti-forgery-validation","title":"How to use the built-in anti-forgery validation","text":"<p>To enable anti-forgery validation, use the module <code>blacksheep.server.csrf</code>:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.csrf import use_anti_forgery\n\n\napp = Application(show_error_details=True)\n\nuse_anti_forgery(app)\n</code></pre> <p>The <code>use_anti_forgery(app)</code> function configures middleware to issue and validate anti-forgery tokens, as well as extensions for Jinja2 templates to render these tokens in HTML templates. It is important to configure templating before enabling anti-forgery, as the latter sets up extensions in the Jinja2 environment.</p> <p>Consider an example having this folder structure:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.jinja\n\u2514\u2500\u2500 server.py\n</code></pre> <p>Where <code>server.py</code> contains the following code:</p> <pre><code>from blacksheep import Application, FromForm, get, post, view\nfrom blacksheep.server.csrf import use_anti_forgery\n\n\napp = Application()\n\nuse_anti_forgery(app)\n\n\n@get(\"/\")\ndef home(request):\n    return view(\"index\", {}, request=request)\n\n\nclass CreateUserInput:\n    def __init__(self, username: str, **kwargs):\n        self.username = username\n\n\n@post(\"/user\")\nasync def create_user(data: FromForm[CreateUserInput]):\n    \"\"\"Calls to this endpoint require an anti-forgery token.\"\"\"\n    return {\"example\": True, \"username\": data.value.username}\n</code></pre> <p>And <code>index.jinja</code> contains the following template:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"/user\" method=\"post\"&gt;\n        {% af_input %}\n        &lt;input type=\"text\" name=\"username\" /&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The <code>{% af_input %}</code> tag renders an HTML input element containing an anti-forgery token. The built-in solution uses the Double-Token strategy. When an anti-forgery token is required to render HTML, a corresponding HTTP-only cookie is included in the response. The cookie's value and the control parameter are matched in subsequent requests for validation. Contextually, response headers are also set to protect the HTML view against click-jacking and to forbid iframes.</p> <p>Alternative tags.</p> <p>In alternative to <code>{% af_input %}</code>, it is possible to use the tag <code>{% csrf_input %}</code> (like Django). However, <code>af_input</code> is recommended since the objective of the tag is to obtain an input element containing an anti-forgery token, not to achieve Cross-Site Request Forgery!</p> <p>An example of a rendered view looks like the following:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"/user\" method=\"post\"&gt;\n        &lt;input type=\"hidden\" name=\"__RequestVerificationToken\" value=\"IlY2ejJ2MmQyWkZoUVo0ekxLdE9WVU9wQzhtR0dKbDNrdm1KVlc2SGwi.kAXPtBV3gFePzQQXRd0cO9fWOt0\" /&gt;\n        &lt;input type=\"text\" name=\"username\" /&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Validation is applied by default to all <code>DELETE PATCH POST PUT</code> web requests. Requests using other methods are not validated as they are not supposed to change the state and should execute read-only operations.</p> <p>Important note about token generation.</p> <p>Tokens are signed using symmetric encryption. For your production environments, configure application secrets using environment variables as described in data protection.</p>"},{"location":"anti-request-forgery/#how-to-send-the-anti-forgery-token","title":"How to send the anti-forgery token","text":"<p>The anti-forgery token can be sent to the server in one of the following ways:</p> Location Parameter Name Form parameter <code>__RequestVerificationToken</code> Header <code>RequestVerificationToken</code> <p>To use custom parameter names, refer to the <code>AntiForgeryHandler</code> class in <code>blacksheep.server.csrf</code>.</p>"},{"location":"anti-request-forgery/#example-using-controllers","title":"Example using Controllers","text":"<pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 home\n\u2502\u00a0\u00a0      \u00a0\u00a0 \u2514\u2500\u2500 index.jinja\n\u2514\u2500\u2500 server.py\n</code></pre> <p><code>server.py</code></p> <pre><code>from blacksheep import Application, FromForm\nfrom blacksheep.server.controllers import Controller, get, post\nfrom blacksheep.server.csrf import use_anti_forgery\n\napp = Application(show_error_details=True)\n\nuse_anti_forgery(app)\n\n\nclass CreateUserInput:\n    def __init__(self, username: str, **kwargs):\n        self.username = username\n\n\nclass Home(Controller):\n    @get(\"/\")\n    async def index(self, request):\n        return self.view(\"index\", {}, request=request)\n\n    @post(\"/user\")\n    async def create_user(self, data: FromForm[CreateUserInput]):\n        \"\"\"Calls to this endpoint require an anti-forgery token.\"\"\"\n        return {\"example\": True, \"username\": data.value.username}\n</code></pre> <p><code>index.jinja</code> (like in the previous example).</p>"},{"location":"anti-request-forgery/#rendering-anti-forgery-tokens-without-input-elements","title":"Rendering anti-forgery tokens without input elements","text":"<p>The tag <code>{% af_token %}</code> can be used to render an anti-forgery value without rendering an HTML input element. For example to render it inside JavaScript:</p> <pre><code>&lt;script&gt;\n    EXAMPLE = {\"token\": \"{% af_token %}\"}\n&lt;/script&gt;\n</code></pre>"},{"location":"anti-request-forgery/#excluding-request-handlers-from-validation","title":"Excluding request handlers from validation","text":"<p>Use the <code>ignore_anti_forgery</code> decorator to exclude particular request handlers from anti-forgery validation:</p> <pre><code>from blacksheep.server.csrf import ignore_anti_forgery\n\n\n@ignore_anti_forgery()\n@post(\"/example\")\nasync def create_example():\n    \"\"\"This endpoint does not require an anti-forgery token.\"\"\"\n</code></pre>"},{"location":"anti-request-forgery/#custom-antiforgeryhandler-classes","title":"Custom AntiForgeryHandler classes","text":"<p>The following example demonstrates how to override methods of the <code>AntiForgeryHandler</code>:</p> <pre><code>from blacksheep.server.csrf import AntiForgeryHandler, use_anti_forgery\n\n\nclass CustomAntiForgeryHandler(AntiForgeryHandler):\n    pass\n\n\nuse_anti_forgery(app, handler=CustomAntiForgeryHandler())\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"application/","title":"The Application class","text":"<p>The <code>Application</code> class in BlackSheep is responsible for handling the application life cycle (start, working state, stop), routing, web requests, and exceptions. This page describes the details of the <code>Application</code> class:</p> <ul> <li> How to handle errors.</li> <li> Application events and life cycle.</li> </ul>"},{"location":"application/#handling-errors","title":"Handling errors","text":"<p>BlackSheep catches any unhandled exception that happen during the execution of request handlers, producing an <code>HTTP 500 Internal Server Error</code> response. To see this in practice, start an application like the following:</p> <pre><code>from blacksheep import Application, get\n\napp = Application()\n\n\n@get(\"/\")\ndef crash_test():\n    raise Exception(\"Crash test\")\n</code></pre> <p>And observe how a request to its root produces a response with HTTP status 500, and the text \"Internal server error\".</p> <p>Exception details are hidden from the client by default: it would be a security issue if the web application returned error details to the client. However, while developing and occasionally while investigating issues, it is useful to be able to obtain error details directly from the web requests that are failing. To enable error details, update the app declaration as follows:</p> <pre><code>app = Application(show_error_details=True)\n</code></pre> <p>Now the application returns the details of the exception with the full stack trace, serving a page like the following:</p> <p></p> <p>Use the <code>APP_SHOW_ERROR_DETAILS</code>.</p> <p>Rather than using the <code>show_error_details</code> parameter, it is recommended to use the environment variable <code>APP_SHOW_ERROR_DETAILS</code> to control whether the application displays detailed error information. Setting <code>APP_SHOW_ERROR_DETAILS=1</code> or <code>APP_SHOW_ERROR_DETAILS=True</code> enables this feature.</p> <p>Settings strategy</p> <p>BlackSheep project templates include a strategy to handle application settings and configuration roots. Refer to Getting started with the MVC project template for more information.</p>"},{"location":"application/#configuring-exceptions-handlers","title":"Configuring exceptions handlers","text":"<p>The BlackSheep <code>Application</code> object has an <code>exceptions_handlers</code> dictionary that defines how errors should be handled. When an exception happens while handling a web request and reaches the application, the application checks if there is a matching handler for that kind of exception. An exception handler is defined as a function with the following signature:</p> <pre><code>from blacksheep import Request, Response, text\n\nasync def exception_handler(self, request: Request, exc: Exception) -&gt; Response:\n    pass\n</code></pre> <pre><code>class CustomException(Exception):\n    pass\n\nasync def exception_handler(self, request, exc: CustomException):\n    nonlocal app\n    assert self is app\n    assert isinstance(exc, CustomException)\n    return text(\"Called\")\n\n\n# Register the exception handler for the CustomException type:\napp.exceptions_handlers[CustomException] = exception_handler\n\n\n@get('/')\nasync def home(request):\n    # of course, the exception can be raised at any point\n    # for example in the business logic layer\n    raise CustomException()\n</code></pre> <p>Exceptions inheriting from <code>HTTPException</code> can be mapped to handlers by their type or by their status code, using <code>int</code> keys; while user-defined exceptions are mapped to handlers by their type.</p> <p>When an exception handler is registered for a type of exception, all subclasses are also handled by that handler. It is however possible to define a more specific handler for one of the descendant classes.</p>"},{"location":"application/#configuring-exception-handlers-using-decorators","title":"Configuring exception handlers using decorators","text":"<p>It is also possible to register exception handlers using decorators, instead of interacting with <code>app.exceptions_handlers</code> dictionary:</p> <pre><code>class CustomException(Exception):\n    pass\n\n\n@app.exception_handler(CustomException)\nasync def handler_example(self, request, exc: CustomException):\n    ...\n</code></pre>"},{"location":"application/#overriding-the-default-exception-handler-for-unhandled-exceptions","title":"Overriding the default exception handler for unhandled exceptions","text":"<p>To override how unhandled exceptions are handled, define a custom <code>Application</code> class overriding its <code>handle_internal_server_error</code> method, like in the following example:</p> <pre><code>from blacksheep import Application, json\nfrom blacksheep.messages import Request\n\n\nclass MyApp(Application):\n    async def handle_internal_server_error(self, request: Request, exc: Exception):\n        # TODO: handle this as you wish!\n        return json({\"message\": \"Oh, no!\"}, 500)\n</code></pre>"},{"location":"application/#application-events","title":"Application events","text":"<p>A BlackSheep application exposes three events: on_start, after_start, on_stop. These events can be used to configure callbacks and services that depend on the application lifecycle. The application class also offers a useful method to configure objects that need to be initialized when the application starts, and disposed of when the application stops: lifespan.</p>"},{"location":"application/#using-the-lifespan-decorator","title":"Using the lifespan decorator","text":"<p>The <code>Application.lifespan</code> method can be used to register objects bound to the application life cycle. Common examples of such objects are HTTP clients and database clients, since they use connection pools that can be initialized and must be disposed of when the application stops.</p> <p>The following example illustrates how to use the <code>@app.lifespan</code> decorator to create an HTTP <code>ClientSession</code> that will be disposed of when the application stops. Note how the instance of <code>ClientSession</code> is also bound to application services, so that it can be injected into request handlers that need it.</p> <pre><code>import asyncio\nfrom blacksheep import Application\nfrom blacksheep.client.pool import ClientConnectionPools\nfrom blacksheep.client.session import ClientSession\n\napp = Application()\n\n\n@app.lifespan\nasync def register_http_client():\n    async with ClientSession(\n        pools=ClientConnectionPools(asyncio.get_running_loop())\n    ) as client:\n        print(\"HTTP client created and registered as singleton\")\n        app.services.register(ClientSession, instance=client)\n        yield\n\n    print(\"HTTP client disposed of\")\n\n\n@router.get(\"/\")\nasync def home(http_client: ClientSession):\n    print(http_client)\n    return {\"ok\": True, \"client_instance_id\": id(http_client)}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=44777, log_level=\"debug\", lifespan=\"on\")\n</code></pre> <ul> <li>The code before the <code>yield</code> statement (lines 11-16) is executed when the   application starts.</li> <li>The code after the <code>yield</code> statement (lines 17-18) is executed when the   application stops.</li> </ul> <p>@app.lifespan</p> <p>This method leverages <code>contextlib.asynccontextmanager</code>. What is defined before the <code>yield</code> statement executes when the application starts, and what is defined after the <code>yield</code> statement executes when the application stops.</p> <p>The following example illustrates how a <code>redis-py</code> connection can be disposed of using <code>@app.lifespan</code>:</p> <pre><code>import redis.asyncio as redis\n\n...\n\n@app.lifespan\nasync def configure_redis():\n    \"\"\"\n    Configure an async Redis client, and dispose of its connections when the\n    application stops.\n    See:\n    https://redis.readthedocs.io/en/stable/examples/asyncio_examples.html\n    \"\"\"\n    connection = redis.Redis()\n    print(f\"Ping successful: {await connection.ping()}\")\n\n    app.services.register(redis.Redis, instance=connection)\n\n    yield connection\n\n    print(\"Disposing the Redis connection pool...\")\n    await connection.close()\n</code></pre>"},{"location":"application/#on_start","title":"on_start","text":"<p>This event should be used to configure components such as new request handlers and services registered in <code>app.services</code>, including database connection pools and HTTP client sessions.</p>"},{"location":"application/#after_start","title":"after_start","text":"<p>This event should be used to configure tasks that must occur after request handlers are normalized. At this stage, the application router contains information about the actual routes handled by the web application, allowing routes to be inspected. For example, the built-in OpenAPI documentation generation creates the API specification file at this point.</p> <p>Example: inspecting routes.</p> <p>An <code>after_start</code> callback that prints all routes registered in the application router:</p> <pre><code>@app.after_start\nasync def after_start_print_routes(application: Application) -&gt; None:\n    print(application.router.routes)\n</code></pre>"},{"location":"application/#on_stop","title":"on_stop","text":"<p>This event should be used to trigger callbacks that need to run when the application stops. For example, it can be used to dispose of services that require cleanup, such as database connection pools and HTTP client sessions using connection pools.</p>"},{"location":"application/#application-life-cycle","title":"Application life cycle","text":"<p>Refer to the following diagram to know more about when application events are fired, and the state of the application when they are executed.</p> <p></p>"},{"location":"application/#how-to-register-event-handlers","title":"How to register event handlers","text":"Using decoratorsUsing += <p>Event handlers can be registered using decorators.</p> <pre><code>from blacksheep import Application, Request, Response, text, get\n\n\napp = Application()\n\n\n@get(\"/\")\nasync def home(request: Request) -&gt; Response:\n    return text(\"Example Async\")\n\n\n@app.on_start\nasync def on_start(application: Application) -&gt; None:\n    print(\"On start\")\n\n\n@app.after_start\nasync def after_start(application: Application) -&gt; None:\n    print(\"After start\")\n\n\n@app.on_stop\nasync def on_stop(application: Application) -&gt; None:\n    print(\"On stop\")\n</code></pre> <p>In alternative to decorators, event handlers can be registered using <code>+=</code>:</p> <pre><code>from blacksheep import Application, Request, Response, text, get\n\n\napp = Application()\n\n\n@get(\"/\")\nasync def home(request: Request) -&gt; Response:\n    return text(\"Example Async\")\n\n\nasync def before_start(application: Application) -&gt; None:\n    print(\"Before start\")\n\n\nasync def after_start(application: Application) -&gt; None:\n    print(\"After start\")\n\n\nasync def on_stop(application: Application) -&gt; None:\n    print(\"On stop\")\n\n\napp.on_start += before_start\napp.after_start += after_start\napp.on_stop += on_stop\n</code></pre>"},{"location":"application/#next","title":"Next","text":"<p>Read about the details of routing in BlackSheep.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPDEWRV"},{"location":"asgi/","title":"ASGI Servers","text":"<p>BlackSheep is an ASGI web framework, which requires an ASGI HTTP server to run, such as Uvicorn, or Hypercorn. All examples in this documentation use <code>Uvicorn</code>, but the framework has also been tested with Hypercorn and should work with any server that implements the <code>ASGI</code> specification.</p>"},{"location":"asgi/#uvicorn","title":"Uvicorn","text":""},{"location":"asgi/#hypercorn","title":"Hypercorn","text":"<p>Many details, such as how to run the server in production, depend on the chosen ASGI server.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RP"},{"location":"authentication/","title":"Authentication in BlackSheep","text":"<p>The term 'authentication strategy' in the context of a web application refers to the process of identifying the user accessing the application. BlackSheep provides a built-in authentication strategy for request handlers. This page covers:</p> <ul> <li> How to use the built-in authentication strategy.</li> <li> How to configure a custom authentication handler.</li> <li> How to use the built-in support for JWT Bearer authentication.</li> <li> How to read the user's context in request handlers.</li> </ul> <p>Additional dependencies.</p> <p>Using JWT Bearer and OpenID integrations requires additional dependencies. Install them by running: <code>pip install blacksheep[full]</code>.</p>"},{"location":"authentication/#underlying-library","title":"Underlying library","text":"<p>The authentication and authorization logic for BlackSheep is packaged and published in a dedicated library: <code>guardpost</code> (in pypi).</p>"},{"location":"authentication/#how-to-use-built-in-authentication","title":"How to use built-in authentication","text":"<p>Common strategies for identifying users in web applications include:</p> <ul> <li>Reading an <code>Authorization: Bearer xxx</code> request header containing a JWT.   with claims that identify the user.</li> <li>Reading a signed token from a cookie.</li> </ul> <p>The following sections first explain how to use the built-in support for JWT Bearer tokens and then describe how to write a custom authentication handler.</p> <p>Terms: user, service, principal.</p> <p>The term 'user' typically refers to human users, while 'service' describes non-human clients. In Java and .NET, the term 'principal' is commonly used to describe a generic identity.</p>"},{"location":"authentication/#oidc","title":"OIDC","text":"<p>BlackSheep implements built-in support for OpenID Connect authentication, meaning that it can be easily integrated with identity provider services such as:</p> <ul> <li>Auth0.</li> <li>Entra ID.</li> <li>Azure Active Directory B2C.</li> <li>Okta.</li> </ul> <p>Examples in GitHub.</p> <p>The Neoteroi/BlackSheep-Examples/ repository in GitHub contains examples of JWT Bearer authentication and OpenID Connect integrations.</p> <p>A basic example of integration with any of the identity providers listed above, using implicit flow for <code>id_token</code> (which removes the need to handle secrets), is shown below:</p> <pre><code>from blacksheep import Application, get, html, pretty_json\nfrom blacksheep.server.authentication.oidc import OpenIDSettings, use_openid_connect\nfrom guardpost.authentication import Identity\n\napp = Application()\n\n\n# basic Auth0 integration that handles only an id_token\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"&lt;YOUR_AUTHORITY&gt;\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        callback_path=\"&lt;CALLBACK_PATH&gt;\",\n    ),\n)\n\n\n@get(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        response = pretty_json(user.claims)\n\n        return response\n\n    return html(\"&lt;a href='/sign-in'&gt;Sign in&lt;/a&gt;&lt;br/&gt;\")\n</code></pre> <p>Where:</p> Parameter Description YOUR_AUTHORITY The URL to your account, like <code>https://neoteroi.eu.auth0.com</code> CLIENT_ID Your app registration ID CALLBACK_PATH The path that is enabled for <code>reply_uri</code> in your app settings, for example if you enabled for localhost: <code>http://localhost:5000/authorization-callback</code>, the value should be <code>/authorization-callback</code> <p>For more information and examples, refer to the dedicated page about OpenID Connect authentication.</p>"},{"location":"authentication/#jwt-bearer","title":"JWT Bearer","text":"<p>BlackSheep implements built-in support for JWT Bearer authentication, and validation of JWTs:</p> <ul> <li>Issued by identity providers implementing OpenID Connect (OIDC) discovery   (such as Auth0, Microsoft Entra ID).</li> <li>And more in general, JWTs signed using asymmetric encryption and verified   using public RSA keys.</li> </ul> <p>The following example shows how to configure JWT Bearer authentication for an application registered in <code>Microsoft Entra ID</code>, and also how to configure authorization to restrict access to certain methods, only for users who are successfully authenticated:</p> <pre><code>from guardpost import Policy, User\nfrom guardpost.common import AuthenticatedRequirement\n\nfrom blacksheep import Application, get, json\nfrom blacksheep.server.authentication.jwt import JWTBearerAuthentication\nfrom blacksheep.server.authorization import auth\n\napp = Application()\n\napp.use_authentication().add(\n    JWTBearerAuthentication(\n        authority=\"https://login.microsoftonline.com/&lt;YOUR_TENANT_NAME&gt;.onmicrosoft.com\",\n        valid_audiences=[\"&lt;YOUR_APP_CLIENT_ID&gt;\"],\n        valid_issuers=[\"https://login.microsoftonline.com/&lt;YOUR_TENANT_ID&gt;/v2.0\"],\n    )\n)\n\n# configure authorization, to restrict access to methods using @auth decorator\nauthorization = app.use_authorization()\n\nauthorization += Policy(\"example_name\", AuthenticatedRequirement())\n\n\n@get(\"/\")\ndef home():\n    return \"Hello, World\"\n\n\n@auth(\"example_name\")\n@get(\"/api/message\")\ndef example():\n    return \"This is only for authenticated users\"\n\n\n@get(\"/open/\")\nasync def open(user: User | None):\n    if user is None:\n        return json({\"anonymous\": True})\n    else:\n        return json(user.claims)\n</code></pre> <p>The built-in handler for JWT Bearer authentication does not currently support JWTs signed with symmetric keys. Support for symmetric keys might be added in the future.</p> <p>\ud83d\udca1</p> <p>It is possible to configure several JWTBearerAuthentication handlers, for applications that need to support more than one identity provider. For example, for applications that need to support sign-in through Auth0, Azure Active Directory, Azure Active Directory B2C.</p>"},{"location":"authentication/#writing-a-custom-authentication-handler","title":"Writing a custom authentication handler","text":"<p>The example below shows how to configure a custom authentication handler that obtains the user's identity for each web request.</p> <pre><code>from blacksheep import Application, Request, auth, get, json\nfrom guardpost import AuthenticationHandler, Identity, User\n\n\napp = Application(show_error_details=True)\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Identity | None:\n        # TODO: apply the desired logic to obtain a user's identity from\n        # information in the web request, for example reading a piece of\n        # information from a header (or cookie).\n        header_value = context.get_first_header(b\"Authorization\")\n\n        if header_value:\n            # implement your logic to obtain the user\n            # in this example, an identity is hard-coded just to illustrate\n            # testing in the next paragraph\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            # if the request cannot be authenticated, set the context.identity\n            # to None - do not throw exception because the app might support\n            # different ways to authenticate users\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n\n\n@get(\"/\")\ndef home():\n    return \"Hello, World\"\n\n\n@auth(\"example_name\")\n@get(\"/api/message\")\ndef example():\n    return \"This is only for authenticated users\"\n\n\n@get(\"/open/\")\nasync def open(user: User | None):\n    if user is None:\n        return json({\"anonymous\": True})\n    else:\n        return json(user.claims)\n</code></pre> <p>It is possible to configure several authentication handlers to implement different ways to identify users. To distinguish how the user was authenticated, use the second parameter of the Identity constructor:</p> <pre><code>identity = Identity({\"name\": \"Jan Kowalski\"}, \"AUTHENTICATION_MODE\")\n</code></pre> <p>The authentication context is the <code>Request</code> instance created to handle the incoming web request. Authentication handlers must set the <code>identity</code> property on the request to enable the automatic injection of <code>user</code> via dependency injection.</p>"},{"location":"authentication/#testing-the-example","title":"Testing the example","text":"<p>To test the example above, start a web server as explained in the getting started guide, then navigate to its root. A web request to the root of the application without an <code>Authorization</code> header will produce a response with the following body:</p> <pre><code>{\"anonymous\":true}\n</code></pre> <p>While a web request with an <code>Authorization</code> header will produce a response with the following body:</p> <pre><code>{\"name\":\"Jan Kowalski\"}\n</code></pre> <p>For example, to generate web requests using <code>curl</code>:</p> <pre><code>curl  http://127.0.0.1:44555/open\n</code></pre> <p>Gets the output: <code>{\"anonymous\":true}</code>.</p> <pre><code>curl -H \"Authorization: foo\" http://127.0.0.1:44555/open\n</code></pre> <p>Gets the output: <code>{\"name\":\"Jan Kowalski\"}</code>.</p> <p>The application has been started on port 44555 (e.g. <code>uvicorn server:app --port=44555</code>).</p>"},{"location":"authentication/#reading-a-users-context","title":"Reading a user's context","text":"<p>The example below shows how a user's identity can be read from the web request:</p> Using binders (recommended)Directly from the request <pre><code>from guardpost.authentication import Identity\n\n\n@get(\"/\")\nasync def for_anybody(user: Identity | None):\n    ...\n</code></pre> <pre><code>@get(\"/\")\nasync def for_anybody(request: Request):\n    user = request.identity\n    # user can be None or an instance of Identity (set in the authentication\n    # handler)\n</code></pre>"},{"location":"authentication/#next","title":"Next","text":"<p>While authentication focuses on identifying users, authorization determines whether a user is permitted to perform the requested action. The next page describes the built-in authorization strategy in BlackSheep.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"authorization/","title":"Authorization in BlackSheep","text":"<p>The term 'authorization strategy' in the context of a web application refers to the process of determining whether a user is permitted to perform certain operations. BlackSheep provides a built-in authorization strategy for request handlers. This page covers:</p> <ul> <li> How to use the built-in authorization strategy.</li> <li> How to apply authorization rules to request handlers.</li> </ul> <p>It is recommended to review the authentication documentation before proceeding with this page.</p>"},{"location":"authorization/#how-to-use-built-in-authorization","title":"How to use built-in authorization","text":"<p>Common strategies for authorizing users in web applications include:</p> <ul> <li>Verifying that the user's context, obtained from a JWT,   includes certain claims (e.g., <code>scope</code>, <code>role</code>)</li> <li>Verifying that a web request contains a specific key, such as an   instrumentation key or a key signed by a private RSA key (owned by the user)   and validated by a public RSA key (used by the server).</li> </ul> <p>The following example demonstrates how to configure an authorization handler that requires an authenticated user. It is adapted from the example on the authentication's documentation page:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request, json, ok, get\nfrom blacksheep.server.authorization import Policy, auth\nfrom guardpost.asynchronous.authentication import AuthenticationHandler, Identity\nfrom guardpost.authentication import User\nfrom guardpost.common import AuthenticatedRequirement\n\napp = Application(show_error_details=True)\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        header_value = context.get_first_header(b\"Authorization\")\n        if header_value:\n            # TODO: parse and validate the value of the authorization\n            # header to get an actual user's identity\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n\nAuthenticated = \"authenticated\"\n\n# enable authorization, and add a policy that requires an authenticated user\napp.use_authorization().add(Policy(Authenticated, AuthenticatedRequirement()))\n\n\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n\n\n@auth(Authenticated)\n@get(\"/account\")\nasync def only_for_authenticated_users():\n    return ok(\"example\")\n</code></pre> <ul> <li>Authorization is enabled by calling <code>app.use_authorization()</code>. This method   returns an instance of <code>AuthorizationStrategy</code>, which manages the   authorization rules.</li> <li>The method <code>.add(Policy(Authenticated, AuthenticatedRequirement()))</code>   configures an authorization policy with a single requirement, to have an   authenticated user.</li> <li>The authorization policy is applied to request handlers using the <code>@auth</code>   decorator from <code>blacksheep.server.authorization</code> with an argument that   specifies the policy to be used.</li> </ul> <p>It is possible to define several authorization policies, each specifying one or more requirements to be satisfied in order for authorization to succeed.</p>"},{"location":"authorization/#defining-an-authorization-policy-that-checks-claims","title":"Defining an authorization policy that checks claims","text":"<p>The following example demonstrates how to configure an authorization handler that validates a user's claims, such as checking for a <code>role</code> claim that may originate from a JWT.</p> <pre><code>from blacksheep.server.authorization import Policy\n\nfrom guardpost.authorization import AuthorizationContext\nfrom guardpost.authorization import Requirement\n\n\nclass AdminRequirement(Requirement):\n    def handle(self, context: AuthorizationContext):\n        identity = context.identity\n\n        if identity is not None and identity.claims.get(\"role\") == \"admin\":\n            context.succeed(self)\n\n\nclass AdminsPolicy(Policy):\n    def __init__(self):\n        super().__init__(\"admin\", AdminRequirement())\n</code></pre> <p>Full example:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request, get, json, ok\nfrom blacksheep.server.authorization import Policy, auth\nfrom guardpost import (\n    AuthenticationHandler,\n    Identity,\n    User,\n    AuthorizationContext,\n    Requirement,\n)\nfrom guardpost.common import AuthenticatedRequirement\n\napp = Application(show_error_details=True)\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        header_value = context.get_first_header(b\"Authorization\")\n        if header_value:\n            # TODO: parse and validate the value of the authorization\n            # header to get an actual user's identity\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n\nAuthenticated = \"authenticated\"\n\n\nclass AdminRequirement(Requirement):\n    def handle(self, context: AuthorizationContext):\n        identity = context.identity\n\n        if identity is not None and identity.claims.get(\"role\") == \"admin\":\n            context.succeed(self)\n\n\nclass AdminPolicy(Policy):\n    def __init__(self):\n        super().__init__(\"admin\", AdminRequirement())\n\n\napp.use_authorization().add(Policy(Authenticated, AuthenticatedRequirement())).add(\n    AdminPolicy()\n)\n\n\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    # This method can be used by anybody\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n\n\n@auth(Authenticated)\n@get(\"/account\")\nasync def only_for_authenticated_users():\n    # This method can be used by any authenticated user\n    return ok(\"example\")\n\n\n@auth(\"admin\")\n@get(\"/admin\")\nasync def only_for_administrators():\n    # This method requires \"admin\" role in user's claims\n    return ok(\"example\")\n</code></pre>"},{"location":"authorization/#using-the-default-policy","title":"Using the default policy","text":"<p>The <code>app.use_authorization()</code> method returns an instance of <code>AuthorizationStrategy</code> from the <code>guardpost</code> library. This object can be configured to use a default policy, such as requiring an authenticated user by default for all request handlers.</p> <pre><code>authorization = app.use_authorization()\n\n# configure a default policy to require an authenticated user for all handlers\nauthorization.default_policy = Policy(\"authenticated\", AuthenticatedRequirement())\n</code></pre> <p>The default policy is used when the <code>@auth</code> decorator is used without arguments.</p> <p>To enable anonymous access for certain handlers in this scenario, use the <code>allow_anonymous</code> decorator from <code>blacksheep.server.authorization</code>:</p> <pre><code>from blacksheep.server.authorization import allow_anonymous\n\n\n@allow_anonymous()\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n</code></pre>"},{"location":"authorization/#specifying-authentication-schemes-for-request-handlers","title":"Specifying authentication schemes for request handlers","text":"<p>In some scenarios it is necessary to specify multiple authentication schemes for web applications: for example, the same application might handle authentication obtained through the <code>GitHub</code> OAuth app and <code>Microsoft Entra ID</code>. In such scenarios, it might be necessary to restrict access to some endpoints by authentication method, too.</p> <p>To do so:</p> <ol> <li>Specify different authentication handlers, configuring schemes overriding    the <code>scheme</code> property as in the example below.</li> <li>Use the <code>authentication_schemes</code> parameter in the <code>@auth</code> decorator.</li> </ol> <pre><code>class GitHubAuthHandler(AuthenticationHandler):\n\n    @property\n    def scheme(self) -&gt; str:\n      return \"github\"\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        ...\n\n\n@auth(\"authenticated\", authentication_schemes=[\"github\"])\n@get(\"/admin\")\nasync def only_for_user_authenticated_with_github():\n    # This method only tries to authenticate users using the \"github\"\n    # authentication scheme, defined overriding the scheme @property\n    return ok(\"example\")\n</code></pre>"},{"location":"authorization/#failure-response-codes","title":"Failure response codes","text":"<p>When a request fails because of authorization reasons, the web framework returns:</p> <ul> <li>Status <code>401   Unauthorized</code>   if authentication failed and no valid credentials were provided.</li> <li>Status <code>403 Forbidden</code> if   authentication succeeded as valid credentials were provided, but the user is   not authorized to perform an action.</li> </ul> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"background-tasks/","title":"Background tasks","text":"<p>This page describes how to start background tasks in request handlers, and how to configure background tasks that run periodically during the application's lifetime.</p>"},{"location":"background-tasks/#how-to-handle-a-request-in-the-background","title":"How to handle a request in the background","text":"<p>The following example shows how to handle a web request in the background, which is the use case for the HTTP 202 Accepted response status code.</p> <pre><code>import asyncio\nfrom blacksheep import Application, Response, accepted, get\n\napp = Application(show_error_details=True)\n\n\nasync def background_work():\n    # simulate a delay...\n    await asyncio.sleep(1)\n    print(\"Done!\")\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    # start a task in background\n    asyncio.create_task(background_work())\n\n    # note: the server returns a response immediately, so before the conclusion\n    # of the background task\n    return accepted(\"Operation accepted\")\n</code></pre>"},{"location":"background-tasks/#how-to-configure-background-tasks","title":"How to configure background tasks","text":"<p>The following example shows how to configure a background task, including the activation of a service resolved by the DI container, running periodically once every second:</p> <pre><code>import asyncio\nfrom datetime import datetime\n\nfrom blacksheep import Application, get\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    return f\"Hello, World! {datetime.now().isoformat()}\"\n\n\ndef get_current_timestamp():\n    return datetime.now().isoformat()\n\n\nclass Foo:\n    def __init__(self) -&gt; None:\n        pass\n\n\nasync def task_example(app: Application) -&gt; None:\n    # example background task, running once every second,\n    # this example also shows how to activate a service using the DI container\n    while True:\n        print(get_current_timestamp())\n\n        my_foo = app.service_provider.get(Foo)\n        assert isinstance(my_foo, Foo)\n        print(\"Foo id: \", id(my_foo))\n\n        await asyncio.sleep(1)\n\n\nasync def configure_background_tasks(app):\n    asyncio.get_event_loop().create_task(task_example(app))\n\n\napp.on_start += configure_background_tasks\n\napp.services.add_scoped(Foo)\n</code></pre> <p>Last modified on: 2025-04-29 07:50:00</p>RPEWRV"},{"location":"behind-proxies/","title":"Behind proxies","text":"<p>Production web applications are commonly deployed behind HTTP proxies. While many modern web services use cloud platforms that abstract away the need to manage HTTP proxies, there are still scenarios where managing load balancing and proxy rules is necessary. This is especially true when deploying applications using platforms like Kubernetes.</p> <p>Deploying web applications behind proxies often requires configuring routing based on the properties of incoming web requests. The most common examples include routing based on the HTTP host header, the prefix of the URL path, or a combination of both.</p> <p>This page provides an overview of the features provided by BlackSheep to handle these scenarios.</p>"},{"location":"behind-proxies/#routing-based-on-hostnames","title":"Routing based on hostnames","text":"<pre><code>graph LR\n    client1[\"Client 1\"] --&gt;|HTTP&amp;nbsp;GET&amp;nbsp;https:&amp;sol;&amp;sol;orders&amp;period;neoteroi&amp;period;xyz&amp;sol;order&amp;sol;123| proxy[\"Routing rules\"]\n    client2[\"Client 2\"] --&gt;|HTTP&amp;nbsp;POST&amp;nbsp;https:&amp;sol;&amp;sol;orders&amp;period;neoteroi&amp;period;xyz&amp;sol;order| proxy[\"Routing rules\"]\n    client3[\"Client 3\"] --&gt;|HTTP&amp;nbsp;GET&amp;nbsp;https:&amp;sol;&amp;sol;users&amp;period;neoteroi&amp;period;xyz&amp;sol;user&amp;sol;123| proxy[\"Routing rules\"]\n\n    subgraph \"HTTP Proxy\"\n        direction TB\n        proxy\n    end\n\n    subgraph \"Servers\"\n        A[\"Orders Web API&lt;br&gt;orders.neoteroi.xyz\"]\n        B[\"Users Web API&lt;br&gt;users.neoteroi.xyz\"]\n        C[\"Consents Web API&lt;br&gt;consents.neoteroi.xyz\"]\n    end\n\n    proxy --&gt;|&amp;nbsp;orders.neoteroi.xyz&amp;nbsp;| A\n    proxy --&gt;|&amp;nbsp;users.neoteroi.xyz&amp;nbsp;| B\n    proxy --&gt;|&amp;nbsp;consents.neoteroi.xyz&amp;nbsp;| C\n\n    %% Note\n    classDef note stroke:#000,stroke-width:1px;\n    note[\"Example: *.neoteroi.xyz is the wildcard domain used by an HTTP&amp;nbsp;Proxy.\n    Several domains are configured to point to the same proxy.&lt;br&gt;\n    Requests are routed to different backend services based on subdomains.\"]:::note\n    proxy -.-&gt; note</code></pre> <p>Routing based solely on the host header generally does not introduce complications for backend web applications. However, it does require additional maintenance to manage multiple domain names and TLS settings, and routing rules.</p>"},{"location":"behind-proxies/#routing-based-on-paths","title":"Routing based on paths","text":"<p>Path-based routing allows a proxy server to forward requests to different backend services based on a prefix of the URL path. This is particularly useful when hosting multiple applications or services under the same domain.</p> <pre><code>graph LR\n    client1[\"Client 1\"] --&gt;|HTTP&amp;nbsp;GET&amp;nbsp;https:&amp;sol;&amp;sol;api&amp;period;neoteroi&amp;period;xyz&amp;sol;order&amp;sol;123| proxy[\"Routing rules\"]\n    client2[\"Client 2\"] --&gt;|HTTP&amp;nbsp;POST&amp;nbsp;https:&amp;sol;&amp;sol;api&amp;period;neoteroi&amp;period;xyz&amp;sol;order| proxy[\"Routing rules\"]\n    client3[\"Client 3\"] --&gt;|HTTP&amp;nbsp;GET&amp;nbsp;https:&amp;sol;&amp;sol;api&amp;period;neoteroi&amp;period;xyz&amp;sol;user&amp;sol;123| proxy[\"Routing rules\"]\n\n    subgraph \"HTTP Proxy\"\n        direction TB\n        proxy\n    end\n\n    subgraph \"Servers\"\n        A[\"Orders Web API\"]\n        B[\"Users Web API\"]\n        C[\"Consents Web API\"]\n    end\n\n    proxy --&gt;|&amp;nbsp;/orders/*&amp;nbsp;| A\n    proxy --&gt;|&amp;nbsp;/users/*&amp;nbsp;| B\n    proxy --&gt;|&amp;nbsp;/consents/*&amp;nbsp;| C\n\n    %% Note\n    classDef note stroke:#000,stroke-width:1px;\n    note[\"Example: api.neoteroi.xyz is the domain of an HTTP&amp;nbsp;Proxy.&lt;br&gt;\n    Depending on the first portion of the URL path,&lt;br/&gt;the HTTP Proxy forwards the request to the appropriate server.\"]:::note\n    proxy -.-&gt; note</code></pre> <p>When deploying behind proxies in this manner, it is crucial to ensure that the application properly handles being exposed at a specific path. While this works well for most REST APIs, it can lead to complications with redirects and for applications that include user interfaces.</p> <p>The following diagram illustrates the problem of redirects, if the path prefix is not handled properly.</p> <pre><code>sequenceDiagram\n    autonumber\n    actor User\n    participant Proxy as HTTP Proxy&lt;br&gt;(Exposes /example/)\n    participant Backend as Backend Server&lt;br&gt;(Exposed at /)\n\n    User-&gt;&gt;Proxy: HTTP GET https://example.com/example/dashboard\n    Proxy-&gt;&gt;Backend: HTTP GET /dashboard\n    Backend--&gt;&gt;Proxy: HTTP 302 Redirect to /sign-in\n    Proxy--&gt;&gt;User: HTTP 302 Redirect to /sign-in\n\n    note over User: The user is redirected to&lt;br&gt;https://example.com/sign-in,&lt;br&gt;which is incorrect because&lt;br&gt;the prefix /example/ is missing.\n\n    User-&gt;&gt;Proxy: HTTP GET https://example.com/sign-in\n    Proxy--&gt;&gt;User: HTTP 404 Not Found</code></pre> The example of API Gateways <p>API Gateways like AWS API Gateway and Azure API Management use path based routing to expose many APIs behind the same domain name. Path based routing generally does not cause complications for REST APIs, but likely causes complications for web apps serving HTML documents and implementing interactive sign-in.</p> <p>BlackSheep offers two ways to deal with this scenario:</p> <ul> <li>One approach, defined by the <code>ASGI</code> specification, involves specifying a   <code>root_path</code> in the <code>ASGI</code> server. This information is passed in the scope of   web requests. This method is ideal for those who prefer not to modify the   path at which web servers handle requests, and to configure the proxy server   to strip the extra prefix when forwarding requests to backend services   (applying URL rewrite).</li> <li>The second approach involves configuring a prefix in the application router   to globally change the prefix of all request handlers. The global prefix can   be set when instantiating the <code>Router</code> or using the environment variable   <code>APP_ROUTE_PREFIX</code>. This method assumes that modifying the path handled by   the web server is desirable to align it with the path handled by the HTTP   proxy server, and it is ideal when applying URL rewrite is not easy.</li> </ul> <p>For both options, BlackSheep handles the information provided by <code>root_path</code> and the application router prefix in some specific ways. For example, the <code>get_absolute_url_to_path</code> defined in <code>blacksheep.messages</code> will handle the information and return an absolute URL to the server according to both scenarios.</p> Feature Description <code>request.base_path</code> Returns the <code>base_path</code> of a web request, when the ASGI scope includes a <code>root_path</code>, or a route prefix is used. <code>blacksheep.messages.get_absolute_url_to_path</code> Returns an absolute URL path to a given destination, including the current <code>root_path</code> or route prefix. Useful when working with redirects. OpenAPI Documentation Since version <code>2.1.0</code>, it uses relative links to serve the OpenAPI Specification files (YAML and JSON), and relative paths to support any path prefix. Jinja2 template helper <p>The BlackSheep MVC template includes an example of helper function to render absolute paths in Jinja templates.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RP"},{"location":"binders/","title":"Binders","text":"<p>BlackSheep implements automatic binding of parameters for request handlers, a feature inspired by \"Model Binding\" in the ASP.NET web framework. This feature improves code quality and the developer experience since it provides a strategy to read values from request objects in a consistent way and removes the need to write parts that read values from the request object inside request handlers. It also enables a more accurate generation of OpenAPI Documentation, since the framework is aware of what kind of parameters are used by the request handlers (e.g. headers, cookies, query).</p> <p>This page describes:</p> <ul> <li> Implicit and explicit bindings.</li> <li> Built-in binders.</li> <li> How to define a custom binder.</li> </ul> <p>It is recommended to read the following pages before this one:</p> <ul> <li>Getting started: Basics</li> <li>Getting started: MVC</li> <li>Requests</li> </ul>"},{"location":"binders/#introduction","title":"Introduction","text":"<p>Automatic binding of request query strings and route parameters has been described in several places in the previous pages, and explicit and implicit binding is introduced in the section about requests.</p> <p>Binding is implicit when the source of a parameter is inferred by conventions, or explicit when the programmer specifies exact binders from <code>blacksheep.server.bindings</code>.</p>"},{"location":"binders/#implicit-binding","title":"Implicit binding","text":"<p>An example of implicit binding is when a request handler parameter is read from the request URL's route parameters because its name matches the name of a route parameter:</p> <pre><code>@get(\"/api/cats/{cat_id}\")\nasync def get_cat(cat_id: str):\n    ...\n</code></pre> <p>Another example of implicit binding is when a request handler parameter is annotated with a type that is configured in <code>application.services</code>:</p> <pre><code>class Foo:\n    ...\n\n\napp.services.add_instance(Foo())\n\n\n@get(\"/something\")\nasync def do_something(foo: Foo):\n    ...\n</code></pre> <p>In this case, <code>Foo</code> is obtained from application services since the type is registered in <code>app.services</code>.</p> <p>Binding happens implicitly when parameters in the request handler's signature are not annotated with types, or are not annotated with types that inherit from <code>BoundValue</code> class, defined in <code>blacksheep.server.bindings</code>.</p> <p>Warning</p> <p>A parameter with the name \"request\" is always bound to the instance of the <code>Request</code> of the web request.</p>"},{"location":"binders/#explicit-binding","title":"Explicit binding","text":"<p>Binders can be defined explicitly, using type annotations and classes from <code>blacksheep.server.bindings</code> (or just <code>blacksheep</code>).</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import FromJSON, FromServices, post\n\nfrom your_business_logic.handlers.cats import CreateCatHandler  # example\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n\n\n@post(\"/api/cats\")\nasync def create_cat(\n    create_cat_handler: FromServices[CreateCatHandler],\n    input: FromJSON[CreateCatInput],\n):\n    ...\n</code></pre> <p>In the example above, <code>create_cat_handler</code> is obtained from <code>application.services</code>, an exception is thrown if the the service cannot be resolved. This happens if the service is not registered in application services, or any of the services on which it depends is not registered (see Service resolution for more information on services that depend on other services).</p> <p><code>input</code> is obtained by reading the request payload, parsing it as JSON, and creating an instance of CreateCatInput from it. If an exception occurs while trying to parse the request payload or when instantiating the <code>CreateCatInput</code>, the framework produces automatically a <code>400 Bad Request</code> response for the client.</p> <p>When mapping the request's payload to an instance of the desired type, the type is instantiated using <code>cls(**data)</code>. If it necessary to parse dates or other complex types that are not handled by JSON deserialization, this must be done in the constructor of the class. To handle gracefully a JSON payload having extra unused properties, use <code>*args</code> in your class constructor: <code>__init__(one, two, three, *args)</code>.</p>"},{"location":"binders/#optional-parameters","title":"Optional parameters","text":"<p>Optional parameters can be defined in one of these ways:</p> <ol> <li>using <code>typing.Optional</code> annotation</li> <li>specifying a default value</li> </ol> <pre><code>@get(\"/foo\")\nasync def example(\n    page: int = 1,\n    search: str = \"\",\n):\n    # page is read from the query string, if specified, otherwise defaults to 1\n    # search is read from the query string, if specified, otherwise defaults to \"\"\n    ...\n</code></pre> <pre><code>from typing import Optional\n\n\n@get(\"/foo\")\nasync def example(\n    page: Optional[int],\n    search: Optional[str],\n):\n    # page is read from the query string, if specified, otherwise defaults to None\n    # search is read from the query string, if specified, otherwise defaults to None\n    ...\n</code></pre> <pre><code>from blacksheep import FromQuery, get\n\n\n@get(\"/foo\")\nasync def example(\n    page: FromQuery[int] = FromQuery(1),\n    search: FromQuery[str] = FromQuery(\"\"),\n):\n    # page.value defaults to 1\n    # search.value defaults to \"\"\n    ...\n</code></pre> <pre><code>from typing import Optional\n\nfrom blacksheep import FromQuery, get\n\n\n@get(\"/foo\")\nasync def example(\n    page: FromQuery[Optional[int]],\n    search: FromQuery[Optional[str]],\n):\n    # page.value defaults to None\n    # search.value defaults to None\n    ...\n</code></pre> <pre><code>from typing import Optional\n\nfrom blacksheep import FromQuery, get\n\n\n@get(\"/foo\")\nasync def example(\n    page: Optional[FromQuery[int]],\n    search: Optional[FromQuery[str]],\n):\n    # page defaults to None\n    # search defaults to None\n    ...\n</code></pre>"},{"location":"binders/#built-in-binders","title":"Built-in binders","text":"Binder Description FromHeader A parameter obtained from a header. FromQuery A parameter obtained from URL query. FromCookie A parameter obtained from a cookie. FromServices Service from <code>application.services</code>. FromJSON Request body read as JSON and optionally parsed. FromForm A parameter obtained from Form request body: either application/x-www-form-urlencoded or multipart/form-data. FromText Request payload read as text, using UTF-8 encoding. FromBytes Request payload read as raw bytes. FromFiles Request payload of file type. ClientInfo Client IP and port information obtained from the request ASGI scope, as Tuple[str, int]. ServerInfo Server IP and port information obtained from the request scope. RequestUser Request's identity. RequestURL Request's URL. RequestMethod Request's HTTP method. <p><code>FromHeader</code> and <code>FromCookie</code> binders must be subclassed because they require a <code>name</code> class property:</p> <pre><code>from blacksheep import FromCookie, FromHeader, get\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\nclass FromFooCookie(FromCookie[Optional[str]]):\n    name = \"foo\"\n\n\n@get(\"/\")\ndef home(accept: FromAcceptHeader, foo: FromFooCookie) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Foo: {foo.value}\n        \"\"\"\n    )\n</code></pre>"},{"location":"binders/#defining-a-custom-binder","title":"Defining a custom binder","text":"<p>To define a custom binder, define a <code>BoundValue[T]</code> class and a <code>Binder</code> class having <code>handle</code> class property referencing the custom <code>BoundValue</code> class. The following example demonstrates how to define a custom binder:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request\nfrom blacksheep.server.bindings import Binder, BoundValue\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nclass FromCustomValue(BoundValue[str]):\n    pass\n\n\nclass CustomBinder(Binder):\n\n    handle = FromCustomValue\n\n    async def get_value(self, request: Request) -&gt; Optional[str]:\n        # TODO: implement here the desired logic to read a value from\n        # the request object\n        return \"example\"\n\n\n@get(\"/\")\ndef home(something: FromCustomValue):\n    assert something.value == \"example\"\n    return f\"OK {something.value}\"\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"cache-control/","title":"Cache control","text":"<p>This page describes features to configure <code>Cache-Control</code> response headers. It covers:</p> <ul> <li> Using the <code>cache_control</code> decorator to configure a header for specific   request handlers.</li> <li> Using the <code>CacheControlMiddleware</code> to configure a common header for all   request handlers globally.</li> </ul>"},{"location":"cache-control/#about-cache-control","title":"About Cache-Control","text":"<p>The <code>Cache-Control</code> response header can be used to describe how responses can be cached by clients. For information on this subject, it is recommended to refer to the <code>mozilla.org</code> documentation.</p>"},{"location":"cache-control/#using-the-cache_control-decorator","title":"Using the cache_control decorator","text":"<p>The following example illustrates how the <code>cache_control</code> decorator can be used to control caching for specific request handlers:</p> <pre><code>from blacksheep import Application, get\nfrom blacksheep.server.headers.cache import cache_control\n\n\napp = Application()\n\n\n@get(\"/\")\n@cache_control(no_cache=True, no_store=True)\nasync def home():\n    return \"This response should not be cached or stored!\"\n\n\n@get(\"/api/cats\")\n@cache_control(max_age=120)\nasync def get_cats():\n    ...\n</code></pre> <p>Decorators order.</p> <p>The order of decorators matters: the router decorator must be the outermost decorator in this case.</p> <p>For controllers:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.controllers import Controller, get\nfrom blacksheep.server.headers.cache import cache_control\n\n\napp = Application()\n\n\nclass Home(Controller):\n    @get(\"/\")\n    @cache_control(no_cache=True, no_store=True)\n    async def index(self):\n        return \"Example\"\n</code></pre>"},{"location":"cache-control/#using-the-cachecontrolmiddleware","title":"Using the CacheControlMiddleware","text":"<p>While the <code>cache_control</code> decorator described above can be used to configure specific request handlers, in some circumstances it might be desirable to configure a default <code>Cache-Control</code> strategy for all paths at once.</p> <p>To configure a default <code>Cache-Control</code> for all <code>GET</code> request handlers resulting in successful responses with status <code>200</code>.</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.controllers import Controller, get\nfrom blacksheep.server.headers.cache import cache_control, CacheControlMiddleware\n\n\napp = Application()\n\n\napp.middlewares.append(CacheControlMiddleware(no_cache=True, no_store=True))\n</code></pre> <p>It is then possible to override the default rule in specific request handlers:</p> <pre><code>app.middlewares.append(CacheControlMiddleware(no_cache=True, no_store=True))\n\n\nclass Home(Controller):\n    @get(\"/\")\n    @cache_control(max_age=120)\n    async def index(self):\n        return \"Example\"\n</code></pre> <p>The provided <code>CacheControlMiddleware</code> can be subclassed to control when requests should be affected:</p> <pre><code>from blacksheep import Request, Response\nfrom blacksheep.server.headers.cache import CacheControlMiddleware\n\n\nclass MyCacheControlMiddleware(CacheControlMiddleware):\n    def should_handle(self, request: Request, response: Response) -&gt; bool:\n        # TODO: implement here the desired logic\n        ...\n</code></pre> <p>For instance, a middleware that disables cache-control by default can be defined in the following way:</p> <pre><code>class NoCacheControlMiddleware(CacheControlMiddleware):\n    \"\"\"\n    Disable client caching globally, by default, setting a\n    Cache-Control: no-cache, no-store for all responses.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(no_cache=True, no_store=True)\n\n    def should_handle(self, request: Request, response: Response) -&gt; bool:\n        return True\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RP"},{"location":"cli/","title":"More about the BlackSheep-CLI","text":"<p>The second version of the web framework offers a command-line interface (CLI) to bootstrap new projects using templates, inspired by similar CLIs of popular front-end web frameworks.</p> <p>This page describes the CLI in detail, covering the following subjects:</p> <ul> <li> How to install the <code>blacksheep-cli</code>.</li> <li> How to use its help.</li> <li> How to create a new project.</li> <li> How to configure new templates.</li> </ul>"},{"location":"cli/#installing-the-cli","title":"Installing the CLI","text":"<p>The CLI is distributed as a separate package, and can be installed from the Python Package Index:</p> <pre><code>pip install blacksheep-cli\n</code></pre> <p>Once installed, the CLI can be used to bootstrap new projects using interactive prompts.</p> <p>Beware of dependencies</p> <p>It is recommended to use the <code>blacksheep-cli</code> only to bootstrap new projects, and to not include it as a dependency for web projects, because it includes several dependencies that are not necessary to run a web server.</p>"},{"location":"cli/#using-the-help","title":"Using the help","text":"<p>The <code>blacksheep-cli</code> is a Click application with auto-generated help. Type <code>blacksheep</code> or <code>blacksheep --help</code> to display the help, with the list of command groups:</p> <p></p> <p>To display the help of a specific command group, use the command group name followed by <code>--help</code>, like in the following example:</p> <p></p>"},{"location":"cli/#listing-available-templates","title":"Listing available templates","text":"<p>The <code>blacksheep-cli</code> is pre-configured with official templates. To list the available templates, use the <code>blacksheep templates list</code>, or the <code>blacksheep templates details</code> commands.</p> <pre><code>$ blacksheep templates list\napi\nmvc\n</code></pre> <p>To display details about the templates, which are stored in a configuration file in the user's folder, use the <code>blacksheep templates details</code> command:</p> <p></p> <p>Available templates</p> <p>At the time of this writing, there are two officially maintained templates. More can be added in the future, and users can configure additional templates using the <code>blacksheep templates add</code> command.</p>"},{"location":"cli/#creating-a-new-project","title":"Creating a new project","text":"<p>Use the <code>blacksheep create</code> command to bootstrap a project using one of the supported templates. The command will prompt for the necessary input to bootstrap a new project. Aside from the project name and template type, each project template defines the parameters that are needed.</p> <p></p> <p>The CLI includes a help, and supports custom templates, using the same sources supported by <code>Cookiecutter</code>.</p>"},{"location":"cli/#templates-commands","title":"Templates commands","text":"Command Description <code>add</code> Adds a new template to the list of available templates. This information is stored in a configuration file in the user's folder (this is an implementation detail and might change in the future). <code>remove</code> Removes a template from the list of available templates. <code>list</code> Lists the names of the available templates. <code>details</code> Displays details about the available templates."},{"location":"cli/#creating-a-new-template","title":"Creating a new template","text":"<p>To create a new project template, define a new <code>cookiecutter</code> template.</p> <ul> <li>cookiecutter docs</li> <li>API template, which can be followed as example</li> </ul> <p>To offer a better prompt, include a <code>questions.json</code> file for Python <code>questionary</code>, whose questions match the parameters described in <code>cookiecutter.json</code>; like in the API template.</p> <p>The BlackSheep CLI supports all sources that are supported by <code>cookiecutter</code>.</p> <p>Then include it in the list of available templates, using the <code>templates add</code> command, like in:</p> <pre><code>blacksheep templates add foo https://github.com/Neoteroi/BlackSheep-Foo -d 'Some nice template! \ud83d\udc03'\n</code></pre> <p>To use a specific <code>git</code> tag, add a <code>${tag}</code> suffix to the source, like:</p> <pre><code>blacksheep templates add foov2 'https://github.com/Neoteroi/BlackSheepFoo$v2'\n</code></pre>"},{"location":"cli/#cookiecutter","title":"Cookiecutter","text":"<p>The <code>blacksheep-cli</code> uses <code>Cookiecutter</code> under the hood, with <code>questionary</code> to offer better prompts.</p> <p>The official templates are <code>cookiecutter</code> templates, that can be used in a non-interactive way if desired, using the <code>cookiecutter</code> CLI. This can be useful to bootstrap new projects in automated jobs (CI/CD).</p> <p>For example, to bootstrap a new project using the API template, with the name \"foo\" and using TOML files for application settings:</p> <pre><code>cookiecutter https://github.com/Neoteroi/BlackSheep-API --no-input project_name=foo app_settings_format=TOML\n</code></pre> <p>Last modified on: 2025-04-01 23:22:49</p>RPEW"},{"location":"client/","title":"HTTP Client","text":"<p>BlackSheep includes an implementation of HTTP Client for HTTP 1.1.</p>"},{"location":"client/#client-features","title":"Client features","text":"<ul> <li>HTTP connection pooling.</li> <li>User-friendly handling of SSL contexts (safe by default).</li> <li>Support for client side middlewares.</li> <li>Automatic handling of redirects (can be disabled, validates circular   redirects and maximum number of redirects - redirects to URN are simply   returned to code using the client).</li> <li>Automatic handling of cookies (can be disabled, <code>Set-Cookie</code> and <code>Cookie</code>   headers).</li> </ul> <p>Example:</p> <pre><code>import asyncio\nfrom blacksheep.client import ClientSession\n\n\nasync def client_example(loop):\n    async with ClientSession() as client:\n        response = await client.get(\"https://docs.python.org/3/\")\n\n        assert response is not None\n        text = await response.text()\n        print(text)\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(client_example(loop))\n</code></pre>"},{"location":"client/#http-connection-pooling","title":"HTTP Connection pooling","text":"<p>The HTTP client in BlackSheep implements connection pooling. Meaning that connections to the same host and port are kept in memory and reused for different request-response cycles, when possible. By default, connections are not disposed of as long as they are kept open.</p> <p>Implementation: /blacksheep/client/pool.py.</p> <p>Connections are created using <code>asyncio</code> function <code>loop.create_connection</code>.</p>"},{"location":"client/#client-middlewares","title":"Client middlewares","text":"<p>The HTTP Client supports middlewares. Middlewares on the server are functions that are executed in order, at every request-response cycle and enable manipulation of incoming requests and outgoing responses. Middlewares support interruption of the chain: that is, returning an HTTP response without firing all handlers in the chain, for example, to return HTTP 401 Unauthorized when applying an authentication strategy. The HTTP client can benefit from the same design pattern, and this is supported in BlackSheep.</p>"},{"location":"client/#client-middleware-example","title":"Client middleware example","text":"<pre><code>async def client_example_middleware(request, next_handler):\n    # do something before the request is sent\n    response = await next_handler(request)\n\n    # do something with the response from the remote server\n    return response\n\nclient = ClientSession()\nclient.middlewares.append(client_example_middleware)\nclient.configure()\n</code></pre>"},{"location":"client/#considerations-about-the-clientsession-class","title":"Considerations about the ClientSession class","text":"<p>The <code>ClientSession</code> owns by default a connections pool, if none is specified for it. The connections pool is automatically disposed of when the client is exited, if it was created for the client.</p> <p>On the importance of connection pooling.</p> <p>Avoid instantiating a new <code>ClientSession</code> at each web request, unless the same <code>ConnectionsPool</code> is reused among the instances. Instantiating a new <code>ClientSession</code> without reusing the same TCP connections pool has negative effects on the performance of the application.</p> <p>It is recommended to instantiate a single instance of HTTP client and register it as a service of the application, using the <code>@app.lifespan</code> method:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.client.session import ClientSession\n\napp = Application()\n\n\n@app.lifespan\nasync def register_http_client():\n    async with ClientSession() as client:\n        print(\"HTTP client created and registered as singleton\")\n        app.services.register(ClientSession, instance=client)\n        yield\n\n    print(\"HTTP client disposed of\")\n\n\n@router.get(\"/\")\nasync def home(http_client: ClientSession):\n    print(http_client)\n    return {\"ok\": True, \"client_instance_id\": id(http_client)}\n</code></pre> <p>When following this approach, the HTTP client can be automatically injected into request handlers and services that need it, and is automatically disposed of when the application is stopped.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"compression/","title":"Compression","text":"<p>This page describes built-in features to handle automatic response compression. It covers:</p> <ul> <li> Using the <code>GzipMiddleware</code> to enable gzip compression.</li> </ul>"},{"location":"compression/#gzipmiddleware","title":"GzipMiddleware","text":"<p>To enable automatic compression of response bodies using <code>gzip</code>, use the <code>GzipMiddleware</code> like in the following example:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.compression import GzipMiddleware\n\n\napp = Application()\n\n\napp.middlewares.append(GzipMiddleware())\n</code></pre> <p>Or, in alternative:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.compression import use_gzip_compression\n\n\napp = Application()\n\n\nuse_gzip_compression(app)\n</code></pre> <p>Not for streamed content.</p> <p>The <code>GzipMiddleware</code> does not compress bytes streamed using the <code>StreamedContent</code> class (used by default when serving files), it only compresses whole bodies like, for example, those that are generated when returning <code>JSON</code> content to the client.</p>"},{"location":"compression/#options","title":"Options","text":"<p>The following table describes options for the <code>GzipMiddleware</code> constructor.</p> Option Type Description min_size <code>int</code> (default 500) The minimum size before applying compression to response bodies. comp_level <code>int</code> (default 5) The compression level, as passed to <code>gzip.compress</code> function. handled_types <code>Optional[Iterable[bytes]]</code> Control which content types can be compressed by the specific instance of <code>GzipMiddleware</code>. executor <code>Optional[Executor]</code> (default <code>None</code>) Control which instance of <code>concurrent.future.Executor</code> is used to compress - if not specified the default executor handled by <code>run_in_executor</code> is used. <p>When <code>handled_types</code> is not specified for an instance of <code>GzipMiddleware</code>, compression is applied by default to content types containing any of the following strings:</p> <ul> <li>json</li> <li>xml</li> <li>yaml</li> <li>html</li> <li>text/plain</li> <li>application/javascript</li> <li>text/css</li> <li>text/csv</li> </ul> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"contributing/","title":"Contributing to BlackSheep","text":"<p>This page describes how to contribute to BlackSheep. Most of the information presented here applies also to other projects from <code>Neoteroi</code> (e.g. rodi, guardpost, essentials-openapi), although among these projects, only BlackSheep is using <code>Cython</code>.</p>"},{"location":"contributing/#system-requirements","title":"System requirements","text":"<p>Building <code>blacksheep</code> locally requires the following:</p> <ul> <li>one of the supported Python versions; it   is recommended to use one of the latest two stable versions (e.g. Python 3.8   or 3.9 as of the 1st of May 2021)</li> <li>a <code>C</code> compiler, required to use   Cython   (refer to Cython's documentation for more information on this subject)</li> </ul>"},{"location":"contributing/#preparing-a-development-environment","title":"Preparing a development environment","text":"<ol> <li>fork the main repository in GitHub</li> <li>clone the forked repository</li> <li>create a Python virtual environment in the desired location (<code>.gitignores</code>    is configured to ignore a <code>venv</code> folder, so if you name your virtual    environment this way, you can comfortably keep the virtual environment in    the same folder of the repository)</li> <li>install the dependencies that are required to develop, listed in    <code>requirements.txt</code> (pip install -r requirements.txt)</li> <li>compile the <code>C</code> extensions: if your system supports <code>Makefile</code>, use    <code>make compile</code>; otherwise run manually the commands described in the    <code>Makefile</code> for <code>cyt</code> and <code>compile</code> commands</li> <li>run the unit tests to verify if things were compiled correctly, using    <code>pytest</code> or <code>make test</code></li> </ol> <p>Watch the following video for instructions:</p> <p> </p>"},{"location":"contributing/#formatters-and-style-enforcement","title":"Formatters and style enforcement","text":"<p>BlackSheep uses the following tools for code formatting:</p> <ul> <li><code>flake8</code></li> <li><code>black</code></li> <li><code>isort</code></li> </ul> <p><code>flake8</code>, <code>black</code>, and <code>isort</code> are used in the CI pipeline as a required step for successful build completion. The repository includes configuration files for <code>flake8</code> and <code>black</code>.</p> <p>The provided <code>Makefile</code> defines a task to run linters:</p> <ul> <li><code>make lint</code> - to run flake8, isort, and black validation</li> </ul>"},{"location":"contributing/#type-hints","title":"Type hints","text":"<p>BlackSheep aims at being type friendly, meaning:</p> <ul> <li>most functions, especially those whose arguments are not obvious, should be   type annotated</li> <li>when developers work with popular text editors and IDEs like <code>PyCharm</code> or   <code>Visual Studio Code</code>, they should benefit from proper help / auto-completion   of parameters required by functions and constructors</li> <li>the parts coded in <code>Cython</code> are documented using stub files (<code>.pyi</code>), see   PEP   484</li> <li>the code should be generally respectful of   <code>MyPy</code> and, when <code>Visual   Studio Code</code> is used,   <code>Pylance</code></li> </ul> <p>This being said, <code>blacksheep</code> doesn't aim at 100% typing coverage or full adherence to <code>MyPy</code>'s (or <code>pyright/Pylance</code>'s) notions of typing perfection. The most important thing is for features to work as intended and well (good enough!), and to be fully test-covered.</p> <p></p>"},{"location":"contributing/#code-coverage","title":"Code coverage","text":"<p>BlackSheep features 100% code coverage, except for some rare cases where <code>#pragma: no cover</code> is used. New contributions should not decrease code coverage, unless there is a good reason to skip lines. Integration with <code>Codecov</code> checks code coverage in pull requests.</p> <p></p> <p>To create code coverage:</p> <pre><code>make test-cov\n</code></pre> <p>Or, for those who cannot use <code>make</code>:</p> <pre><code>pytest --cov-report html --cov=blacksheep\n</code></pre>"},{"location":"contributing/#how-to-name-branches","title":"How to name branches","text":"<p>It doesn't matter, as long as branch names don't contain anything that violates the Code of Conduct included in the project's repository. As a general rule of thumb, branch names should have a descriptive name, or refer to the number of an issue in their name (e.g. <code>fix_102</code>).</p>"},{"location":"contributing/#setuppy","title":"setup.py","text":"<p>It is the intention of <code>blacksheep</code>'s author to always keep <code>setup.py</code> files as stupid and simple as possible. So please don't modify the <code>setup.py</code> file to be \"smarter\" or more dynamic without prior discussion in an issue.</p>"},{"location":"contributing/#how-to-develop-and-debug-with-visual-studio-code","title":"How to develop and debug with Visual Studio Code","text":"<p>The following video shows I am using Visual Studio Code to work on BlackSheep:</p> <p> </p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"controllers/","title":"Controllers","text":"<p>BlackSheep includes built-in features to support the MVC (Model, View, Controller) architecture. A <code>Controller</code> is a class with at least one method registered as a request handler (i.e., associated with a route). A Controller is instantiated for each web request when the request matches a route defined in that controller.</p> <p>This page describes:</p> <ul> <li> Controller methods.</li> <li> API Controllers.</li> </ul> <p>It is recommended to follow the MVC tutorial before reading this page.</p> <p>For Flask users</p> <p>If you come from Flask, controllers in BlackSheep can be considered equivalent to Flask's Blueprints, as they allow to group request handlers in dedicated modules and classes.</p>"},{"location":"controllers/#the-controller-class","title":"The Controller class","text":"<p>Controllers implement several methods to simplify returning responses. These are the same described in Responses, but they can be overridden in subclasses of <code>Controller</code> and they remove the need to import functions.</p> Method Description ok Returns an HTTP 200 OK response, with an optional message; sent as plain text or JSON. status_code Returns a plain response with the given status, and with an optional message; sent as plain text or JSON. created Returns an HTTP 201 Created response, to the given location and with optional JSON content. accepted Returns an HTTP 202 Accepted response, with an optional message; sent as plain text or JSON. no_content Returns an HTTP 204 No Content response. json Returns a response with application/json content, and the given status (default HTTP 200 OK). pretty_json Returns a response with indented application/json content, and the given status (default HTTP 200 OK). text Returns a response with text/plain content, and the given status (default HTTP 200 OK). html Returns a response with text/html content, and the given status (default HTTP 200 OK). moved_permanently Returns an HTTP 301 Moved Permanently response, to the given location. redirect Returns an HTTP 302 Found response (commonly called redirect), to the given location. see_other Returns an HTTP 303 See Other response, to the given location. not_modified Returns an HTTP 304 Not Modified response. temporary_redirect Returns an HTTP 307 Temporary Redirect response, to the given location. permanent_redirect Returns an HTTP 308 Permanent Redirect response, to the given location. bad_request Returns an HTTP 400 Bad Request response, with an optional message; sent as plain text or JSON. unauthorized Returns an HTTP 401 Unauthorized response, with an optional message; sent as plain text or JSON. forbidden Returns an HTTP 403 Forbidden response, with an optional message; sent as plain text or JSON. not_found Returns an HTTP 404 Not Found response, with an optional message; sent as plain text or JSON. view Returns a view rendered synchronously. view_async Returns a view rendered asynchronously. file Returns a binary file response with the given content type and optional file name, for download (attachment) (default HTTP 200 OK). This method supports being called with bytes, or a generator yielding chunks. <p>For information on how to use these methods, refer to the type annotations provided in the code.</p> <p></p> <p>Info</p> <p>Using an IDE like JetBrains PyCharm, or Visual Studio Code (as in the screenshot above), enables automatic completion and hints thanks to type annotations.</p>"},{"location":"controllers/#on_request-and-on_response","title":"on_request and on_response","text":"<p>Using controllers it is possible to define methods that are always executed before handling a request and after producing a response:</p> <pre><code>class Example(Controller):\n\n    async def on_request(self, request: Request):\n        print(\"Received a request!\")\n\n    async def on_response(self, response: Response):\n        print(\"Produced response!\")\n</code></pre> <p>Using controllers involves a performance fee compared to using functions because a controller must be instantiated at each web request, but has the following benefits:</p> <ul> <li>Controllers support dependency injection to   receive services for their constructors, in addition to dependency   injection for every single request handler</li> <li>Controllers support defining an <code>on_request(request: Request)</code> method, that   gets called at every web request, <code>on_response(response: Response)</code> method,   and a base <code>route</code> (defined as class method) for all handlers defined in the   class.</li> <li>Controllers provide methods to produce responses, that can be overridden in   base classes to personalize the behavior of the application without   monkey-patching functions</li> </ul> <p>Therefore they can help avoid code repetition.</p> <p>The following example shows how dependency injection can be used in controller constructors, and an implementation of the <code>on_request</code> method:</p> <pre><code>app = Application()\n\n\nclass Settings:\n\n    def __init__(self, greetings: str):\n        self.greetings = greetings\n\n\nclass Home(Controller):\n\n    def __init__(self, settings: Settings):\n        # controllers are instantiated dynamically at every web request\n        self.settings = settings\n\n    async def on_request(self, request: Request):\n        print(\"[*] Received a request!!\")\n\n    def greet(self):\n        return self.settings.greetings\n\n    @get(\"/\")\n    async def index(self, request: Request):\n        return text(self.greet())\n\n# when configuring the application, register\n# a singleton of the application settings,\n# this service is automatically injected into request handlers\n# having a signature parameter type annotated `: Settings`, or\n# having name \"settings\", without type annotations\napp.services.add_instance(Settings(value))\n</code></pre> <p>The dependency can also be described as class property:</p> <pre><code>class Home(Controller):\n    settings: Settings\n\n    ...\n</code></pre> <p>If route methods (e.g. <code>head</code>, <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>) from <code>blacksheep.server.controllers</code> are used, then the default singleton <code>Router</code> instance for controllers is used. It is also possible to use a specific router, as long as this router is bound to the application object:</p> <pre><code>from blacksheep.server.routing import RoutesRegistry\n\n\napp = Application()\napp.controllers_router = RoutesRegistry()\nget = app.controllers_router.get\n</code></pre>"},{"location":"controllers/#the-apicontroller-class","title":"The APIController class","text":"<p>The <code>APIController</code> class is a kind of <code>Controller</code> dedicated to API definitions. An APIController offers some properties to simplify versioning of routes and adding a common path prefix to all routes, for example, prepending \"/v1/\" fragment to all routes and the name of the controller class.</p> <pre><code>from blacksheep import Response, FromJSON, FromQuery\nfrom blacksheep.server.controllers import APIController, delete, get, patch, post\n\n\nclass Cats(APIController):\n    @get()\n    def get_cats(\n        self,\n        page: FromQuery[int] = FromQuery(1),\n        page_size: FromQuery[int] = FromQuery(30),\n        search: FromQuery[str] = FromQuery(\"\"),\n    ) -&gt; Response:\n        \"\"\"Returns a list of paginated cats.\"\"\"\n\n    @get(\"{cat_id}\")\n    def get_cat(self, cat_id: UUID) -&gt; Response:\n        \"\"\"Gets a cat by id.\"\"\"\n\n    @patch(\"{cat_id}\")\n    def update_cat(self, cat_id: str, input: UpdateCatInput) -&gt; Response:\n        \"\"\"Updates a cat with given id.\"\"\"\n\n    @post()\n    def create_cat(self, input: FromJSON[CreateCatInput]) -&gt; Response:\n        \"\"\"Creates a new cat.\"\"\"\n\n    @delete(\"{cat_id}\")\n    def delete_cat(self, cat_id: str) -&gt; Response:\n        \"\"\"Deletes a cat by id.\"\"\"\n</code></pre> <p>In the example above, the routes defined on the <code>Cats</code> class will result in the following paths:</p> HTTP Method Path Request handler Description GET /api/cats <code>get_cats</code> Returns a list of paginated cats. GET /api/cats/{cat_id} <code>get_cat</code> Gets a cat by id. POST /api/cats/{cat_id} <code>create_cat</code> Creates a new cat. PATCH /api/cats/{cat_id} <code>update_cat</code> Updates a cat with given id. DELETE /api/cats/{cat_id} <code>delete_cat</code> Deletes a cat by id. <p>To include a version number in the API, implement a <code>version</code> <code>@classmethod</code> like in the following example:</p> <pre><code>class Cats(APIController):\n\n    @classmethod\n    def version(cls) -&gt; str:\n        return \"v1\"\n\n    ...\n</code></pre> <p>In such case, the generated paths would be as follows:</p> HTTP Method Path Request handler Description HTTP GET /api/v1/cats <code>get_cats</code> Returns a list of paginated cats. HTTP GET /api/v1/cats/{cat_id} <code>get_cat</code> Gets a cat by id. HTTP POST /api/v1/cats/{cat_id} <code>create_cat</code> Creates a new cat. HTTP PATCH /api/v1/cats/{cat_id} <code>update_cat</code> Updates a cat with given id. HTTP DELETE /api/v1/cats/{cat_id} <code>delete_cat</code> Deletes a cat by id. <p>To specify a name for the API, different than the default one, implement a <code>route</code> <code>@classmethod</code> like in the following example:</p> <pre><code>class Cats(APIController):\n\n    @classmethod\n    def route(cls) -&gt; str:\n        return \"catz\"\n\n    ...\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"cors/","title":"Cross-Origin Resource Sharing","text":"<p>BlackSheep provides a strategy to handle Cross-Origin Resource Sharing (CORS). This page covers:</p> <ul> <li> Enabling CORS globally.</li> <li> Enabling CORS for specific endpoints.</li> </ul>"},{"location":"cors/#enabling-cors-globally","title":"Enabling CORS globally","text":"<p>The example below demonstrates how to enable CORS globally:</p> <pre><code>app.use_cors(\n    allow_methods=\"GET POST DELETE\",\n    allow_origins=\"https://www.example.dev\",\n    allow_headers=\"Authorization\",\n    max_age=300,\n)\n</code></pre> <p>When enabled this way, the framework handles <code>CORS</code> requests and preflight <code>OPTIONS</code> requests.</p> <p>It is possible to use <code>*</code> to enable any origin or any method:</p> <pre><code>app.use_cors(\n    allow_methods=\"*\",\n    allow_origins=\"*\",\n    allow_headers=\"* Authorization\",\n    max_age=300,\n)\n</code></pre> Options Description allow_methods Controls the value of Access-Control-Allow-Methods. \ud83d\udde1\ufe0f allow_origins Controls the value of Access-Control-Allow-Origin. \ud83d\udde1\ufe0f allow_headers Controls the value of Access-Control-Allow-Headers. \ud83d\udde1\ufe0f allow_credentials Controls the value of Access-Control-Allow-Credentials. expose_headers Controls the value of Access-Control-Expose-Headers. \ud83d\udde1\ufe0f max_age Controls the value of Access-Control-Max-Age, defaults to 5 seconds. <p>\ud83d\udde1\ufe0f The value can be a string of values separated by space, comma, or semi-colon,    or a list.</p>"},{"location":"cors/#enabling-cors-for-specific-endpoints","title":"Enabling CORS for specific endpoints","text":"<p>The example below demonstrates how to enable CORS only for specific endpoints:</p> <pre><code>app.use_cors()\ncors = app.cors\n\napp.add_cors_policy(\n    \"example\",\n    allow_methods=\"GET POST\",\n    allow_origins=\"*\",\n)\n\n@route(\"/\", methods=[\"GET\", \"POST\"])\nasync def home():\n    ...\n\n@cors(\"example\")\n@route(\"/specific-rules\", methods=[\"GET\", \"POST\"])\nasync def enabled():\n    ...\n</code></pre> <p>Explanation:</p> <ol> <li>The function call <code>app.use_cors()</code> activates the built-in handling of CORS    requests and registers a global CORS rule that denies all requests by    default.</li> <li>The call to <code>app.add_cors_policy(...)</code> registers a new set of CORS rules    associated with the key 'example'.</li> <li>The CORS rules associated with the key 'example' are applied to specific    request handlers using the <code>@cors</code> decorator.</li> </ol> <p>It is possible to register many sets of rules for CORS, each with its own key, and apply different rules to request handlers. It is also possible to define a global rule when calling <code>app.use_cors(...)</code> that enables certain operations for all request handlers, while still defining specific rules.</p> <pre><code># the following settings are applied by default to all request handlers:\napp.use_cors(\n    allow_methods=\"GET POST\",\n    allow_origins=\"https://www.foo.org\",\n    allow_headers=\"Authorization\",\n)\n\napp.add_cors_policy(\n    \"one\",\n    allow_methods=\"GET POST PUT DELETE\",\n    allow_origins=\"*\",\n    allow_headers=\"Authorization\",\n)\n\napp.add_cors_policy(\"deny\")\n\n\n@route(\"/\", methods=[\"GET\", \"POST\"])\nasync def home():\n    ...\n\n@app.cors(\"one\")\n@route(\"/specific-rules\", methods=[\"GET\", \"POST\"])\nasync def enabled():\n    ...\n\n@app.cors(\"deny\")\n@get(\"/disabled-for-cors\")\nasync def disabled():\n    ...\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"dataprotection/","title":"Data protection","text":"<p>Web applications often need to protect data, so that it can be stored in cookies or other types of client storage. BlackSheep uses <code>itsdangerous</code> to sign and encrypt information. For example, it is used to store <code>claims</code> obtained from <code>id_token</code>s in integrations with identity providers using OpenID Connect, or when handling session cookies.</p> <p>This page covers:</p> <ul> <li> Handling secrets.</li> <li> Using data protection features.</li> </ul>"},{"location":"dataprotection/#how-to-handle-secrets","title":"How to handle secrets","text":"<p>Symmetric encryption is used to sign and encrypt information in several scenarios. This means that BlackSheep applications need secrets to protect sensitive data in some circumstances. When keys are not specified, they are generated automatically in memory when the application starts, for the best user experience.</p> <p>Danger</p> <p>This means that keys are not persisted when applications restart, and are not consistent when multiple instances of the same application are deployed across regions, or within the same server. This is acceptable during local development, but should not be the case in production environments.</p> <p>To use consistent keys, configure one or more environment variables like the following:</p> <ul> <li>APP_SECRET_1=\"***\"</li> <li>APP_SECRET_2=\"***\"</li> <li>APP_SECRET_3=\"***\"</li> </ul> <p>Keys can be configured in a host environment, or fetched from a dedicated service such as <code>AWS Secrets Manager</code> or <code>Azure Key Vault</code> at application start-up, and configured as environment settings for the application.</p>"},{"location":"dataprotection/#example","title":"Example","text":"<pre><code>from blacksheep.server.dataprotection import get_serializer\n\n\nserializer = get_serializer(purpose=\"example\")\n\ntoken = serializer.dumps({\"id\": 1, \"message\": \"This will be kept secret\"})\n\nprint(token)\n\ndata = serializer.loads(token)\n\nprint(data)\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"dependency-injection/","title":"Dependency injection in BlackSheep","text":"<p>The getting started tutorials demonstrate how route and query string parameters can be directly injected into request handlers through function signatures. Additionally, BlackSheep supports the dependency injection of services configured for the application. This page covers:</p> <ul> <li> An introduction to dependency injection in BlackSheep, with a focus on Rodi.</li> <li> Service resolution.</li> <li> Service lifetime.</li> <li> Options to create services.</li> <li> Examples of dependency injection.</li> <li> How to use alternatives to Rodi.</li> </ul> <p>Rodi's documentation</p> <p>Detailed documentation for Rodi can be found at: Rodi.</p>"},{"location":"dependency-injection/#introduction","title":"Introduction","text":"<p>The <code>Application</code> object exposes a <code>services</code> property that can be used to configure services. When the function signature of a request handler references a type that is registered as a service, an instance of that type is automatically injected when the request handler is called.</p> <p>Consider this example:</p> <ul> <li>Some context is necessary to handle certain web requests (for example, a   database connection pool).</li> <li>A class that contains this context can be configured in application services   before the application starts.</li> <li>Request handlers have this context automatically injected.</li> </ul>"},{"location":"dependency-injection/#demo","title":"Demo","text":"<p>Starting from a minimal environment as described in the getting started tutorial, create a <code>foo.py</code> file with the following contents, inside a <code>domain</code> folder:</p> <pre><code>.\n\u251c\u2500\u2500 domain\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 foo.py\n\u2514\u2500\u2500 server.py\n</code></pre> <pre><code># domain/foo.py\nclass Foo:\n\n    def __init__(self) -&gt; None:\n        self.foo = \"Foo\"\n</code></pre> <p>Import the new class in <code>server.py</code>, and register the type in <code>app.services</code> as in this example:</p> <pre><code># server.py\nfrom blacksheep import Application, get\n\nfrom domain.foo import Foo\n\n\napp = Application()\n\napp.services.add_scoped(Foo)  # &lt;-- register Foo type as a service\n\n\n@get(\"/\")\ndef home(foo: Foo):  # &lt;-- foo is referenced in type annotation\n    return f\"Hello, {foo.foo}!\"\n</code></pre> <p>An instance of <code>Foo</code> is injected automatically for every web request to \"/\".</p> <p>Dependency injection is implemented in a dedicated library: Rodi. Rodi implements dependency injection in an unobtrusive way: it works by inspecting code and doesn't require altering the source code of the types it resolves.</p>"},{"location":"dependency-injection/#service-resolution","title":"Service resolution","text":"<p>Rodi automatically resolves dependency graphs when a resolved type depends on other types. In the following example, instances of <code>A</code> are automatically created when resolving <code>Foo</code> because the <code>__init__</code> method in <code>Foo</code> requires an instance of <code>A</code>:</p> <pre><code># domain/foo.py\nclass A:\n    pass\n\n\nclass Foo:\n    def __init__(self, dependency: A) -&gt; None:\n        self.dependency = dependency\n</code></pre> <p>Both types must be registered in <code>app.services</code>:</p> <pre><code># server.py\nfrom blacksheep import Application, get, text\n\nfrom domain.foo import A, Foo\n\n\napp = Application()\n\napp.services.add_transient(A)\napp.services.add_scoped(Foo)\n\n\n@get(\"/\")\ndef home(foo: Foo):\n    return text(\n        f\"\"\"\n        A: {id(foo.dependency)}\n        \"\"\"\n    )\n</code></pre> <p>Produces a response like the following at \"/\":</p> <pre><code>        A: 140289521293056\n</code></pre>"},{"location":"dependency-injection/#using-class-annotations","title":"Using class annotations","text":"<p>It is possible to use class properties, like in the example below:</p> <pre><code>class A:\n    pass\n\n\nclass Foo:\n    dependency: A\n</code></pre>"},{"location":"dependency-injection/#understanding-service-lifetimes","title":"Understanding service lifetimes","text":"<p><code>rodi</code> supports types having one of these lifetimes:</p> <ul> <li>singleton - instantiated only once.</li> <li>transient - services are instantiated every time they are required.</li> <li>scoped - instantiated once per web request.</li> </ul> <p>Consider the following example, where a type <code>A</code> is registered as transient, <code>B</code> as scoped, <code>C</code> as singleton:</p> <pre><code># domain/foo.py\nclass A:\n    ...\n\n\nclass B:\n    ...\n\n\nclass C:\n    ...\n\n\nclass Foo:\n    def __init__(self, a1: A, a2: A, b1: B, b2: B, c1: C, c2: C) -&gt; None:\n        self.a1 = a1\n        self.a2 = a2\n        self.b1 = b1\n        self.b2 = b2\n        self.c1 = c1\n        self.c2 = c2\n</code></pre> <pre><code># server.py\nfrom blacksheep import Application, get, text\n\nfrom domain.foo import A, B, C, Foo\n\n\napp = Application()\n\napp.services.add_transient(A)\napp.services.add_scoped(B)\napp.services.add_singleton(C)\n\napp.services.add_scoped(Foo)\n\n\n@get(\"/\")\ndef home(foo: Foo):\n    return text(\n        f\"\"\"\n        A1: {id(foo.a1)}\n\n        A2: {id(foo.a2)}\n\n        B1: {id(foo.b1)}\n\n        B2: {id(foo.b2)}\n\n        C1: {id(foo.c1)}\n\n        C2: {id(foo.c2)}\n        \"\"\"\n    )\n</code></pre> <p>Produces responses like the following at \"/\":</p> Request 1Request 2 <pre><code>        A1: 139976289977296\n\n        A2: 139976289977680\n\n        B1: 139976289977584\n\n        B2: 139976289977584\n\n        C1: 139976289978736\n\n        C2: 139976289978736\n</code></pre> <pre><code>        A1: 139976289979888\n\n        A2: 139976289979936\n\n        B1: 139976289979988\n\n        B2: 139976289979988\n\n        C1: 139976289978736\n\n        C2: 139976289978736\n</code></pre> <ul> <li>Transient services are created every time they are needed (A).</li> <li>Scoped services are created once per web request (B).</li> <li>Singleton services are instantiated only once and reused across the application (C).</li> </ul>"},{"location":"dependency-injection/#options-to-create-services","title":"Options to create services","text":"<p>Rodi provides several ways to define and instantiate services.</p> <ol> <li>registering an exact instance as a singleton</li> <li>registering a concrete class by its type</li> <li>registering an abstract class and one of its concrete implementations</li> <li>registering a service using a factory function</li> </ol> <p>For detailed information on this subject, refer to the Rodi documentation: Registering types.</p>"},{"location":"dependency-injection/#singleton-example","title":"Singleton example","text":"<pre><code>class ServiceSettings:\n    def __init__(\n        self,\n        oauth_application_id: str,\n        oauth_application_secret: str\n    ):\n        self.oauth_application_id = oauth_application_id\n        self.oauth_application_secret = oauth_application_secret\n\napp.services.add_instance(\n    ServiceSettings(\"00000000001\", os.environ[\"OAUTH_APP_SECRET\"])\n)\n</code></pre>"},{"location":"dependency-injection/#registering-a-concrete-class","title":"Registering a concrete class","text":"<pre><code>class HelloHandler:\n\n    def greetings() -&gt; str:\n        return \"Hello\"\n\n\napp.services.add_transient(HelloHandler)\n</code></pre>"},{"location":"dependency-injection/#registering-an-abstract-class","title":"Registering an abstract class","text":"<pre><code>from abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom blacksheep.server.responses import json, not_found\n\n\n# domain class and abstract repository defined in a dedicated package for\n# domain objects\n@dataclass\nclass Cat:\n    id: str\n    name: str\n\n\nclass CatsRepository(ABC):\n\n    @abstractmethod\n    async def get_cat_by_id(self, id: str) -&gt; Optional[Cat]:\n        pass\n\n# ------------------\n\n# the concrete implementation will be defined in a dedicated package\nclass PostgreSQLCatsRepository(CatsRepository):\n\n    async def get_cat_by_id(self, id: str) -&gt; Optional[Cat]:\n        # TODO: implement\n        raise Exception(\"Not implemented\")\n\n# ------------------\n\n# register the abstract class and its concrete implementation when configuring\n# the application\napp.services.add_scoped(CatsRepository, PostgreSQLCatsRepository)\n\n\n# a request handler needing the CatsRepository doesn't need to know about\n# the exact implementation (e.g. PostgreSQL, SQLite, etc.)\n@get(\"/api/cats/{cat_id}\")\nasync def get_cat(cat_id: str, repo: CatsRepository):\n\n    cat = await repo.get_cat_by_id(cat_id)\n\n    if cat is None:\n        return not_found()\n\n    return json(cat)\n</code></pre>"},{"location":"dependency-injection/#using-a-factory-function","title":"Using a factory function","text":"<pre><code>class Something:\n    def __init__(self, value: str) -&gt; None:\n        self.value = value\n\n\ndef something_factory(services, activating_type) -&gt; Something:\n    return Something(\"Factory Example\")\n\n\napp.services.add_transient_by_factory(something_factory)\n</code></pre>"},{"location":"dependency-injection/#example-implement-a-request-context","title":"Example: implement a request context","text":"<p>A good example of a scoped service is one used to assign each web request with a trace id that can be used to identify requests for logging purposes.</p> <pre><code>from uuid import UUID, uuid4\n\n\nclass OperationContext:\n    def __init__(self):\n        self._trace_id = uuid4()\n\n    @property\n    def trace_id(self) -&gt; UUID:\n        return self._trace_id\n</code></pre> <p>Register the <code>OperationContext</code> type as a scoped service, this way it is instantiated once per web request:</p> <pre><code>app.services.add_scoped(OperationContext)\n\n\n@get(\"/\")\ndef home(context: OperationContext):\n    return text(f\"Request ID: {context.trace_id}\")\n</code></pre>"},{"location":"dependency-injection/#services-that-require-asynchronous-initialization","title":"Services that require asynchronous initialization","text":"<p>Services that require asynchronous initialization can be configured using application events. The recommended way is using the <code>lifespan</code> context manager, like described in the example below.</p> <pre><code>import asyncio\nfrom blacksheep import Application\nfrom blacksheep.client.pool import ClientConnectionPools\nfrom blacksheep.client.session import ClientSession\n\napp = Application()\n\n\n@app.lifespan\nasync def register_http_client():\n    async with ClientSession(\n        pools=ClientConnectionPools(asyncio.get_running_loop())\n    ) as client:\n        print(\"HTTP client created and registered as singleton\")\n        app.services.register(ClientSession, instance=client)\n        yield\n\n    print(\"HTTP client disposed of\")\n\n\n@router.get(\"/\")\nasync def home(http_client: ClientSession):\n    print(http_client)\n    return {\"ok\": True, \"client_instance_id\": id(http_client)}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=44777, log_level=\"debug\", lifespan=\"on\")\n</code></pre> <p>Here are the key points describing the logic of using the <code>lifespan</code> decorator:</p> <ul> <li>Purpose: The <code>@app.lifespan</code> decorator is used to define asynchronous   setup and teardown logic for an application, such as initializing and   disposing of resources.</li> <li>Setup Phase: Code before the <code>yield</code> statement is executed when the   application starts. This is typically used to initialize resources (e.g.,   creating an HTTP client, database connections, or other services).</li> <li>Resource Registration: During the setup phase, resources can be   registered as services in the application's dependency injection container,   making them available for injection into request handlers.</li> <li>Teardown Phase: Code after the <code>yield</code> statement is executed when the   application stops. This is used to clean up or dispose of resources (e.g.,   closing connections or releasing memory).</li> <li>Singleton Resource Management: The <code>@lifespan</code> decorator is particularly   useful for managing singleton resources that need to persist for the   application's lifetime.</li> <li>Example Use Case: In the provided example, an <code>HTTP client</code> is created   and registered as a singleton during the setup phase, and it is disposed of   during the teardown phase.</li> </ul> <p>Otherwise, it is possible to use the <code>on_start</code> callback, like in the following example, to register a service that requires asynchronous initialization:</p> <pre><code>import asyncio\nfrom blacksheep import Application, get, text\n\n\napp = Application()\n\n\nclass Example:\n    def __init__(self, text):\n        self.text = text\n\n\nasync def configure_something(app: Application):\n    await asyncio.sleep(0.5)  # simulate 500 ms delay\n\n    app.services.add_instance(Example(\"Hello World\"))\n\n\napp.on_start += configure_something\n\n\n@get(\"/\")\nasync def home(service: Example):\n    return service.text\n</code></pre> <p>Services that require disposal can be disposed of in the <code>on_stop</code> callback:</p> <pre><code>async def dispose_example(app: Application):\n    service = app.service_provider[Example]\n    await service.dispose()\n\n\napp.on_stop += dispose_example\n</code></pre>"},{"location":"dependency-injection/#the-container-protocol","title":"The container protocol","text":"<p>Since version 2, BlackSheep supports alternatives to <code>rodi</code> for dependency injection. The <code>services</code> property of the <code>Application</code> class needs to conform to the following container protocol:</p> <ul> <li>The <code>register</code> method to register types.</li> <li>The <code>resolve</code> method to resolve instances of types.</li> <li>The <code>__contains__</code> method to describe whether a type is defined inside the   container.</li> </ul> <pre><code>class ContainerProtocol:\n    \"\"\"\n    Generic interface of DI Container that can register and resolve services,\n    and tell if a type is configured.\n    \"\"\"\n\n    def register(self, obj_type: Union[Type, str], *args, **kwargs):\n        \"\"\"Registers a type in the container, with optional arguments.\"\"\"\n\n    def resolve(self, obj_type: Union[Type[T], str], *args, **kwargs) -&gt; T:\n        \"\"\"Activates an instance of the given type, with optional arguments.\"\"\"\n\n    def __contains__(self, item) -&gt; bool:\n        \"\"\"\n        Returns a value indicating whether a given type is configured in this container.\n        \"\"\"\n</code></pre> <p>The following example demonstrates how to use <code>punq</code> for dependency injection as an alternative to <code>rodi</code>.</p> <pre><code>from typing import Type, TypeVar, Union, cast\n\nimport punq\n\nfrom blacksheep import Application\nfrom blacksheep.messages import Request\nfrom blacksheep.server.controllers import Controller, get\n\nT = TypeVar(\"T\")\n\n\nclass Foo:\n    def __init__(self) -&gt; None:\n        self.foo = \"Foo\"\n\n\nclass PunqDI:\n    \"\"\"\n    BlackSheep DI container implemented with punq\n\n    https://github.com/bobthemighty/punq\n    \"\"\"\n    def __init__(self, container: punq.Container) -&gt; None:\n        self.container = container\n\n    def register(self, obj_type, *args):\n        self.container.register(obj_type, *args)\n\n    def resolve(self, obj_type: Union[Type[T], str], *args) -&gt; T:\n        return cast(T, self.container.resolve(obj_type))\n\n    def __contains__(self, item) -&gt; bool:\n        return bool(self.container.registrations[item])\n\n\ncontainer = punq.Container()\ncontainer.register(Foo)\n\napp = Application(services=PunqDI(container), show_error_details=True)\n\n\n@get(\"/\")\ndef home(foo: Foo):  # &lt;-- foo is referenced in type annotation\n    return f\"Hello, {foo.foo}!\"\n\n\nclass Settings:\n    def __init__(self, greetings: str):\n        self.greetings = greetings\n\n\ncontainer.register(Settings, instance=Settings(\"example\"))\n\n\nclass Home(Controller):\n    def __init__(self, settings: Settings):\n        # controllers are instantiated dynamically at every web request\n        self.settings = settings\n\n    async def on_request(self, request: Request):\n        print(\"[*] Received a request!!\")\n\n    def greet(self):\n        return self.settings.greetings\n\n    @get(\"/home\")\n    async def index(self):\n        return self.greet()\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"localhost\", port=44777, log_level=\"debug\")\n</code></pre> <p>It is also possible to configure the dependency injection container using the <code>settings</code> namespace, like in the following example:</p> <pre><code>from blacksheep.settings.di import di_settings\n\n\ndef default_container_factory():\n    return PunqDI(punq.Container())\n\n\ndi_settings.use(default_container_factory)\n</code></pre> <p>Dependency injection libraries vary.</p> <p>Some features might not be supported when using a different kind of container, because not all libraries for dependency injection implement the notion of <code>singleton</code>, <code>scoped</code>, and <code>transient</code> (most only implement <code>singleton</code> and <code>transient</code>).</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRVT"},{"location":"develop-with-https/","title":"Develop using HTTPS","text":"<p>To develop locally with HTTPS using a trusted certificate, it is recommended to use <code>mkcert</code>, which is a simple tool for making locally-trusted development certificates.</p> <ul> <li>Install <code>mkcert</code></li> <li>Install the root certificates authority (CA) using the <code>mkcert --install</code> command</li> <li>Generate a certificate for local development using the command: <code>mkcert localhost 127.0.0.1 ::1</code></li> <li>Use the feature of the <code>ASGI</code> server you select, to run with HTTPS.   For <code>uvicorn</code>, refer to this documentation: https://www.uvicorn.org/deployment/#running-with-https.</li> </ul> <p>Example:</p> <pre><code>mkcert --install\n\nmkcert localhost 127.0.0.1 ::1\n\nuvicorn server:app --port 44555 --ssl-keyfile=./localhost-key.pem --ssl-certfile=./localhost.pem\n</code></pre> <p></p> <p>Last modified on: 2025-04-01 23:22:49</p>RP"},{"location":"extensions/","title":"Extensions","text":"<p>This page provides a list of BlackSheep projects, extensions, or packages providing integration with BlackSheep.</p>"},{"location":"extensions/#torino","title":"Torino","text":"<p>Torino is an advanced project built using BlackSheep for its API part, including a single page application built using React, TypeScript, HTML5, and SASS. It consists of a private file storage and photo gallery for Azure Storage Account. The project provides examples of how to integrate a BlackSheep API to PostgreSQL or SQLite using SQLAlchemy, with migrations, and also how to structure a project using dependency injection, integrate with Azure Application Insights, and more.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#blacksheep-sqlalchemy","title":"BlackSheep-SQLAlchemy","text":"<p>Extension for BlackSheep that simplifies the use of SQLAlchemy in the web framework.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#blacksheep-prometheus","title":"BlackSheep-Prometheus","text":"<p>Prometheus integration for BlackSheep. This package provides integration to collect telemetries about web requests.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#piccolo-orm","title":"Piccolo-ORM","text":"<p>Piccolo is a fast, user-friendly ORM and query builder which supports asyncio. Piccolo provides a CLI that lets you scaffold new ASGI applications, including support for BlackSheep.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#venezia","title":"Venezia","text":"<p>Venezia is an advanced demo project for a BlackSheep web service deployed to Azure App Service, using a PostgreSQL database, GitHub Workflows, and ARM templates. It includes an example integration with Azure Application Insights.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#apitally","title":"Apitally","text":"<p>Apitally is a lightweight monitoring and analytics tool for APIs, with built-in support for BlackSheep. It tracks API usage, errors, and performance, and includes request logging and alerting features.</p> <p>\ud83c\udfe0 Homepage</p> <p>Last modified on: 2025-05-01 10:33:51</p>RPEWSG"},{"location":"getting-started/","title":"Getting started with BlackSheep","text":"<p>This tutorial explains how to create and start a minimal BlackSheep web application. It provides an overview of the following topics:</p> <ul> <li> Creating a web application from scratch.</li> <li> Running the web application.</li> <li> Configuring routes.</li> <li> Handling parameters.</li> <li> Handling responses.</li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python version &gt;= 3.10 (3.8 and 3.9 are   supported but not recommended for this tutorial)</li> <li>Ensure the Python executable is included in the <code>$PATH</code> environment variable.   (tip: if you install Python on Windows using the official installer, enable   the checkbox to update your <code>$PATH</code> variable during the installation)</li> </ul>"},{"location":"getting-started/#preparing-a-development-environment","title":"Preparing a development environment","text":"<ol> <li>Create a folder in your desired location, open a terminal, and navigate to it.</li> <li>Create a virtual environment using the following command:</li> </ol> <pre><code>python -m venv venv\n</code></pre> <ol> <li>Activate the virtual environment:</li> </ol> On Linux or MacOn Windows <pre><code>source venv/bin/activate\n</code></pre> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>BlackSheep is an ASGI web framework, so it requires an ASGI HTTP server like uvicorn, or hypercorn. Install <code>uvicorn</code> and <code>blacksheep</code> for this tutorial:</p> <pre><code>pip install blacksheep uvicorn\n</code></pre>"},{"location":"getting-started/#creating-and-running-a-web-application","title":"Creating and running a web application","text":"<p>Create a file <code>server.py</code>, and paste the following contents into it:</p> <pre><code>from datetime import datetime\nfrom blacksheep import Application, get\n\n\napp = Application()\n\n@get(\"/\")\ndef home():\n    return f\"Hello, World! {datetime.now().isoformat()}\"\n</code></pre> <p>Use the command below to start the application using port <code>44777</code>, with automatic reload on file change:</p> <pre><code>uvicorn server:app --port 44777 --reload\n</code></pre> <p>The terminal should display information like in the picture below:</p> <p></p> <p>Open a web browser and navigate to http://127.0.0.1:44777. The web browser will display the text answer from the web application:</p> <p></p>"},{"location":"getting-started/#configuring-routes","title":"Configuring routes","text":"<p>The current code configures a request handler for the HTTP GET method at the application's root path: <code>\"/\"</code>. Notice how a function decorator registers the home function as a request handler:</p> <pre><code>@get(\"/\")\ndef home():\n    ...\n</code></pre> <p>This means that whenever a HTTP GET request is received at the root URL of the application (e.g. http://127.0.0.1:44777), the <code>home</code> function is used to handle the request and produce a response.</p> <p>Register more request handlers to handle more routes and HTTP methods. Update your <code>server.py</code> file to contain the following code, which includes two request handlers: one for <code>HTTP GET /</code>, and one for <code>HTTP POST /</code>.</p> <pre><code>from blacksheep import Application, get, post\n\n\napp = Application()\n\n\n@get(\"/\")\ndef home(request):\n    return \"GET Example\"\n\n\n@post(\"/\")\ndef post_example(request):\n    return \"POST Example\"\n</code></pre> <p>Auto reload.</p> <p>Thanks to <code>uvicorn</code>'s auto reload feature (used with <code>--reload</code> argument), when the <code>server.py</code> file is updated, the application is automatically reloaded. This is extremely useful during development.</p> <p>Navigate again to <code>http://127.0.0.1:44777</code>, it should display the text: <code>\"GET Example\"</code>.</p> <p>To verify that the <code>post_example</code> request handler is handling <code>POST</code> requests, make a POST HTTP request at the server's address. For example, using <code>curl</code> or PowerShell:</p> curlPowerShell <pre><code>curl -X POST http://127.0.0.1:44777\n</code></pre> <pre><code>Invoke-WebRequest -Uri http://localhost:44777 -Method POST\n</code></pre> <p>Info</p> <p>The application automatically handles requests for any path that is not handled by the router, returning an <code>HTTP 404 Not Found</code> response and producing <code>HTTP 500 Internal Server Error</code> responses in case of unhandled exceptions happening during code execution.</p>"},{"location":"getting-started/#handling-route-parameters","title":"Handling route parameters","text":"<p>So far the examples only showed request handlers that didn't use any input parameter. To define a request handler that uses a route parameter, define dynamic routes using the following syntax:</p> <pre><code>@get(\"/{name}\")\ndef greetings(name):\n    return f\"Hello, {name}!\"\n</code></pre> <p>Route parameters and function parameters are bound by matching names. Add the fragment of code above to <code>server.py</code> and navigate to <code>http://127.0.0.1:44777/World</code>.</p> <p>A route can contain several named parameters, separated by slashes, and dynamic fragments mixed with static fragments:</p> <pre><code>@get(\"/{one}/{two}/{three}\")\ndef multiple_parameters(one, two, three):\n    return f\"1: {one}, 2: {two}, 3: {three}!\"\n\n\n@get(\"/movies/{movie_id}/actors/{actor_id}\")\ndef mix(movie_id, actor_id):\n    ...\n</code></pre> <p>Route parameters are by default treated as strings, but BlackSheep supports automatic parsing of values when function arguments are annotated using built-in <code>typing</code> annotations. For example, to define a route that handles integer route parameters and returns <code>HTTP 400 Bad Request</code> for invalid values, it is sufficient to decorate the function argument this way:</p> <p>By default, route parameters are treated as strings. However, BlackSheep supports automatic value parsing when function arguments are annotated with type annotations. For instance, to define a route that handles integer parameters and returns an <code>HTTP 400 Bad Request</code> for invalid values, it is sufficient to decorate the function argument as follows:</p> <pre><code>@get(\"/lucky-number/{number}\")\ndef only_numbers_here(number: int):\n    return f\"Lucky number: {number}\\n\"\n</code></pre> curlPowerShell <pre><code>curl http://127.0.0.1:44777/lucky-number/777\nLucky number: 777\n\ncurl http://127.0.0.1:44777/lucky-number/x\nBad Request: Invalid value ['x'] for parameter `number`; expected a valid int.\n</code></pre> <pre><code>Invoke-WebRequest -Uri http://127.0.0.1:44777/lucky-number/777\n\nStatusCode        : 200\nStatusDescription : OK\nContent           : Lucky number: 777\n\nInvoke-WebRequest -Uri http://127.0.0.1:44777/lucky-number/x\nInvoke-WebRequest: Bad Request: Invalid value ['x'] for parameter `number`; expected a valid int.\n</code></pre> <p>Several built-in types are handled automatically, like <code>str</code>, <code>bool</code>, <code>int</code>, <code>float</code>, <code>uuid.UUID</code>, <code>datetime.date</code>, <code>datetime.datetime</code>, <code>list[T]</code>, <code>set[T]</code>.</p>"},{"location":"getting-started/#handling-query-string-parameters","title":"Handling query string parameters","text":"<p>BlackSheep can handle query string parameters automatically. Add this new fragment to your application:</p> <pre><code>@get(\"/query\")\ndef query_greetings(name: str):\n    return f\"Hello, {name}!\"\n</code></pre> <p>Then navigate to http://localhost:44777/query?name=World.</p> <p>Request handlers can work with various query strings, and query string parameters also support lists.</p> <pre><code>@get(\"/query-list\")\ndef greetings_many(name: list[str]):\n    return f\"Hello, {', '.join(name)}!\"\n\n# example:\n# http://localhost:44777/query-list?name=Charlie&amp;name=Lisa&amp;name=Snoopy\n# --&gt; Hello, Charlie, Lisa, Snoopy!\n</code></pre> <p>Every handler can have many input parameters from different sources: request headers, cookies, query, route, request body, and configured application services. These are treated in more detail in the dedicated page about Binders.</p>"},{"location":"getting-started/#accessing-the-request-object","title":"Accessing the request object","text":"<p>To access the HTTP Request object directly, add a parameter called \"request\" to the signature of a request handler (type annotation is optional):</p> <pre><code>from blacksheep import Request\n\n@get(\"/request-object\")\ndef request_object(request: Request):\n    # the request object exposes methods to read headers, cookies,\n    # body, route parameters\n    ...\n</code></pre> <p>Info</p> <p>You can name the request parameter any way you like (e.g. <code>request</code>, <code>req</code>, <code>foo</code>, etc.), as long as you keep the correct type annotation (<code>blacksheep.Request</code>).</p>"},{"location":"getting-started/#handling-responses","title":"Handling responses","text":"<p>Generally, request handlers in BlackSheep must return an instance of <code>blacksheep.messages.Response</code> class. The framework offers several functions for generating responses for various use cases, which are defined in the <code>blacksheep.server.responses</code> namespace.</p> <p>The following example demonstrates how to serve a JSON response using a class defined with <code>dataclass</code>. Replace the contents of <code>server.py</code> with the following code:</p> <pre><code>from dataclasses import dataclass\nfrom uuid import UUID, uuid4\n\nfrom blacksheep import Application, get, json\n\n\n@dataclass\nclass Cat:\n    id: UUID\n    name: str\n    active: bool\n\n\napp = Application()\n\n\n@get(\"/api/cats\")\ndef get_cats():\n    return json(\n        [\n            Cat(uuid4(), \"Lampo\", True),\n            Cat(uuid4(), \"Milady\", True),\n            Cat(uuid4(), \"Meatball\", True),\n            Cat(uuid4(), \"Pilou\", True),\n        ]\n    )\n</code></pre> <p>Navigate to http://127.0.0.1:44777/api/cats to view the result, which will look like this:</p> <pre><code>[{\"id\":\"9dea0080-0e92-46e0-b090-55454c23d37f\",\"name\":\"Lampo\",\"active\":true},\n{\"id\":\"3ce81720-de11-41b4-bad4-6fa63e00403d\",\"name\":\"Milady\",\"active\":true},\n{\"id\":\"2981d8a4-52c3-4ed9-96b8-30fafe62bc47\",\"name\":\"Meatball\",\"active\":true},\n{\"id\":\"b697358e-0f74-4449-840a-32c8db839244\",\"name\":\"Pilou\",\"active\":true}]\n</code></pre> <p>Notice how the <code>json</code> function creates an instance of <code>Response</code> with content serialized into a JSON string.</p> <pre><code>from blacksheep import json\n\nresponse = json({\"example\": 1})\nresponse.content\n&lt;blacksheep.contents.Content object at 0x7f4ebcf30720&gt;\n\nresponse.content.body\nb'{\"example\":1}'\n\nresponse.content.length\n13\n</code></pre> <p>Tip</p> <p>Try also the <code>pretty_json</code> function in <code>blacksheep.server.responses</code>, which returns indented JSON.</p> <p>For more granular control, it is possible to use the <code>blacksheep.messages.Response</code> class directly (read <code>blacksheep.server.responses</code> module for examples), and it is possible to modify the response before returning it to the client. For instance, to set a response header:</p> <pre><code>@get(\"/api/cats\")\ndef get_cats():\n    response = json(\n        [\n            Cat(uuid4(), \"Lampo\", True),\n            Cat(uuid4(), \"Milady\", True),\n            Cat(uuid4(), \"Meatball\", True),\n            Cat(uuid4(), \"Pilou\", True),\n        ]\n    )\n\n    response.add_header(b\"X-Foo\", b\"Foo!\")\n\n    return response\n</code></pre> <p>User-defined request handlers can return arbitrary objects, which will be automatically converted to JSON responses.</p> <pre><code>@get(\"/api/cats\")\ndef get_cats() -&gt; list[Cat]:\n    return [\n        Cat(uuid4(), \"Lampo\", True),\n        Cat(uuid4(), \"Milady\", True),\n        Cat(uuid4(), \"Meatball\", True),\n        Cat(uuid4(), \"Pilou\", True),\n    ]\n</code></pre> <p>The rationale behind this design choice is that JSON is the most widely used format for serializing objects today. This feature helps reduce code verbosity while making the return type explicit. Furthermore, it enables the automatic generation of OpenAPI documentation to describe the response body.</p>"},{"location":"getting-started/#asynchronous-request-handlers","title":"Asynchronous request handlers","text":"<p>The examples so far have demonstrated synchronous request handlers. To create asynchronous request handlers, use <code>async</code> functions:</p> <pre><code>@get(\"/api/movies\")\nasync def get_movies():\n    # ... do something async (example)\n    movies = await movies_provider.get_movies()\n    return json(movies)\n</code></pre> <p>Asynchronous code is described more in other sections of the documentation.</p>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>This tutorial covered the basics of creating a BlackSheep application. The general concepts introduced here are applicable to any web framework:</p> <ul> <li>server-side routing</li> <li>handling query strings and route parameters</li> <li>handling requests and responses</li> </ul> <p>The next page will explore a more advanced scenario, including server-side rendering of HTML views, serving static files, and more features.</p> <ul> <li>Getting started with the MVC project template</li> </ul> <p>Last modified on: 2025-04-22 08:29:25</p>RPRVEW"},{"location":"hsts/","title":"HSTS","text":"<p>The HTTP Strict-Transport-Security (HSTS) response header is a standard feature that instructs clients to access a site exclusively using HTTPS. Any attempt to access the site via HTTP is automatically redirected to HTTPS.</p> <p>BlackSheep provides middleware to globally configure the HTTP Strict-Transport-Security (HSTS) response header. This page explains how to use the built-in middleware to enforce HSTS in a web application.</p>"},{"location":"hsts/#enabling-hsts","title":"Enabling HSTS","text":"<pre><code>from blacksheep import Application\nfrom blacksheep.server.env import is_development\nfrom blacksheep.server.security.hsts import HSTSMiddleware\n\napp = Application()\n\n\nif not is_development():\n    app.middlewares.append(HSTSMiddleware())\n</code></pre> <p>Considerations for local development.</p> <p>Enabling <code>HSTS</code> during local development is generally not recommended, as it instructs browsers to require <code>HTTPS</code> for all traffic on <code>localhost</code>. For this reason, the example above configures the middleware only when the application is not running in development mode. Refer to Defining application environment for more information.</p>"},{"location":"hsts/#options","title":"Options","text":"Option Type Description max_age <code>int</code> Control the <code>max-age</code> directive of the HSTS header (default 31536000) include_subdomains <code>bool</code> Control the <code>include-subdomains</code> directive of the HSTS header (default false)"},{"location":"hsts/#for-more-information","title":"For more information","text":"<p>For more information on HTTP Strict Transport Security, refer to the developer.mozilla.org documentation.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"},{"location":"middlewares/","title":"Middlewares","text":"<p>Middlewares enable modifying the chain of functions that handle each web request.</p> <p>This page covers:</p> <ul> <li> Introduction to middlewares.</li> <li> How to use function decorators to avoid code repetition.</li> </ul>"},{"location":"middlewares/#introduction-to-middlewares","title":"Introduction to middlewares","text":"<p>Middlewares enable the definition of callbacks that are executed for each web request in a specific order.</p> <p>Info</p> <p>If a function should only be called for specific routes, use a decorator function instead.</p> <p>Middlewares are executed in order: each receives the <code>Request</code> object as the first parameter and the next handler to be called as the second parameter. Any middleware can choose not to call the next handler and instead return a <code>Response</code> object. For instance, a middleware can be used to return an <code>HTTP 401 Unauthorized</code> response in certain scenarios.</p> <pre><code>from blacksheep import Application, get\n\napp = Application()\n\n\nasync def middleware_one(request, handler):\n    print(\"middleware 1: A\")\n    response = await handler(request)\n    print(\"middleware 1: B\")\n    return response\n\n\nasync def middleware_two(request, handler):\n    print(\"middleware 2: C\")\n    response = await handler(request)\n    print(\"middleware 2: D\")\n    return response\n\n\napp.middlewares.append(middleware_one)\napp.middlewares.append(middleware_two)\n\n\n@get(\"/\")\ndef home():\n    return \"OK\"\n</code></pre> <p>In this example, the following data would be printed to the console:</p> <pre><code>middleware 1: A\nmiddleware 2: C\nmiddleware 2: D\nmiddleware 1: B\n</code></pre>"},{"location":"middlewares/#middlewares-defined-as-classes","title":"Middlewares defined as classes","text":"<p>To define a middleware as a class, make the class async callable, like in the example below:</p> <pre><code>class ExampleMiddleware:\n\n    async def __call__(self, request, handler):\n        # do something before passing the request to the next handler\n\n        response = await handler(request)\n\n        # do something after the following request handlers prepared the response\n        return response\n</code></pre> <p>The same example including type annotations:</p> <pre><code>from typing import Awaitable, Callable\n\nfrom blacksheep import Request, Response\n\n\nclass ExampleMiddleware:\n    async def __call__(\n        self, request: Request, handler: Callable[[Request], Awaitable[Response]]\n    ) -&gt; Response:\n        # do something before passing the request to the next handler\n\n        response = await handler(request)\n\n        # do something after the following request handlers prepared the response\n        return response\n</code></pre>"},{"location":"middlewares/#resolution-chains","title":"Resolution chains","text":"<p>When middlewares are defined for an application, resolution chains are built at its start. Every handler configured in the application router is replaced by a chain, executing middlewares in order, down to the registered handler.</p>"},{"location":"middlewares/#wrapping-request-handlers","title":"Wrapping request handlers","text":"<p>When a common portion of logic should be applied to certain request handlers, but not to all of them, it is recommended to define a decorator.</p> <p>The following example shows how to define a decorator that applies certain response headers only for certain routes.</p> <pre><code>from functools import wraps\nfrom typing import Tuple\n\nfrom blacksheep.server.normalization import ensure_response\n\n\ndef headers(additional_headers: Tuple[Tuple[str, str], ...]):\n    def decorator(next_handler):\n        @wraps(next_handler)\n        async def wrapped(*args, **kwargs) -&gt; Response:\n            response = ensure_response(await next_handler(*args, **kwargs))\n\n            for (name, value) in additional_headers:\n                response.add_header(name.encode(), value.encode())\n\n            return response\n\n        return wrapped\n\n    return decorator\n</code></pre> <p>Then use the decorator on specific request handlers:</p> <pre><code>@get(\"/\")\n@headers(((\"X-Foo\", \"Foo\"),))\nasync def home():\n    return \"OK\"\n</code></pre> <p>The order of decorators matters.</p> <p>User-defined decorators must be applied before the route decorator (in the example above, before <code>@get</code>).</p>"},{"location":"middlewares/#define-a-wrapper-compatible-with-synchronous-and-asynchronous-functions","title":"Define a wrapper compatible with synchronous and asynchronous functions","text":"<p>To define a wrapper that is compatible with both synchronous and asynchronous functions, it is possible to use <code>inspect.iscoroutinefunction</code> function. For example, to alter the decorator above to be also compatible with request handlers defined as synchronous functions:</p> <pre><code>import inspect\nfrom functools import wraps\nfrom typing import Tuple\n\nfrom blacksheep.server.normalization import ensure_response\n\n\ndef headers(additional_headers: Tuple[Tuple[str, str], ...]):\n    def decorator(next_handler):\n\n        if inspect.iscoroutinefunction(next_handler):\n            @wraps(next_handler)\n            async def wrapped(*args, **kwargs):\n                response = ensure_response(await next_handler(*args, **kwargs))\n\n                for (name, value) in additional_headers:\n                    response.add_header(name.encode(), value.encode())\n\n                return response\n\n            return wrapped\n        else:\n            @wraps(next_handler)\n            def wrapped(*args, **kwargs):\n                response = ensure_response(next_handler(*args, **kwargs))\n\n                for (name, value) in additional_headers:\n                    response.add_header(name.encode(), value.encode())\n\n                return response\n\n            return wrapped\n\n    return decorator\n</code></pre> <p>Warning</p> <p>The <code>ensure_response</code> function is necessary to support scenarios when the request handlers defined by the user doesn't return an instance of Response class (see request handlers normalization).</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"mounting/","title":"Mounting applications","text":"<p>The term 'mounting' refers to the ability to integrate ASGI applications into others under specific routes. This enables reusing whole applications across web applications. This page covers:</p> <ul> <li> Using the mount feature.</li> <li> Details about mounting and handling of application events.</li> <li> Mounting and OpenAPI Documentation.</li> <li> An example using Piccolo Admin.</li> </ul>"},{"location":"mounting/#how-to-use-mounts","title":"How to use mounts","text":"<p>To mount an application in another application, use the <code>mount</code> method:</p> <pre><code>parent_app.mount(\"/example-path\", child_app)\n</code></pre> <p>Example:</p> <pre><code>from blacksheep import Application\n\nparent = Application()\n\n\n@parent.router.get(\"/\")\ndef parent_home():\n    return \"Hello, from the parent app\"\n\n\nchild = Application()\n\n\n@child.router.get(\"/\")\ndef child_home():\n    return \"Hello, from the child app\"\n\n\n# Note: when mounting another BlackSheep application,\n# make sure to handle the start and stop events of the mounted app\nparent.mount_registry.auto_events = True\n\nparent.mount(\"/sub\", child)\n</code></pre> <p>In the example above, both <code>parent</code> and <code>child</code> are complete applications that can be started independently. If <code>child</code> is started alone, it replies to GET web requests at route \"/\" with the text \"Hello, from the child app\".</p> <p>Since <code>parent</code> mounts <code>child</code> under the path '/sub', it delegates requests starting with <code>/sub/*</code> to the mounted application. As a result, when parent is started, a GET request to the route '/sub' produces the greeting message from <code>child</code>. A GET request to the route \"/\" instead is replied with the text \"Hello, from the parent app\".</p> <p>///!!! info     Try to create a file <code>server.py</code> like in the example above, and run the     applications using <code>uvicorn</code>, to verify how they work in practice.</p>"},{"location":"mounting/#side-effects-of-mounting","title":"Side effects of mounting","text":"<p>Although mounting enables interesting scenarios, it comes at a cost.</p> <p>Applications that are supposed to be mounted by other applications need to be designed to be \"mount-friendly\", for example when they handle redirects or links to static files they serve. Absolute paths will not work when used by applications that are mounted by other applications, while relative paths will work.</p> <p>If an application is not designed to be mounted by other applications, it might create non-obvious side effects.</p> <p>Consider the following example:</p> <pre><code>from blacksheep import Application, redirect\n\napp_a = Application()\n\n\n@app_a.router.get(\"/\")\ndef a_home():\n    return \"Hello, from Application A\"\n\n\n@app_a.router.get(\"/test\")\ndef redirect_to_home():\n    # Note: app_a defines an absolute path for redirection - this won't work\n    # for mounted apps since the intention is most likely to redirect to a path\n    # handled by the same application\n    return redirect(\"/\")\n\n\napp_b = Application()\n\n\n@app_b.router.get(\"/\")\ndef b_home():\n    return \"Hello, from Application B\"\n\n\n@app_b.on_start\nasync def handle_app_a_start(_):\n    await app_a.start()\n\n\n@app_b.on_stop\nasync def handle_app_a_stop(_):\n    await app_a.stop()\n\n\napp_b.mount(\"/a\", app_a)\n</code></pre> <p>This won't produce the expected result in real-life scenarios. <code>app_a</code> in this case redirects to the absolute path \"/\", therefore a path that is handled by <code>app_b</code>. In general, mounted apps will be defined in dedicated packages with no knowledge of the applications that mount them. To fix this scenario, it is necessary to use a relative path for redirection, like:</p> <pre><code>@app_a.router.get(\"/test\")\ndef redirect_to_home():\n    return redirect(\"./\")\n</code></pre>"},{"location":"mounting/#handling-of-application-events","title":"Handling of application events","text":"<p>Applications often need to define actions that must happen when the application starts, and actions that must happen when the application stops.</p> <p>ASGI web frameworks handle lifecycle events when they get dedicated messages from the underlying ASGI server (<code>lifespan</code> messages), notifying the ASGI server when initialization logic has completed. However, when an application is mounted into another, it is not responsible for handling <code>lifespan</code> messages.</p> <p>When mounted apps define initialization and shutdown logic, the application that mounts them must register their initialization and shutdown functions as part of its own events.</p> <p>BlackSheep applications must always be started to work properly. To enable the automatic handling of application events for mounted applications, use of the following options:</p> <ol> <li>use the env variable <code>APP_MOUNT_AUTO_EVENTS</code> set to a truthy value (\"1\", \"true\",    \"TRUE\") - recommended</li> <li>set the <code>parent.mount_registry.auto_events</code> property to <code>True</code></li> <li>handle application events explicitly like in the example below - necessary    when the mounted applications are other kinds of ASGI apps</li> </ol> <pre><code>@parent.on_start\nasync def handle_child_start(_):\n    await child.start()\n\n\n@parent.on_stop\nasync def handle_child_stop(_):\n    await child.stop()\n\n\nparent.mount(\"/some-route\", child)\n</code></pre> <p>This ensures that when the main application handles <code>lifespan</code> messages from the ASGI HTTP Server, the mounted app is also notified properly of those events.</p> <p>Info</p> <p>The way the mounted app must be started and stopped depends on the web framework used to implement it. The example above is correct when <code>child</code> is an instance of BlackSheep Application.</p>"},{"location":"mounting/#mounting-and-openapi-documentation","title":"Mounting and OpenAPI Documentation","text":"<p>Since version <code>1.2.5</code>, BlackSheep supports generating OpenAPI Documentation for mounted BlackSheep applications, meaning that parent applications can expose OpenAPI Documentation about all endpoints, including those of mounted apps and their descendants.</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\nfrom openapidocs.v3 import Info\n\nfrom blacksheep import Application\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\n\nparent = Application(show_error_details=True)\nparent.mount_registry.auto_events = True\nparent.mount_registry.handle_docs = True\n\n\ndocs = OpenAPIHandler(info=Info(title=\"Parent API\", version=\"0.0.1\"))\ndocs.bind_app(parent)\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n    email: str\n    foo: int\n\n\n@dataclass\nclass CreateDogInput:\n    name: str\n    email: str\n    example: int\n\n\n@dataclass\nclass CreateParrotInput:\n    name: str\n    email: str\n\n\n@parent.router.get(\"/\")\ndef a_home():\n    \"\"\"Parent root.\"\"\"\n    return \"Hello, from the parent app - for information, navigate to /docs\"\n\n\n@parent.router.get(\"/cats\")\ndef get_cats_conflicting():\n    \"\"\"Conflict!\"\"\"\n    return \"CONFLICT\"\n\n\nchild_1 = Application()\n\n\n@child_1.router.get(\"/\")\ndef get_cats():\n    \"\"\"Gets a list of cats.\"\"\"\n    return \"Gets a list of cats.\"\n\n\n@child_1.router.post(\"/\")\ndef create_cat(data: CreateCatInput):\n    \"\"\"Creates a new cat.\"\"\"\n    return \"Creates a new cat.\"\n\n\n@child_1.router.delete(\"/{cat_id}\")\ndef delete_cat(cat_id: str):\n    \"\"\"Deletes a cat by id.\"\"\"\n    return \"Deletes a cat by id.\"\n\n\nchild_2 = Application()\n\n\n@child_2.router.get(\"/\")\ndef get_dogs():\n    \"\"\"Gets a list of dogs.\"\"\"\n    return \"Gets a list of dogs.\"\n\n\n@child_2.router.post(\"/\")\ndef create_dog(data: CreateDogInput):\n    \"\"\"Creates a new dog.\"\"\"\n    return \"Creates a new dog.\"\n\n\n@child_2.router.delete(\"/{dog_id}\")\ndef delete_dog(dog_id: str):\n    \"\"\"Deletes a dog by id.\"\"\"\n    return \"Deletes a dog by id.\"\n\n\nchild_3 = Application()\n\n\n@child_3.router.get(\"/\")\ndef get_parrots():\n    \"\"\"Gets a list of parrots.\"\"\"\n    return \"Gets a list of parrots\"\n\n\n@child_3.router.post(\"/\")\ndef create_parrot(data: CreateParrotInput):\n    \"\"\"Creates a new parrot.\"\"\"\n    return \"Creates a new parrot\"\n\n\n@child_3.router.delete(\"/{parrot_id}\")\ndef delete_parrot(parrot_id: str):\n    \"\"\"Deletes a parrot by id.\"\"\"\n    return \"Deletes a parrot by id.\"\n\n\nparent.mount(\"/cats\", child_1)\nparent.mount(\"/dogs\", child_2)\nparent.mount(\"/parrots\", child_3)\n</code></pre> <p>Produces OpenAPI Documentation for all endpoints.</p> <p></p>"},{"location":"mounting/#examples","title":"Examples","text":"<p>To see a working example where <code>mount</code> is used, see the Piccolo Admin example at BlackSheep-Examples.</p> <p>In this example, Piccolo Admin is configured as a mounted app under \"/admin\" route, providing a UI to handle data stored in a <code>SQLite</code> database.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"mvc-project-template/","title":"Getting started with the MVC project template","text":"<p>This tutorial explains how to create a BlackSheep application using the MVC (Model, View, Controller) project template, covering the following topics:</p> <ul> <li> Creating an application from a project template, using the BlackSheep CLI.</li> <li> Routes defined using classes (controllers).</li> <li> Server side templating (views and models).</li> <li> Handling parameters in controllers.</li> <li> Serving static files</li> </ul> <p>It is recommended to follow the previous tutorial before reading this one.</p>"},{"location":"mvc-project-template/#requirements","title":"Requirements","text":"<ul> <li>Python version &gt;= 3.10 (3.8 and 3.9 are   supported but not recommended for this tutorial)</li> <li>Ensure the Python executable is included in the <code>$PATH</code> environment variable.   (tip: if you install Python on Windows using the official installer, enable   the checkbox to update your <code>$PATH</code> variable during the installation)</li> <li>a text editor: any is fine; this tutorial uses Visual Studio Code</li> </ul>"},{"location":"mvc-project-template/#introduction-to-the-blacksheep-cli","title":"Introduction to the BlackSheep CLI","text":"<p>The previous tutorial covered the basics of creating an application from scratch. While that knowledge is important, starting every project from scratch is often unnecessary. BlackSheep provides a command-line interface (CLI) to simplify the process of starting new projects. The CLI can be installed from the Python Package Index using the <code>blacksheep-cli</code> package:</p> <pre><code>pip install blacksheep-cli\n</code></pre> <p>The BlackSheep-CLI provides the <code>create</code> command to start new projects:</p> <pre><code>blacksheep create\n</code></pre> <p>The CLI will prompt for input about various options. For the sake of this tutorial, answer:</p> <ul> <li><code>tutorial</code> for project name</li> <li><code>mvc</code> for the project template</li> <li><code>Yes</code> for OpenAPI Documentation</li> <li><code>essentials-configuration</code> to read settings</li> <li><code>YAML</code> for app settings format</li> </ul> <pre><code>\u2728 Project name: tutorial\n\ud83d\ude80 Project template: mvc\n\ud83d\udcdc Use OpenAPI Documentation? Yes\n\ud83d\udd27 Library to read settings essentials-configuration\n\ud83d\udd29 App settings format (Use arrow keys)\n \u00bb YAML\n   TOML\n   JSON\n   INI\n</code></pre> <p>BlackSheep create.</p> <p>It is possible to use the <code>create</code> command specifying the project name and template directly, like in:</p> <ul> <li><code>blacksheep create some_name</code></li> <li><code>blacksheep create some_name --template api</code></li> </ul> <p></p> <p>After a project is created, the CLI displays a message with instructions:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ud83c\udfd7\ufe0f  Project created in tutorial\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-- What's next:\n        cd tutorial\n        pip install -r requirements.txt\n        python dev.py\n</code></pre> <p>Install the project dependencies:</p> <ul> <li><code>cd</code> into the project folder</li> <li>create a new Python virtual environment (recommended but optional)</li> <li>install its dependencies with <code>pip install -r requirements.txt</code></li> </ul>"},{"location":"mvc-project-template/#starting-the-application","title":"Starting the application","text":"<p>Start the application using one of the following commands:</p> <pre><code># using the provided dev.py file (useful to debug)\npython dev.py\n\n# or using the uvicorn CLI\nuvicorn app.main:app --port 44777 --lifespan on --reload\n</code></pre> <p>Navigate to the local page, opening a browser at <code>http://localhost:44777</code> (use the same port used in the previous command).</p> <p>The browser should display this page:</p> <p></p> <p>The web application is configured to handle several tasks:</p> <ul> <li>Build and serve dynamic HTML pages.</li> <li>Serve static files (e.g., images, JavaScript, CSS files).</li> <li>Expose an API and provide OpenAPI documentation for it.</li> <li>Handle application settings and manage application start/stop events.</li> </ul> <p>Let's explore these elements in order, but first, let's review the project's structure.</p>"},{"location":"mvc-project-template/#project-structure","title":"Project structure","text":"<p>The project follows the folder structure outlined below:</p> <pre><code>\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 (application files)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controllers\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 (controller files, defining routes)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 (files for OpenAPI Documentation)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 static\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 (static files served by the web app)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 (HTML templates, views compiled by the web app)\n\u2502\n\u251c\u2500\u2500 domain\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 (domain classes, POCO)\n\u2502\n\u251c\u2500\u2500 (root folder, where the main file starting the whole app resides)\n\u251c\u2500\u2500 dev.py  (file that can be used to start a development server, useful for debugging)\n\u2514\u2500\u2500 settings.dev.yaml (settings used when the env variable APP_ENV == dev)\n\u2514\u2500\u2500 settings.yaml (base settings file)\n</code></pre> <ul> <li>The <code>app</code> folder contains files that are specific to the web application,   settings, a folder for <code>controllers</code> that define request handlers, folders   for <code>static</code> files and one for <code>views</code> (HTML templates).</li> <li>Other packages at the root of the project, like <code>domain</code>, should be   abstracted from the web server and potentially reusable in other kinds of   applications.</li> <li>The root folder contains the <code>dev.py</code> file to start the application in   development mode, and settings files with <code>.yaml</code> extension that are read   when the application starts (since the YAML format was selected when using   the <code>blacksheep create</code> command).</li> </ul>"},{"location":"mvc-project-template/#open-the-project-with-a-text-editor","title":"Open the project with a text editor","text":"<p>Open the project's folder using your favorite text editor.</p> <p></p>"},{"location":"mvc-project-template/#routes-defined-using-classes-controllers","title":"Routes defined using classes (controllers)","text":"<p>The previous tutorial described how routes can be defined using functions:</p> <pre><code>@get(\"/\")\nasync def home():\n    ...\n</code></pre> <p>BlackSheep offers an alternative way to define request handlers: using classes. Both approaches have pros and cons, which will be described later in more detail. To see this in practice, create a new file <code>app/controllers/greetings.py</code> and copy the following code into it:</p> <pre><code>from blacksheep.server.controllers import Controller, get\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-world\")\n    def index(self):\n        return self.text(\"Hello, World!\")\n</code></pre> <p>Stop and restart the application, then navigate to <code>http://localhost:44777/hello-world</code>: it will display the response from the <code>Greetings.index</code> method.</p> <p>When the path of a web request matches a route defined in a controller, a new instance of that <code>Controller</code> is created to handle the request. In other words, each container instance is scoped to a specific web request. Just like function handlers, controllers support automatic injection of parameters and dependency injection to resolve parameters defined in constructors (<code>__init__</code> methods) and class properties. This feature enhances development speed and promotes cleaner code.</p> <p>Rodi documentation.</p> <p>Refer to Rodi's documentation for a detailed introduction to dependency injection.</p> <p>The <code>Controller</code> class provides methods to return various kinds of responses and offers <code>on_request</code> and <code>on_response</code> extensibility points. These functions can be overridden in subclasses of <code>Controller</code> to apply logic at the start and end of each web request.</p> <p>Automatic import of controllers and routes.</p> <p>Python modules defined inside <code>controllers</code> and <code>routes</code> packages are automatically imported by a BlackSheep application. The automatic import happens relatively to the namespace where the application is instantiated.</p>"},{"location":"mvc-project-template/#server-side-templating-views-and-models","title":"Server side templating (views and models)","text":"<p>Server-side templating refers to a web application's ability to generate HTML pages using templates and dynamic variables. By default, BlackSheep achieves this with the <code>Jinja2</code> library developed by the Pallets team.</p> <p>To see how this works in practice when using controllers, edit the <code>Greetings</code> controller created previously as follows:</p> <pre><code>from blacksheep.server.controllers import Controller, get\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-view\")\n    def hello(self):\n        return self.view()\n</code></pre> <p>Then, create a new folder inside <code>views</code> directory, named \"greetings\", and add an HTML file named \"hello.jinja\".</p> <p></p> <p>Copy the following contents into <code>hello.jinja</code>:</p> <pre><code>&lt;div&gt;\n  &lt;h1&gt;Hello, There&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>Now navigate to http://localhost:44777/hello-view, to see the response from the new HTML view.</p> <p>Notice how convention over configuration is used in this case, to determine that <code>./views/greetings/hello.jinja</code> file must be used, because of the convention: <code>./views/{CONTROLLER_NAME}/{METHOD_NAME}.jinja</code>.</p> <p>The view currently is an HTML fragment, not a full document. To make it a full page, modify <code>hello.jinja</code> to use the application layout:</p> <pre><code>{%- extends \"layout.jinja\" -%}\n{%- block title -%}\n  Hello Page!\n{%- endblock -%}\n{%- block description -%}\n  Project template to create web applications with MVC architecture using BlackSheep web framework.\n{%- endblock -%}\n{%- block css -%}\n  &lt;link rel=\"stylesheet\" href=\"/styles/public.css\" /&gt;\n{%- endblock -%}\n{%- block body -%}\n  &lt;div style=\"margin: 10em 2em;\"&gt;\n    &lt;h1&gt;Hello, There!&lt;/h1&gt;\n  &lt;/div&gt;\n{%- endblock -%}\n{%- block js -%}\n\n{%- endblock -%}\n</code></pre> <p>Refresh the page at http://localhost:44777/hello-view to see the result.</p> <p>In this case, a page layout is applied using: <code>{%- extends \"layout.jinja\" -%}</code>, with several blocks defined in <code>layout.jinja</code>. For more information on layouts and features of the templating library, refer to the Jinja2 documentation.</p> <p>Until now, the tutorial have only demonstrated the Controller and View components of the MVC architecture. A Model serves as the context for an HTML view. To include dynamic content in an HTML template, use mustache-style <code>{{name}}</code> placeholders and pass a model with properties whose names match the placeholders to the <code>view</code> function.</p> <p>For example, modify <code>hello.jinja</code> to use dynamic content from a model:</p> <pre><code>  &lt;div style=\"margin: 10em 2em;\"&gt;\n    &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;\n\n    &lt;ul&gt;\n      {% for sentence in sentences %}\n        &lt;li&gt;&lt;a href=\"{{ sentence.url }}\"&gt;{{ sentence.text }}&lt;/a&gt;&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n</code></pre> <p>and <code>greetings.py</code> to contain the following code:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom blacksheep.server.controllers import Controller, get\n\n\n@dataclass\nclass Sentence:\n    text: str\n    url: str\n\n\n@dataclass\nclass HelloModel:\n    name: str\n    sentences: List[Sentence]\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-view\")\n    def hello(self):\n        return self.view(\n            model=HelloModel(\n                \"World!\",\n                sentences=[\n                    Sentence(\n                        \"Check this out!\",\n                        \"https://github.com/Neoteroi/BlackSheep\",\n                    )\n                ],\n            )\n        )\n</code></pre> <p>Produces this result: </p> <p>Models can be defined as dictionaries, dataclasses, pydantic models, or regular classes implementing a constructor.</p>"},{"location":"mvc-project-template/#handling-parameters-in-controllers","title":"Handling parameters in controllers","text":"<p>The Getting started guide demonstrated how request handlers support the automatic injection of parameters from HTTP requests. Controllers offer the same functionality, allowing parameters to be automatically read and passed into controller methods:</p> <pre><code>class Example(Controller):\n\n    @get(\"/example/{value}\")\n    def route_example(self, value: str):\n        return self.text(f\"Got: {value} in route\")\n\n    @get(\"/example\")\n    def query_example(self, value: str):\n        return self.text(f\"Got: {value} in query string\")\n</code></pre> <p>Controllers also support dependency injection for their constructor (<code>__init__</code> method) and class properties, this will be explained in the next page.</p>"},{"location":"mvc-project-template/#serving-static-files","title":"Serving static files","text":"<p>The homepage of the MVC project template looks like in the following picture:</p> <p></p> <p>The project template includes a folder for static files, such as images, CSS, and JavaScript files. Static files are served using a catch-all route that reads files whose paths, relative to the static folder, match the URL path of the request.</p> <p>For example, if the <code>static</code> folder contains the file <code>scripts/example.js</code>, an HTTP GET web request to <code>http://localhost:44777/scripts/example.js</code> will resolve to this file and its related information. When serving static files, BlackSheep automatically handles several tasks:</p> <ul> <li>It manages the <code>ETag</code> response header, the <code>If-None-Match</code> request header, and   <code>HTTP 304 Not Modified</code> responses when files remain unchanged on the file   system.</li> <li>It processes <code>HTTP GET</code> and <code>HTTP HEAD</code> requests to return file information.</li> <li>It supports Range requests, enabling pause-and-resume downloads and optimal   handling of videos (e.g., downloading videos from a specific point in time).</li> </ul> <p>Add a file to the static folder and access it by entering its path in your browser.</p> <p>Relative paths are supported, but only files within the root static folder are served. It is not possible to download files outside of the static folder, as this would pose a security risk. Additionally, BlackSheep only handles certain file extensions by default, specifically the most common ones used in web applications. Paths starting with '/' are always treated as absolute paths starting from the root of the website.</p>"},{"location":"mvc-project-template/#strategy-for-application-settings","title":"Strategy for application settings","text":"<p>The <code>API</code> and the <code>MVC</code> project templates include a strategy to read and validate application settings from various sources and support multiple system environments (like <code>dev</code>, <code>test</code>, and <code>prod</code> environments).</p> <ul> <li><code>Pydantic</code> is always used to describe and validate application settings.</li> <li>Application settings can be read from various sources using either   <code>Pydantic v1 BaseSettings</code> class, or <code>essentials-configuration</code>.</li> <li>When using <code>essentials-configuration</code>, use the <code>APP_ENV</code> environment variable   to control the application environment and to use environment-specific   settings from dedicated files using the pattern:   <code>settings.{{env_name}}.{{format}}</code>, like <code>settings.test.yaml</code>,   <code>settings.prod.toml</code>.</li> </ul> <p>For more information on application settings and the recommended way to apply configuration depending on the application environment, refer to Settings.</p>"},{"location":"mvc-project-template/#summary","title":"Summary","text":"<p>This tutorial covered some higher-level topics of a BlackSheep application. The general concepts presented here apply to many kinds of web frameworks:</p> <ul> <li>server side templating of HTML views</li> <li>serving of static files</li> <li>use of MVC architecture</li> </ul> <p>The next pages describe the built-in support for dependency injection, and automatic generation of OpenAPI Documentation.</p> <p>For more information...</p> <p>For more information about Server Side Rendering, read Templating.</p> <p>For more information about the BlackSheep CLI, read More about the CLI.</p> <p>Don't miss the api project template.</p> <p>Try also the <code>api</code> project template, to start new Web API projects that don't handle HTML views.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWT"},{"location":"openapi/","title":"OpenAPI Documentation","text":"<p>BlackSheep implements automatic generation of OpenAPI Documentation for most common REST API scenarios, and provides methods to fully control the OpenAPI Specification file. This page describes the following:</p> <ul> <li> An introduction to OpenAPI Documentation.</li> <li> Built-in support for OpenAPI Documentation.</li> <li> How to document endpoints.</li> <li> How to handle common responses.</li> <li> Expose the documentation for anonymous access.</li> <li> Options to display OpenAPI Documentation.</li> <li> How to implement a custom <code>UIProvider</code>.</li> </ul>"},{"location":"openapi/#introduction-to-openapi-documentation","title":"Introduction to OpenAPI Documentation","text":"<p>Citing from the Swagger website, at the time of this writing:</p> <p>The OpenAPI Specification (OAS) defines a standard {...} interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service {...}.</p> <p>An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p> <p>Since a web application inherently knows the paths it handles and a certain amount of metadata can be inferred from the source code, BlackSheep provides automatic generation of OpenAPI documentation. It also offers an API to enhance the documentation with additional information that cannot be inferred from the source code.</p> <p>If you followed the Getting started: MVC tutorial, the project template is preconfigured to include an example of OpenAPI documentation and to expose a Swagger UI at the <code>/docs</code> path.</p> <p></p>"},{"location":"openapi/#built-in-support-for-openapi-documentation","title":"Built-in support for OpenAPI Documentation","text":"<p>The following piece of code describes a minimal set-up to enable generation of OpenAPI Documentation and exposing a Swagger UI in BlackSheep:</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import Application, get\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\napp = Application()\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@dataclass\nclass Foo:\n    foo: str\n\n\n@get(\"/foo\")\nasync def get_foo() -&gt; Foo:\n    return Foo(\"Hello!\")\n</code></pre> <p>If you start this application and navigate to its <code>/docs</code> route, you will see a Swagger UI like this:</p> <p></p> <p>In this example, BlackSheep generates the following specification and offers it in both JSON and YAML format:</p> /openapi.yaml/openapi.json <pre><code>openapi: 3.1.0\ninfo:\n    title: Example API\n    version: 0.0.1\npaths:\n    /foo:\n        get:\n            responses:\n                '200':\n                    description: Success response\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/Foo'\n            operationId: get_foo\nservers: []\ncomponents:\n    schemas:\n        Foo:\n            type: object\n            required:\n            - foo\n            properties:\n                foo:\n                    type: string\n                    nullable: false\ntags: []\n</code></pre> <pre><code>{\n    \"openapi\": \"3.1.0\",\n    \"info\": {\n        \"title\": \"Example API\",\n        \"version\": \"0.0.1\"\n    },\n    \"paths\": {\n        \"/foo\": {\n            \"get\": {\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Success response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/Foo\"\n                                }\n                            }\n                        }\n                    }\n                },\n                \"operationId\": \"get_foo\"\n            }\n        }\n    },\n    \"servers\": [],\n    \"components\": {\n        \"schemas\": {\n            \"Foo\": {\n                \"type\": \"object\",\n                \"required\": [\n                    \"foo\"\n                ],\n                \"properties\": {\n                    \"foo\": {\n                        \"type\": \"string\",\n                        \"nullable\": false\n                    }\n                }\n            }\n        }\n    },\n    \"tags\": []\n}\n</code></pre>"},{"location":"openapi/#supported-types","title":"Supported types","text":"<p>The framework provides built-in support for the following types:</p> <ul> <li>Built-in <code>dataclasses</code>.</li> <li>Pydantic v2 <code>BaseModel</code>.</li> <li>Pydantic v2 <code>dataclasses</code> (since version <code>2.2.0</code>).</li> <li>Pydantic v1 <code>BaseModel</code>.</li> </ul> <p>Pydantic is fully supported since version 2.2.0.</p> <p>Support for Pydantic has been improved in <code>2.2.0</code>, now the framework uses the OpenAPI Specification generated by Pydantic when handling <code>BaseModel</code> and Pydantic <code>dataclasses</code>. It is recommended to upgrade to version <code>2.2.0</code>.</p> <p>To support more types, define types implementing the <code>ObjectTypeHandler</code> interface and add it to the list of object_types_handlers:</p> <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler, ObjectTypeHandler\n\n\nclass CustomTypeHandler(ObjectTypeHandler):\n    # TODO: implement the interface\n\n\ndocs.object_types_handlers.append(CustomTypeHandler())\n</code></pre> <p>To provide more details for api routes, decorate request handlers using the instance of <code>OpenAPIHandler</code> as a decorator:</p> <pre><code>@docs(responses={200: \"Returns a text saying OpenAPI Example\"})\n@get(\"/\")\ndef home():\n    return \"OpenAPI Example\"\n</code></pre> <p>After this change, the specification file includes the new information:</p> <pre><code>openapi: 3.1.0\ninfo:\n    title: Example API\n    version: 0.0.1\npaths:\n    /foo:\n        get:\n            responses:\n                '200':\n                    description: Returns a text saying OpenAPI Example\n            operationId: get_foo\nservers: []\ncomponents: {}\ntags: []\n</code></pre>"},{"location":"openapi/#adding-description-and-summary","title":"Adding description and summary","text":"<p>An endpoint description can be specified either using a <code>docstring</code>:</p> <pre><code>@docs(responses={200: \"Returns a text saying OpenAPI Example\"})\n@get(\"/\")\nasync def home():\n    \"\"\"\n    This example is used to demonstrate support for OpenAPI in BlackSheep.\n    The endpoint itself doesn't do anything useful.\n    \"\"\"\n    return \"OpenAPI Example\"\n</code></pre> <p>Or in the <code>@docs</code> decorator:</p> <pre><code>@docs(\n    summary=\"This example is used to demonstrate support for OpenAPI in BlackSheep.\",\n    description=\"The endpoint itself doesn't do anything useful.\",\n    responses={200: \"Returns a text saying OpenAPI Example\"},\n)\n@get(\"/\")\nasync def home():\n    return \"OpenAPI Example\"\n</code></pre> <p>When using <code>docstring</code>, the first line of the docstring is used as the summary, and the whole docstring as the description.</p> <p></p> <p>Most of the BlackSheep code base is typed using the <code>typing</code> module, thus IDEs and text editors like Visual Studio Code and PyCharm can provide user's friendly hints for code completion (see the screenshot below). </p>"},{"location":"openapi/#ignoring-endpoints","title":"Ignoring endpoints","text":"<p>To exclude certain endpoints from the API documentation, use <code>@docs.ignore()</code>:</p> <pre><code>@docs.ignore()\n@get(\"/hidden-from-docs\")\nasync def hidden_endpoint():\n    return \"This endpoint won't appear in documentation\"\n</code></pre>"},{"location":"openapi/#documenting-only-certain-routes","title":"Documenting only certain routes","text":"<p>To document only certain routes, use an include function like in the example below. For example, to include only those routes that contain \"/api\":</p> <pre><code># include only endpoints whose path contains \"/api/\"\ndocs.include = lambda path, _: \"/api/\" in path\n</code></pre>"},{"location":"openapi/#documenting-response-examples","title":"Documenting response examples","text":"<p>The following example shows how to describe examples for responses:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom blacksheep import Application, get, json\nfrom blacksheep.server.openapi.common import ContentInfo, ResponseExample, ResponseInfo\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\napp = Application()\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@dataclass\nclass Cat:\n    id: UUID\n\n    name: str\n    creation_time: datetime\n\n\n@docs(\n    summary=\"Gets a cat by id\",\n    description=\"\"\"A sample API that uses a pet store as an\n          example to demonstrate features in the OpenAPI 3 specification\"\"\",\n    responses={\n        200: ResponseInfo(\n            \"A cat\",\n            content=[\n                ContentInfo(\n                    Cat,\n                    examples=[\n                        ResponseExample(\n                            Cat(\n                                id=UUID(\"3fa85f64-5717-4562-b3fc-2c963f66afa6\"),\n                                name=\"Foo\",\n                                creation_time=datetime.now(),\n                            )\n                        )\n                    ],\n                )\n            ],\n        ),\n        404: \"Cat not found\",\n    },\n)\n@get(\"/api/cats/{cat_id}\")\ndef get_cat_by_id(cat_id: UUID):\n    ...\n</code></pre> <p>If the code seems excessively verbose, consider that OpenAPI specification is designed to support documenting responses with different content types (e.g. JSON, XML, etc.) and having examples for each content type. Writing the documentation by hand would be much more time consuming!</p> <p>BlackSheep automatically generates component schemas by type (in this example, <code>Cat</code>) and reuses them in all API endpoints that use them:</p> <p></p> Reusable components schemas. <pre><code>openapi: 3.1.0\ninfo:\n    title: Example API\n    version: 0.0.1\npaths:\n    /api/cats/{cat_id}:\n        get:\n            responses:\n                '200':\n                    description: A cat\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/Cat'\n                '404':\n                    description: Cat not found\n            summary: Gets a cat by id\n            description: \"A sample API that uses a pet store as an\\n          example\\\n                \\ to demonstrate features in the OpenAPI 3 specification\"\n            operationId: get_cat_by_id\n            parameters:\n            -   name: cat_id\n                in: path\n                schema:\n                    type: string\n                    format: uuid\n                    nullable: false\n                description: ''\n                required: true\nservers: []\ncomponents:\n    schemas:\n        Cat:\n            type: object\n            required:\n            - id\n            - name\n            - creation_time\n            properties:\n                id:\n                    type: string\n                    format: uuid\n                    nullable: false\n                name:\n                    type: string\n                    nullable: false\n                creation_time:\n                    type: string\n                    format: date-time\n                    nullable: false\ntags: []\n</code></pre>"},{"location":"openapi/#avoid-code-pollution-using-endpointdocs","title":"Avoid code pollution using EndpointDocs","text":"<p>If you are familiar with other libraries that produce OpenAPI Documentation and you consider the example above, you might notice that adding OpenAPI details to request handlers can pollute the source code and distract the programmer from the actual request handlers' logic.</p> <p>BlackSheep provides a way to avoid polluting the source code and keep the code for OpenAPI in dedicated files. Use the <code>blacksheep.server.openapi.common.EndpointDocs</code> class to define documentation in dedicated files and keep your request handlers code clean:</p> <pre><code>from apidocs.cats import get_cat_docs\n\n@docs(get_cat_docs)\n@get(\"/api/cats/{cat_id}\")\ndef get_cat_by_id(cat_id: UUID):\n    ...\n</code></pre> <p>To see a complete example, refer to the source code of the MVC project template, and see how documentation is organized and configured (in <code>app.docs</code>, <code>app.controllers.docs</code>).</p>"},{"location":"openapi/#deprecating-an-api","title":"Deprecating an API","text":"<p>To mark an endpoint as deprecated, use <code>@docs.deprecated()</code>:</p> <pre><code>@docs.deprecated()\n@get(\"/some-deprecated-api\")\nasync def deprecated_endpoint():\n    return \"This endpoint is deprecated\"\n</code></pre>"},{"location":"openapi/#altering-the-specification-upon-creation","title":"Altering the specification upon creation","text":"<p>To alter the specification file upon creation, define a subclass of <code>OpenAPIHandler</code> that overrides <code>on_docs_generated</code> method.</p> <pre><code>from blacksheep import Application, json\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info, OpenAPI, Server\n\napp = Application()\n\n\nclass MyOpenAPIHandler(OpenAPIHandler):\n    def on_docs_generated(self, docs: OpenAPI) -&gt; None:\n        docs.servers = [\n            Server(url=\"https://foo-example.org\"),\n            Server(url=\"https://test.foo-example.org\"),\n        ]\n\n\ndocs = MyOpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n</code></pre> <p>To fully control the specification upon its creation as Python <code>dict</code>, either override the <code>build_docs</code> method of your custom-defined <code>OpenAPIHandler</code>, or specify a custom <code>Serializer</code> like in the example below (this second option is only available since version <code>2.2.0</code>).</p> <pre><code>from openapidocs.common import Serializer\n\n\nclass CustomSerializer(Serializer):\n    def to_obj(self, item: Any) -&gt; Any:\n        obj = super().to_obj(item)\n        # Fully control for the specification dictionary here\n        return obj\n\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Example API\", version=\"0.0.1\"), serializer=CustomSerializer()\n)\n</code></pre>"},{"location":"openapi/#handling-common-responses","title":"Handling common responses","text":"<p>APIs often implement a common way to handle failures, to provide clients with details for web requests that cannot be completed successfully. For example, an API might return a response body like the following, in case of a bad request for a certain endpoint:</p> <pre><code>{\n    \"error\": \"The provided country code is not supported\",\n    \"code\": \"InvalidCountryCode\"\n}\n</code></pre> <p>Such response body can be handled using a <code>dataclass</code> or Pydantic model:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass ErrorInfo:\n    error: str\n    code: int\n</code></pre> <p>Common responses can be documented this way:</p> <pre><code>from openapidocs.v3 import MediaType, Response as ResponseDoc, Schema\n\n\nerror_info = docs.register_schema_for_type(ErrorInfo)\n\ndocs.common_responses = {\n    400: ResponseDoc(\n        \"Bad request\",\n        content={\n            \"application/json\": MediaType(\n                schema=Schema(\n                    any_of=[error_info],\n                    example=ErrorInfo(error=\"Invalid argument\", code=1001),\n                )\n            )\n        },\n    ),\n    401: ResponseDoc(\n        \"Unauthorized\",\n        content={\n            \"application/json\": MediaType(\n                schema=Schema(\n                    any_of=[error_info],\n                    example=ErrorInfo(error=\"The user is not authorized\", code=3),\n                )\n            )\n        },\n    ),\n}\n</code></pre>"},{"location":"openapi/#support-for-generics","title":"Support for generics","text":"<p>The generation of OpenAPI Documentation supports generic types. Consider the following example:</p> <ol> <li>A common use case is implementing an API that returns a paginated subset of    elements, often based on filters (e.g., textual search).</li> <li>Clients need to know the total count of items matching the filters to    display the total number of items and calculate the number of pages required    to show all results (depending on the page size).</li> <li>In such scenarios, using a <code>Generic</code> type is an effective solution, as many    kinds of objects can be paginated.</li> </ol> <p>Example of generic class definition</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Generic, TypeVar\n\n\nT = TypeVar(\"T\")\n\n\n@dataclass\nclass PaginatedSet(Generic[T]):\n    items: List[T]\n    total: int\n</code></pre> <p>Full example illustrating OpenAPI Documentation for generics:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Generic, List, TypeVar\nfrom uuid import UUID\n\nfrom openapidocs.v3 import Info\n\nfrom blacksheep import Application, FromQuery\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\n\nT = TypeVar(\"T\")\n\n\n@dataclass\nclass PaginatedSet(Generic[T]):\n    items: List[T]\n    total: int\n\n\n@dataclass\nclass Order:\n    id: UUID\n    customer_id: UUID\n    creation_time: datetime\n\n\napp = Application()\n\n\n# enable OpenAPI Documentation\ndocs.bind_app(app)\n\n\n\n@router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n    \"\"\"\n    Returns a paginated set of orders.\n    \"\"\"\n</code></pre> <p>In the example below, the generic type is handled properly and produces the following OpenAPI Documentation:</p> <pre><code>openapi: 3.1.0\n    title: Example\n\nversion: 0.0.1\npaths:\n    /api/orders:\n        get:\n            responses:\n                '200':\n                    description: Success response\n                    content:\n                        application/json:\n                            schema:\n                                $ref: '#/components/schemas/PaginatedSetOfOrder'\n            operationId: get_orders\n            summary: Returns a paginated set of orders.\n            description: Returns a paginated set of orders.\n            parameters:\n            -   name: page\n                in: query\n                schema:\n                    type: integer\n                    format: int64\n                    nullable: false\n                description: ''\n            -   name: page_size\n                in: query\n                schema:\n                    type: integer\n                    format: int64\n                    nullable: false\n                description: ''\n            -   name: search\n                in: query\n                schema:\n                    type: string\n                    nullable: false\n                description: ''\nservers: []\ncomponents:\n    schemas:\n        Order:\n            type: object\n            required:\n            - id\n            - customer_id\n            - creation_time\n            properties:\n                id:\n                    type: string\n                    format: uuid\n                    nullable: false\n                customer_id:\n                    type: string\n                    format: uuid\n                    nullable: false\n                creation_time:\n                    type: string\n                    format: date-time\n                    nullable: false\n        PaginatedSetOfOrder:\n            type: object\n            required:\n            - items\n            - total\n            properties:\n                items:\n                    type: array\n                    nullable: false\n                    items:\n                        $ref: '#/components/schemas/Order'\n                total:\n                    type: integer\n                    format: int64\n                    nullable: false\n</code></pre> Generic types names. <p>Generic types, expressed in Python using <code>GenericType[T]</code>, are represented with <code>GenericTypeOfT</code> to respect OpenAPI specification, saying that <code>$ref values must be RFC3986-compliant percent-encoded URIs</code>. A generic type with more arguments, like <code>Foo[T, U, X]</code> gets represented with <code>FooOfTAndUAndX</code>.</p>"},{"location":"openapi/#describing-parameters","title":"Describing parameters","text":"<p>It is possible to describe parameters explicitly using docstrings.</p>"},{"location":"openapi/#documenting-parameters-explicitly","title":"Documenting parameters explicitly","text":"<p>To document parameters explicitly, use the <code>@docs</code> like in the following example (elaborating on the previous example about generics):</p> <pre><code>@router.get(\"/api/orders\")\n@docs(\n    parameters={\n        \"page\": ParameterInfo(description=\"Page number\"),\n        \"page_size\": ParameterInfo(\n            description=\"The number of items to display per page\"\n        ),\n        \"search\": ParameterInfo(description=\"Optional text search\"),\n    },\n)\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n    \"\"\"\n    Returns a paginated set of orders.\n    \"\"\"\n</code></pre>"},{"location":"openapi/#documenting-parameters-using-docstrings","title":"Documenting parameters using docstrings","text":"<p>BlackSheep supports documenting parameters using docstrings, and the following styles are supported: Epytext, ReStructuredText, NumpyDoc. The following sections show the previous example re-written to use docstrings.</p> EpytextReStructuredTextNumpyDoc <pre><code>@router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n    \"\"\"\n    Returns a paginated set of orders.\n\n    @param page: Page number\n    @param page_size: The number of items to display per page\n    @param search: Optional text search\n    \"\"\"\n</code></pre> <pre><code>@router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n    \"\"\"\n    Returns a paginated set of orders.\n\n    :param page: Page number\n    :param page_size: The number of items to display per page\n    :param search: Optional text search\n    \"\"\"\n</code></pre> <pre><code>@router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n    \"\"\"\n    Returns a paginated set of orders.\n\n    Parameters\n    ----------\n    page : Page number\n    page_size : The number of items to display per page\n    search : Optional text search\n    \"\"\"\n</code></pre> <p>The logic that parses docstrings can also extract types information, but this is not documented because the recommended way is to use type annotations. Refer to the file <code>test_openapi_docstrings.py</code> for more examples on the information that can be extracted from docstrings.</p>"},{"location":"openapi/#anonymous-access","title":"Anonymous access","text":"<p>If the server uses a default authorization policy that requires an authenticated user, it is still possible to make the OpenAPI Documentation endpoint available for anonymous access, using the <code>anonymous_access</code> parameter:</p> <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Example API\", version=\"0.0.1\"), anonymous_access=True\n)\n</code></pre>"},{"location":"openapi/#support-for-redoc-ui-and-scalar-ui","title":"Support for ReDoc UI and Scalar UI","text":"<p>BlackSheep includes built-in support for three systems to display OpenAPI documentation:</p> <ul> <li>Swagger UI (default)</li> <li>ReDoc UI</li> <li>Scalar UI (since version <code>2.2.0</code>)</li> </ul> <p>To enable different ways to display OpenAPI Documentation, use the <code>OpenAPIHandler.ui_providers</code> property.</p> ReDoc UIScalar UI <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom blacksheep.server.openapi.ui import ReDocUIProvider\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\n\ndocs.ui_providers.append(ReDocUIProvider())\n</code></pre> <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom blacksheep.server.openapi.ui import ScalarUIProvider\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\n\ndocs.ui_providers.append(ScalarUIProvider())\n</code></pre>"},{"location":"openapi/#how-to-implement-a-custom-uiprovider","title":"How to implement a custom UIProvider","text":"<p>The BlackSheep package includes some static files to offer a good user experience in some circumstances. These include HTML pages used when enabling Swagger UI or ReDoc UI.</p> <p>To control those pages, for example, to alter the HTML structure or use different sources for JavaScript and CSS files (which by the way could be the BlackSheep application serving the OpenAPI specification files), it is recommended to:</p> <ul> <li>define a custom implementation of <code>UIProvider</code></li> <li>maintain the desired HTML file</li> </ul> <p>Example:</p> <pre><code>from dataclasses import dataclass\nfrom pathlib import Path\n\nfrom blacksheep import Application\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom blacksheep.server.openapi.ui import SwaggerUIProvider, UIOptions\nfrom openapidocs.v3 import Info\n\napp = Application()\n\n\nclass CustomUIProvider(SwaggerUIProvider):\n    def get_openapi_ui_html(self, options: UIOptions) -&gt; str:\n        _template = Path(\"example.html\").read_text()\n        return _template.replace(\"{options.spec_url}\", options.spec_url)\n\n\n# Set the UI provider as desired:\n\ndocs.ui_providers = [CustomUIProvider()]\ndocs.bind_app(app)\n\n\n@dataclass\n\nclass Foo:\n    foo: str\n\n\n@route(\"/foo\")\nasync def get_foo() -&gt; Foo:\n    return Foo(\"Hello!\")\n</code></pre> <p>example.html:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;My desired title&lt;/title&gt;\n    &lt;link rel=\"icon\" href=\"/favicon.png\"/&gt;\n    &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.10.0/swagger-ui.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"swagger-ui\"&gt;&lt;/div&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.10.0/swagger-ui-bundle.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n    const ui = SwaggerUIBundle({\n        url: '{options.spec_url}',\n        oauth2RedirectUrl: window.location.origin + '/docs/oauth2-redirect',\n        dom_id: '#swagger-ui',\n        presets: [\n            SwaggerUIBundle.presets.apis,\n            SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true,\n        showExtensions: true,\n        showCommonExtensions: true\n    })\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"openapi/#changing-operations-ids","title":"Changing operations ids","text":"<p>When OpenAPI Documentation is generated, operation ids are obtained from the name of the Python function definitions.</p> <p>For example, having a <code>get_foo</code> request handler generates an object having <code>operationId</code> equal to \"get_foo\":</p> <pre><code>@router.get(\"/foo\")\nasync def get_foo() -&gt; Foo:\n    return Foo(\"Hello!\")\n</code></pre> <pre><code>    \"paths\": {\n        \"/foo\": {\n            \"get\": {\n                \u2026,\n                \"operationId\": \"get_foo\"\n            }\n        }\n    },\n</code></pre> <p>To change how <code>operationId</code> is generated for endpoints, define a custom type of <code>OpenAPIHandler</code> that overrides the <code>get_operation_id</code> method, to produce the desired result:</p> <pre><code>class CustomOpenAPIHandler(OpenAPIHandler):\n    def get_operation_id(self, docs: Optional[EndpointDocs], handler) -&gt; str:\n        return handler.__name__.capitalize().replace(\"_\", \" \")\n</code></pre>"},{"location":"openapi/#for-more-details","title":"For more details","text":"<p>For more details on the OpenAPI specification and to understand some details such as security settings, refer to the official swagger.io website, and the dedicated library to generate the specification file: essentials-openapi.</p> <p>Last modified on: 2025-04-29 07:50:00</p>RPEWRVT"},{"location":"openid-connect/","title":"OpenID Connect","text":"<p>BlackSheep provides built-in support for OpenID Connect authentication, meaning that it can be easily integrated with identity provider services such as:</p> <ul> <li>Auth0</li> <li>Entra ID</li> <li>Azure Active Directory B2C</li> <li>Okta</li> </ul> <p>This page covers:</p> <ul> <li> Using OpenID Connect integration to provide sign-in and sign-up features.   and to identify users who use the application</li> <li> Using OpenID Connect integration to obtain <code>access_token</code>s to use APIs   (in addition, or instead of <code>id_token</code>s).</li> <li> How tokens are protected and how to configure applications to support   multiple instances and regions.</li> </ul> <p>Additional dependencies.</p> <p>Using JWT Bearer and OpenID integrations requires additional dependencies. Install them by running: <code>pip install blacksheep[full]</code>.</p>"},{"location":"openid-connect/#basic-example","title":"Basic example","text":"<p>A basic example with any of the identity providers listed above, having implicit flow enabled for <code>id_token</code>, looks like the following:</p> <pre><code>from blacksheep import Application, html, pretty_json\nfrom blacksheep.server.authentication.oidc import OpenIDSettings, use_openid_connect\nfrom guardpost.authentication import Identity\n\napp = Application()\n\n\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"&lt;YOUR_AUTHORITY&gt;\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        callback_path=\"&lt;CALLBACK_PATH&gt;\",\n    ),\n)\n\n\n@get(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        response = pretty_json(user.claims)\n\n        return response\n\n    return html(\"&lt;a href='/sign-in'&gt;Sign in&lt;/a&gt;&lt;br/&gt;\")\n</code></pre> <p>When the application is configured with <code>use_openid_connect</code>, request handlers are automatically configured to handle users' sign-in, the redirect after a user signs-in, and signs-out. After a user signs-in successfully, a signed and encrypted cookie containing the claims of the <code>id_token</code> is set automatically for the client, having an expiration time matching the expiration time of the <code>id_token</code> itself. User's identity is automatically restored at each web request by an authentication middleware, and can be read as in the provided examples:</p> <pre><code>@get(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        ...\n</code></pre>"},{"location":"openid-connect/#use_openid_connect","title":"use_openid_connect","text":"Parameter Type, default Description app Application Instance of BlackSheep application. settings OpenIDSettings Instance of OpenIDSettings. auth_handler Optional[OpenIDTokensHandler] = None (CookiesOpenIDTokensHandler) Instance of OpenIDTokensHandler that can handle tokens for requests and responses for the OpenID Connect flow. This class is responsible for communicating tokens to clients, and restoring tokens context for following requests. parameters_builder Optional[ParametersBuilder] = None Optional instance of <code>ParametersBuilder</code>, used to handle parameters configured in redirects and requests to the authorization server. is_default bool = True If default, clients are automatically redirected to the <code>sign-in</code> page when a non-authenticated user tries to access in <code>GET</code> a web page that requires authentication."},{"location":"openid-connect/#openidsettings","title":"OpenIDSettings","text":"<p>The <code>OpenIDSettings</code> class has the following properties:</p> Parameter Type, default Description client_id str ID of the application in the identity server. authority Optional[str] = None If specified, URL of the authorization server. audience Optional[str] = None If specified, the <code>audience</code> for requests using scopes to an API (ref.). client_secret Optional[str] = None For requests that use <code>Authorization Code Grant</code> flow, the secret of the client application in the identity server. discovery_endpoint Optional[str] = None If specified, the exact URL to the discovery point (useful with Okta when using custom scopes for an authorization server). entry_path str = \"/sign-in\" The local entry path for sign-in (this redirects to the sign-in page of the identity server). logout_path str = \"/sign-out\" The local path to the sign-out endpoint (this removes authentication cookie). post_logout_redirect_path str = \"/\" The local path to which a user is redirected after signing-out. callback_path str = \"/authorization-callback\" The local path to handle the redirect after a user signs-in (the reply_url in the identity server must be configured accordingly). refresh_token_path str = \"/refresh-token\" The local path used to handle refresh tokens to obtain new tokens. scope str = \"openid profile email\" The scope of the request, by default an <code>id_token</code> is obtained with email and profile. response_type str = \"code\" Type of OAuth response. redirect_uri Optional[str] = None If specified, the redirect URL that must match the one configured for the application. If not provided, a redirect_url is obtained automatically (see note \ud83d\udde1\ufe0f). scheme_name str = \"OpenIDConnect\" The name of the authentication scheme, affecting the name of authentication cookies (see note \ud83c\udf52). error_redirect_path Optional[str] = None If specified, the local path to which a user is redirected in case of error. end_session_endpoint Optional[str] = None If specified, the local path to which the user can log out. <p>Notes:</p> <ul> <li>\ud83d\udde1\ufe0f obtaining a redirect_url automatically can require handling of forward   headers, when an application is deployed behind a proxy. See   remotes for more information.</li> <li>\ud83c\udf52 this should be changed when configuring more than one OIDC identity   provider.</li> </ul> <p>Info</p> <p><code>access_token</code>s issued for APIs can be validated using JWT Bearer authentication</p>"},{"location":"openid-connect/#examples-using-custom-scopes","title":"Examples using custom scopes","text":"<p>An integration with an <code>Auth0</code> application that uses custom scopes, where the application obtains both an <code>id_token</code> and an <code>access_token</code> for an API, looks like the following:</p> <pre><code>\"\"\"\nThis example shows how to configure an OpenID Connect integration with Auth0,\nobtaining an id_token, an access_token, and a refresh_token. The id_token is\nexchanged with the client using a response cookie (also used to authenticate\nusers for following requests), while the access token and the refresh token are\nnot stored and can only be accessed using optional events.\n\"\"\"\nimport uvicorn\nfrom blacksheep.server.application import Application\nfrom blacksheep.server.authentication.oidc import OpenIDSettings, use_openid_connect\nfrom dotenv import load_dotenv\n\nfrom common.routes import register_routes\nfrom common.secrets import Secrets\n\nload_dotenv()\nsecrets = Secrets.from_env()\napp = Application()\n\n\n# Auth0 with a custom scope\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"https://neoteroi.eu.auth0.com\",\n        audience=\"http://localhost:5000/api/todos\",\n        client_id=\"OOGPl4dgG7qKsm2IOWq72QhXV4wsLhbQ\",\n        client_secret=secrets.auth0_client_secret,\n        callback_path=\"/signin-oidc\",\n        scope=\"openid profile read:todos\",\n        error_redirect_path=\"/sign-in-error\",\n    ),\n)\n\nregister_routes(app)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=5000, log_level=\"debug\")\n</code></pre> <p>An integration with <code>Entra ID</code>:</p> <pre><code>handler = use_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"https://login.microsoftonline.com/b62b317a-19c2-40c0-8650-2d9672324ac4/v2.0/\",\n        client_id=\"499adb65-5e26-459e-bc35-b3e1b5f71a9d\",\n        client_secret=secrets.aad_client_secret,\n        scope=\"openid profile offline_access email \"\n        \"api://65d21481-4f1a-4731-9508-ad965cb4d59f/example\",\n    ),\n)\n</code></pre> <p>An integration with <code>Okta</code>, using the <code>default</code> authorization server:</p> <pre><code>use_openid_connect(\n    app,\n    OpenIDSettings(\n        discovery_endpoint=\"https://dev-34685660.okta.com/oauth2/default/.well-known/oauth-authorization-server\",\n        client_id=\"0oa2gy88qiVyuOClI5d7\",\n        client_secret=secrets.okta_client_secret,\n        callback_path=\"/authorization-code/callback\",\n        scope=\"openid read:todos\",\n    ),\n)\n</code></pre>"},{"location":"openid-connect/#events","title":"Events","text":"<p>The API exposes the following events:</p> <pre><code>from blacksheep.server.authentication.oidc import (\n    OpenIDSettings,\n    TokenResponse,\n    use_openid_connect\n)\n\n\noidc = use_openid_connect(...)\n\n\n@oidc.events.on_id_token_validated\nasync def id_token_callback(context, id_token_claims):\n    \"\"\"\n    This callback is called after an id_token is received, successfully\n    verified using public RSA keys from the identity provider, and parsed\n\n    Using this event handler is possible to modify the claims obtained from the\n    id_token before they are set in the authentication cookie. For example to\n    remove certain claims, or add other information.\n    \"\"\"\n\n\n@oidc.events.on_tokens_received\nasync def on_tokens_received(context, token_response: TokenResponse):\n    \"\"\"\n    This callback is called after a successful web request to the token\n    endpoint to exchange a code with an access_token, and eventually\n    refresh_token, and id_token.\n    \"\"\"\n\n\n@oidc.events.on_error\nasync def on_error(context, data: Dict[str, Any]):\n    \"\"\"\n    This callback is called when an error is returned by the authorization\n    server in the redirect handler.\n    Note that this can happen for a common scenario, like the user refusing\n    to grant consent on the application.\n    \"\"\"\n</code></pre>"},{"location":"openid-connect/#storing-tokens","title":"Storing tokens","text":"<p>By default, <code>access_token</code>(s) and <code>refresh_token</code>(s) are not stored. To store them, the <code>auth_handler.tokens_store</code> property. The examples repository includes an example that shows how to use <code>Redis</code> to store tokens: Redis example</p> <p>A concrete implementation is provided in <code>CookiesTokenStore</code>, storing tokens in cookies. It is possible to create custom implementations of the <code>TokensStore</code>, to use other mechanisms, for example, to store tokens in a Redis cache.</p> <p>When a user is authenticated, and has an <code>access_token</code> (and/or a <code>refresh_token</code>), they are accessible through the <code>Identity</code>:</p> <pre><code>@get(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        print(user.access_token)\n        print(user.refresh_token)\n        ...\n</code></pre> <p>To see how to use a <code>TokensStore</code>, refer to the examples above that use the built-in <code>CookiesTokensStore</code>.</p>"},{"location":"openid-connect/#useful-references","title":"Useful references","text":"<ul> <li>https://auth0.com/docs/security/tokens/access-tokens</li> <li>https://www.oauth.com/oauth2-servers/server-side-apps/possible-errors/</li> <li>https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow</li> <li>https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc</li> <li>https://connect2id.com/learn/openid-connect</li> </ul>"},{"location":"openid-connect/#how-tokens-are-protected","title":"How tokens are protected","text":"<p>Tokens that are stored in cookies are signed and encrypted using <code>itsdangerous</code>, with symmetric encryption. This means that BlackSheep applications need secrets to protect sensitive data. When keys are not specified, they are generated automatically in memory, for the best user experience.</p> <p>Danger</p> <p>This means that keys are not persisted when applications restart, and are not consistent when multiple instances of the same application are deployed across regions, or within the same server. This is acceptable during local development, but should not be the case in production environments.</p> <p>To use consistent keys, configure one or more environment variables like the following:</p> <ul> <li>APPSECRET_1=\"***\"</li> <li>APPSECRET_2=\"***\"</li> <li>APPSECRET_3=\"***\"</li> </ul> <p>Keys can be configured in a host environment, or fetched from a dedicated service such as <code>AWS Secrets Manager</code> or <code>Azure Key Vault</code> at application start-up, and configured as environment settings for the application. DO NOT store secrets that are meant to be used in production under source control.</p> <p>For more information, refer to data protection.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"remotes/","title":"Remotes","text":"<p>The <code>blacksheep.server.remotes</code> namespace provides classes and functions to handle information related to remote proxies and clients.</p> <p>Web applications in production environments are often hosted behind servers such as Apache, IIS, or NGINX. Proxy servers typically obscure some information from the original web request before it reaches the web application.</p> <p>For example:</p> <ul> <li>When HTTPS requests are proxied over HTTP, the original scheme (HTTPS) is   lost and must be forwarded in a header.</li> <li>When an application receives a request from a proxy instead of its true   source, the original client IP address must also be forwarded in a header.</li> <li>The path of web requests can be altered during proxying (e.g., NGINX   configured to proxy requests from <code>/example</code> to the root <code>/</code> of a web   application).</li> </ul> <p>This information is often critical for request processing, such as in redirects, authentication, link generation (when absolute URLs are required), and client geolocation. This page documents how to configure BlackSheep to work with proxy servers and load balancers, using the provided classes to handle:</p> <ul> <li> X-Forwarded headers.</li> <li> Forwarded header.</li> <li> Trusted hosts.</li> <li> How to read information about the original clients in web requests.</li> </ul> <p>For information on how to handle the prefix of routes when exposing a web application behind a proxy, refer to the dedicated page Behind Proxies.</p>"},{"location":"remotes/#handling-x-forwarded-headers","title":"Handling X-Forwarded headers","text":"<p><code>X-Forwarded</code> headers are the de-facto standard headers to propagate information about original web requests to web applications.</p> Header Description X-Forwarded-For Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. X-Forwarded-Host Used to identify the original host requested by the client in the Host HTTP request header X-Forwarded-Proto Used to identify the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. <p>BlackSheep provides an <code>XForwardedHeadersMiddleware</code> class to handle these headers, providing:</p> <ul> <li>Optional validation of trusted hosts.</li> <li>Optional validation of proxies count and IP addresses by known IPs or known   networks.</li> </ul> <p>To configure a BlackSheep web application to handle <code>X-Forwarded</code> headers and configure incoming web requests to expose the correct information about source protocol, client IP, and host:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.forwarding import XForwardedHeadersMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        XForwardedHeadersMiddleware(),\n    )\n</code></pre> <p>Options of the <code>XForwardedHeadersMiddleware</code> class:</p> Parameter Type, default Description allowed_hosts Optional[Sequence[str]] = None Sequence of allowed hosts. If configured, requests that send a different host in the <code>Host</code> header or <code>X-Forwarded-Host</code> header are replied with Bad Request. known_proxies Optional[Sequence[IPAddress]] = None Sequence of allowed proxies IP addresses. If configured, requests that send different proxies IPs in the request scope or <code>X-Forwarded-For</code> header are replied with Bad Request. known_networks Optional[Sequence[IPNetwork]] = None Sequence of allowed proxies networks. If configured, requests that send a foreign proxy IP in the request scope or <code>X-Forwarded-For</code> header are replied with Bad Request. forward_limit int = 1 Maximum number of allowed forwards, by default 1. <p>When <code>known_proxies</code> is not provided, it is set by default to handle <code>localhost</code>: <code>[ip_address(\"127.0.0.1\")]</code>.</p>"},{"location":"remotes/#handling-forwarded-header","title":"Handling Forwarded header","text":"<p>The <code>Forwarded</code> header is a standard header to propagate information about original web requests to web applications.</p> <p>To configure a BlackSheep web application to handle <code>Forwarded</code> headers:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.forwarding import ForwardedHeadersMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        ForwardedHeadersMiddleware(),\n    )\n</code></pre> <p>Options of the <code>ForwardedHeadersMiddleware</code> class:</p> Parameter Type, default Description allowed_hosts Optional[Sequence[str]] = None Sequence of allowed hosts. If configured, requests that send a different host in the <code>Host</code> header or <code>Forwarded</code> header are replied with Bad Request. known_proxies Optional[Sequence[IPAddress]] = None Sequence of allowed proxies IP addresses. If configured, requests that send different proxies IPs in the request scope or <code>Forwarded</code> header are replied with Bad Request. known_networks Optional[Sequence[IPNetwork]] = None Sequence of allowed proxies networks. If configured, requests that send a foreign proxy IP in the request scope or <code>Forwarded</code> header are replied with Bad Request. forward_limit int = 1 Maximum number of allowed forwards, by default 1. <p>When <code>known_proxies</code> is not provided, it is set by default to handle <code>localhost</code>: <code>[ip_address(\"127.0.0.1\")]</code>.</p>"},{"location":"remotes/#handling-trusted-hosts","title":"Handling trusted hosts","text":"<p>When forwarded headers middlewares are not used, but it is necessary to validate hosts, it is possible to use the <code>TrustedHostsMiddleware</code>:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.hosts import TrustedHostsMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        TrustedHostsMiddleware([\"www.neoteroi.dev\"]),\n    )\n</code></pre>"},{"location":"remotes/#reading-information-about-the-original-clients-in-web-requests","title":"Reading information about the original clients in web requests","text":"<p>Web requests expose information about the original clients in the following properties, that are updated by forwarded header middlewares:</p> <pre><code>from blacksheep import Request\n\nrequest: Request\n\nrequest.host\nrequest.scheme\nrequest.original_client_ip\n</code></pre> Property Description host Originating host. scheme Originating scheme (\"http\" or \"https\"). original_client_ip Originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer."},{"location":"remotes/#obtaining-the-web-request-absolute-url","title":"Obtaining the web request absolute URL","text":"<p>To obtain the original absolute URL of a web request, use the provided <code>get_absolute_url_to_path</code> and <code>get_request_absolute_url</code> functions:</p> <pre><code>from blacksheep.messages import get_absolute_url_to_path, get_request_absolute_url\n\n\n# examples\nabsolute_url = get_request_absolute_url(request)\n\nabsolute_url_to_path = get_absolute_url_to_path(request, \"/example\")\n</code></pre>"},{"location":"remotes/#asgi-root_path","title":"ASGI root_path","text":"<p>When the <code>ASGI</code> scope includes the <code>root_path</code> information, it is automatically used for the request <code>base_path</code> property. For more information on this subject, refer to the dedicated page Behind Proxies.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRVT"},{"location":"request-handlers/","title":"Request handlers","text":"<p>The previous pages explain that a request handler in BlackSheep is a function associated with a route, responsible for handling web requests. This page provides a detailed explanation of request handlers, covering the following topics:</p> <ul> <li> Request handler normalization.</li> <li> Using asynchronous and synchronous code.</li> </ul>"},{"location":"request-handlers/#request-handler-normalization","title":"Request handler normalization.","text":"<p>A standard request handler in BlackSheep is defined as an asynchronous function with the following signature:</p> <pre><code>from blacksheep import Request, Response\n\nasync def normal_handler(request: Request) -&gt; Response:\n    ...\n</code></pre> <p>For a function to act as a request handler, it must be associated with a route:</p> <pre><code>from blacksheep import Application, Request, Response, get, text\n\n\napp = Application()\n\n\n@get(\"/\")\nasync def normal_handler(request: Request) -&gt; Response:\n    return text(\"Example\")\n</code></pre> <p>A request handler defined this way is called directly to generate a response when a web request matches the route associated with the function (in this case, HTTP GET at the root of the website \"/\").</p> <p>To enhance the developer experience and improve development speed, BlackSheep implements automatic normalization of request handlers. For instance, a request handler can be defined as a synchronous function, and the framework will automatically wrap it in an asynchronous wrapper:</p> <pre><code>@get(\"/sync\")\ndef sync_handler(request: Request) -&gt; Response:\n    return text(\"Example\")\n</code></pre> <p>Avoid blocking code in synchronous methods!</p> <p>When a request handler is defined as a synchronous function, BlackSheep assumes that the developer understands asynchronous programming and intends for the response to be returned immediately without performing I/O or CPU-intensive operations that could block the event loop.</p> <p>Similarly, request handlers are normalized when their function signature is different than the normal one. For example, a request handler can be defined without arguments, and returning a plain <code>str</code> or an instance of an object (which gets serialized to <code>JSON</code> and configured as response content):</p> <pre><code>@get(\"/greetings\")\ndef hello_there() -&gt; str:\n    return \"Hello, There!\"\n</code></pre> <p>In the example below, the response content is JSON <code>{\"id\":1,\"name\":\"Celine\"}</code>:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Cat:\n    id: int\n    name: str\n\n\n@get(\"/example-cat\")\ndef get_example_cat() -&gt; Cat:\n    return Cat(1, \"Celine\")\n</code></pre>"},{"location":"request-handlers/#automatic-binding-of-parameters","title":"Automatic binding of parameters","text":"<p>An important feature enabled by function normalization is the automatic binding of request parameters, as described in the <code>Getting Started</code> pages. Common scenarios are using route parameters and query string parameters:</p> <pre><code># in this case, a route parameter is passed directly to the request handler\n@get(\"/greetings/{name}\")\ndef hello(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\n\n# in this case, query string parameters by name are read from the request and\n# passed to the request handler\n@get(\"/api/cats\")\ndef get_cats(page: int = 1, page_size: int = 30, search: str = \"\") -&gt; Response:\n    ...\n</code></pre> <p>In the <code>get_cats</code> example above, function parameters are automatically read from the query string and parsed if present; otherwise, default values are used.</p>"},{"location":"request-handlers/#explicit-and-implicit-binding","title":"Explicit and implicit binding","text":"<p>All examples so far showed how to use implicit binding of request parameters. In the <code>get_cats</code> example above, all parameters are implicitly bound from the request query string. To enable more scenarios, BlackSheep also provides explicit bindings that allow specifying the source of the parameter (e.g. request headers, cookies, route, query, body, application services). In the example below, <code>cat_input</code> is read automatically from the request payload as JSON and deserialized automatically into an instance of the <code>CreateCatInput</code> class.</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep.server.bindings import FromJSON\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n    ...\n\n\n@post(\"/cat\")\nasync def create_cat(\n    cat_input: FromJSON[CreateCatInput]\n):\n    data = cat_input.value\n    ...\n</code></pre> <p>More details about bindings are described in Binders.</p>"},{"location":"request-handlers/#normalization-and-openapi-documentation","title":"Normalization and OpenAPI Documentation","text":"<p>Request handler normalization also enables a more accurate generation of OpenAPI Documentation, since the web framework knows that request handlers need input from query strings, routes, headers, cookies, etc.; and produce responses of a certain type.</p>"},{"location":"request-handlers/#using-asynchronous-and-synchronous-code","title":"Using asynchronous and synchronous code.","text":"<p>BlackSheep supports both asynchronous and synchronous request handlers. Request handlers don't need to be asynchronous in those scenarios when the response is well-known and can be produced without doing any I/O bound operation or any CPU-intensive operation. This is the case for example of redirects, and the previous \"Hello, There!\" example:</p> <pre><code>from blacksheep import Application, Request, Response, get, text, redirect\n\n\napp = Application()\n\n\n@get(\"/sync\")\ndef sync_handler() -&gt; str:\n    return \"Example Sync\"\n\n@get(\"/redirect-me\")\ndef redirect_example() -&gt; Response:\n    return redirect(\"/sync\")\n</code></pre> <p>Request handlers that perform I/O-bound or CPU-intensive operations should be defined as <code>async</code> to avoid hindering the performance of the web server. For example, if information is fetched from a database or a remote API when handling a web request handler, it is correct to use asynchronous code to reduce RAM consumption and not block the event loop of the web application.</p> <p>CPU and I/O intensive operations.</p> <p>If an operation is CPU-intensive (e.g. file operations or image resizing), the request handlers that initiate such operation should be async, and use a thread or process pool to not block the web app's event loop. Similarly, request handlers that initiate I/O bound operations (e.g. web requests to external APIs, connecting to a database) should also be <code>async</code>.</p>"},{"location":"request-handlers/#next","title":"Next","text":"<p>The next pages describe requests and responses in detail.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"requests/","title":"Requests","text":"<p>This page describes:</p> <ul> <li> Handling requests.</li> <li> Reading parameters from the request.</li> <li> Reading request headers and cookies.</li> <li> Reading request bodies.</li> </ul>"},{"location":"requests/#the-request-class","title":"The Request class","text":"<p>BlackSheep handles requests as instances of the <code>blacksheep.Request</code> class. This class provides methods and properties to handle request headers, cookies, the URL, route parameters, the request body, the user's identity, and other information like the content type of the request. Each web request results in the creation of a new instance of <code>Request</code>.</p>"},{"location":"requests/#reading-parameters-from-the-request-object","title":"Reading parameters from the request object","text":"<p>It is possible to read query and route parameters from an instance of <code>request</code>. The example below shows how the query string, route parameters, and request headers can be read from the request:</p> <pre><code>from blacksheep import Application, Request, Response, get, text\n\n\napp = Application()\n\n\n@get(\"/{something}\")\ndef example(request: Request) -&gt; Response:\n    client_accept = request.headers.get_first(b\"Accept\")\n    # client_accept is None or bytes\n\n    hello = request.query.get(\"hello\")\n    # hello is None or a List[str]\n\n    something = request.route_values[\"something\"]\n    # something is str\n\n    return text(\n        f\"\"\"\n        Accept: {client_accept.decode()}\n        Hello: {hello}\n        Something: {something}\n        \"\"\"\n    )\n</code></pre> <p>However, the recommended approach is to use automatic bindings, which enable a more accurate generation of OpenAPI Documentation, automatic parsing of values into the desired type, and improves the development experience and source code.</p> <p>The same example can be achieved in the following way:</p> <pre><code>from blacksheep import Application, Request, Response, get, text, FromHeader, FromQuery\n\n\napp = Application()\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\n@get(\"/{something}\")\ndef example(\n    something: str, accept: FromAcceptHeader, hello: FromQuery[str]\n) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Hello: {hello.value}\n        Something: {something}\n        \"\"\"\n    )\n</code></pre> <p>HTTP GET <code>/example?hello=World</code>: <pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,mage/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nHello: World\nSomething: example\n</code></pre></p>"},{"location":"requests/#reading-request-headers-and-cookies","title":"Reading request headers and cookies","text":"<pre><code>from typing import Optional\n\nfrom blacksheep import Application, Response, get, text, FromHeader, FromCookie\n\napp = Application()\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\nclass FromFooCookie(FromCookie[Optional[str]]):\n    name = \"foo\"\n\n\n@get(\"/\")\ndef home(accept: FromAcceptHeader, foo: FromFooCookie) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Foo: {foo.value}\n        \"\"\"\n    )\n</code></pre>"},{"location":"requests/#reading-the-request-body","title":"Reading the request body","text":"<p>The request class offers several methods to read request bodies of different kinds.</p>"},{"location":"requests/#reading-json","title":"Reading JSON","text":"Using binders (recommended)Directly from the request <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import FromJSON, post\n\n\n@dataclass\nclass SomethingInput:\n    name: str\n    foo: bool\n\n\n@post(\"/something\")\nasync def create_something(input: FromJSON[SomethingInput]):\n    data = input.value\n\n    # data is already deserialized from JSON into an instance of\n    # `SomethingInput`\n</code></pre> <p>The type parameter for the <code>FromJSON</code> binder can be a dataclass, a model from <code>pydantic</code>, or a regular class with an <code>__init__</code> method.</p> <p>Note that when mapping the request's payload to an instance of the desired type, the type's constructor with <code>cls(**data)</code> is used. If it necessary to parse dates or other complex types this must be done in the constructor of the class. To gracefully handle a payload with extra properties, use <code>*args</code> in your class constructor: <code>__init__(one, two, three, *args)</code>.</p> <p>To read the JSON payload as a regular dictionary, use <code>dict</code> as the type argument:</p> <pre><code>@post(\"/something\")\nasync def create_something(input: FromJSON[dict]):\n    ...\n</code></pre> <p>When the JSON is read from the request object, it is always treated as the raw deserialized object (usually a dictionary or a list).</p> <pre><code>@post(\"/something\")\nasync def create_something(request: Request):\n    data = await request.json()\n\n    # data is the deserialized object\n</code></pre>"},{"location":"requests/#reading-a-form-request-body","title":"Reading a form request body","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromForm, post\n\n\nclass SomethingInput:\n    name: str\n    foo: bool\n\n    def __init__(self, name: str, foo: str) -&gt; None:\n        self.name = name\n        self.foo = bool(foo)\n\n\n@post(\"/something\")\nasync def create_something(input: FromForm[SomethingInput]):\n    data = input.value\n\n    # data is already deserialized from the form body into an instance\n    # of `SomethingInput` - however some properties need to be parsed\n    # from str into the desired type in the class definition -\n    # see __init__ above\n</code></pre> <pre><code>@post(\"/something\")\nasync def create_something(request: Request):\n    data = await request.form()\n\n    # data is a dictionary\n</code></pre>"},{"location":"requests/#reading-text","title":"Reading text","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromText\n\n\n@post(\"/something\")\nasync def store_text(text: FromText):\n    data = text.value\n</code></pre> <pre><code>@post(\"/text\")\nasync def create_text(request: Request):\n    data = await request.text()\n\n    # data is a string\n</code></pre>"},{"location":"requests/#reading-raw-bytes","title":"Reading raw bytes","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromBytes\n\n\n@post(\"/something\")\nasync def example(payload: FromBytes):\n    data = payload.value\n</code></pre> <pre><code>@post(\"/text\")\nasync def example(request: Request):\n    data = await request.read()\n\n    # data is bytes\n</code></pre>"},{"location":"requests/#reading-files","title":"Reading files","text":"<p>Files read from <code>multipart/form-data</code> payload.</p> Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromFiles\n\n\n@post(\"/something\")\nasync def post_files(files: FromFiles):\n    data = files.value\n</code></pre> <pre><code>@post(\"/upload-files\")\nasync def upload_files(request: Request):\n    files = await request.files()\n\n    for part in files:\n        file_bytes = part.data\n        file_name = file.file_name.decode()\n\n    ...\n</code></pre>"},{"location":"requests/#reading-streams","title":"Reading streams","text":"<p>Reading streams enables reading large-sized bodies using an asynchronous generator. The example below saves a file of arbitrary size without blocking the event loop:</p> Directly from the request <pre><code>from blacksheep import created, post\n\n\n@post(\"/upload\")\nasync def save_big_file(request: Request):\n\n    with open(\"./data/0001.dat\", mode=\"wb\") as saved_file:\n        async for chunk in request.stream():\n            saved_file.write(chunk)\n\n    return created()\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"responses/","title":"Responses","text":"<p>This page describes:</p> <ul> <li> How responses are handled.</li> <li> Helper functions to handle responses.</li> <li> Responses using asynchronous generators.</li> </ul>"},{"location":"responses/#the-response-class","title":"The Response class","text":"<p>A standard request handler in BlackSheep is expected to return an instance of the <code>blacksheep.Response</code> class. Users of the framework can define request handlers that return different kinds of objects. In such cases they are normalized at application start-up to return instances of <code>Response</code>.</p> <p>The following example shows how to use the low-level objects to create a response with status 200 and body \"Hello, World\":</p> <pre><code>from blacksheep import Application, Response, Content, get\n\napp = Application()\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    return Response(200, content=Content(b\"text/plain\", b\"Hello, World!\"))\n</code></pre> <p>BlackSheep uses these exact types to benefit from static typing and compilation of <code>Cython</code> extensions. However, handling responses this way is not comfortable for regular use. For this reason, a number of helper functions are provided to create <code>Response</code> objects with a more user-friendly code API.</p> <p>For example, the <code>json</code> function in <code>blacksheep.server.responses</code> produces a response object having a JSON body.</p> <pre><code>from blacksheep import Application, get, json\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    return json({\"message\": \"Hello, World!\"})\n</code></pre> <p>Produces the following response body:</p> <pre><code>{\"message\":\"Hello, World!\"}\n</code></pre> <p>The framework also allows to define a request handler this way:</p> <pre><code>from blacksheep import Application, get\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    return {\"message\": \"Hello, World!\"}\n</code></pre> <p>When a request handler doesn't specify a <code>Response</code> return type with type annotations, the framework must check the function's return type at each call (causing a small performance fee!), and automatically prepares a <code>Response</code> if necessary.</p>"},{"location":"responses/#functions-in-blacksheepserverresponses","title":"Functions in <code>blacksheep.server.responses</code>","text":"<p>The table below describes the built-in functions to produce responses:</p> Method Description ok Returns an HTTP 200 OK response, with an optional message; sent as plain text or JSON. status_code Returns a plain response with the given status, and with an optional message; sent as plain text or JSON. created Returns an HTTP 201 Created response, to the given location and with optional JSON content. accepted Returns an HTTP 202 Accepted response, with an optional message; sent as plain text or JSON. no_content Returns an HTTP 204 No Content response. json Returns a response with application/json content, and the given status (default HTTP 200 OK). pretty_json Returns a response with indented application/json content, and the given status (default HTTP 200 OK). text Returns a response with text/plain content, and the given status (default HTTP 200 OK). moved_permanently Returns an HTTP 301 Moved Permanently response, to the given location. redirect Returns an HTTP 302 Found response (commonly called redirect), to the given location. see_other Returns an HTTP 303 See Other response, to the given location. not_modified Returns an HTTP 304 Not Modified response. temporary_redirect Returns an HTTP 307 Temporary Redirect response, to the given location. permanent_redirect Returns an HTTP 308 Permanent Redirect response, to the given location. bad_request Returns an HTTP 400 Bad Request response, with an optional message; sent as plain text or JSON. unauthorized Returns an HTTP 401 Unauthorized response, with an optional message; sent as plain text or JSON. forbidden Returns an HTTP 403 Forbidden response, with an optional message; sent as plain text or JSON. not_found Returns an HTTP 404 Not Found response, with an optional message; sent as plain text or JSON. view Returns a view rendered synchronously. view_async Returns a view rendered asynchronously. file Returns a binary file response with the given content type and optional file name, for download (attachment) (default HTTP 200 OK). This method supports being called with bytes, or a generator yielding chunks. <p>Info</p> <p>These functions can be imported directly from the <code>blacksheep</code> namespace.</p> <p>For information on how to use these methods, refer to the type annotations provided in the code.</p> <p></p> <p>Info</p> <p>Using an IDE like JetBrains PyCharm, or Visual Studio Code (as in the screenshot above), enables automatic completion and hints thanks to type annotations.</p>"},{"location":"responses/#response-headers","title":"Response headers","text":"<p>To specify response headers use one of the following methods:</p> <pre><code>@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.add_header(b\"Example\", b\"Value\")\n\n    # add supports multiple headers with the same name:\n    response.headers.add(b\"X-Foo\", b\"Foo\")\n\n    # set syntax overrides other headers with the same name:\n    response.headers[b\"Set-Header-Overriding\"] = b\"Foo\"\n\n    return response\n</code></pre> <p>BlackSheep requires specifying header names and values as <code>bytes</code>, not strings.</p>"},{"location":"responses/#setting-cookies","title":"Setting cookies","text":"<p>To set a cookie, use the <code>set_cookie</code> method of the <code>Response</code> class:</p> <pre><code>from blacksheep import Application, get, json\nfrom blacksheep.cookies import Cookie\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookie(Cookie(\"foo\", \"value\"))\n\n    return response\n</code></pre> <p>The <code>set_cookie</code> method is an abstraction layer on top of the <code>Set-Cookie</code> response header.</p> <p>The following example shows how to set a cookie with <code>HttpOnly</code> and lasting 15 minutes.</p> <pre><code>from datetime import datetime, timedelta\n\nfrom blacksheep import Application, Response, get, json\nfrom blacksheep.cookies import Cookie\n\napp = Application()\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookie(\n        Cookie(\n            \"foo2\",\n            \"value2\",\n            http_only=True,\n            expires=datetime.now() + timedelta(minutes=15),\n        )\n    )\n\n    return response\n</code></pre> <p>Cookie's options:</p> Parameter Type (default value) Description name <code>str</code> Cookie's name. value <code>str</code> Cookie's value. expires <code>datetime                                           | null</code> (<code>null</code>) The maximum lifetime of the cookie as an HTTP-date timestamp. If unspecified, the cookie becomes a session cookie. A session finishes when the client shuts down, and session cookies will be removed. domain <code>str                                                | null</code> (<code>null</code>) Host to which the cookie will be sent. path <code>str                                                | null</code> (<code>null</code>) Optional path to restrict access to the cookie. http_only <code>bool</code> (<code>False</code>) Optional boolean to forbid JavaScript access to the cookie. secure <code>bool</code> (<code>False</code>) Optionally instructs browsers to send the cookie only over HTTPS (or <code>localhost</code>). max_age <code>int</code> (<code>-1</code>) Optional number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. same_site <code>CookieSameSiteMode</code> (CookieSameSiteMode.UNDEFINED) Controls the cookie's <code>Same-Site</code> attribute."},{"location":"responses/#cookiesamesitemode-enum","title":"<code>CookieSameSiteMode</code> enum","text":"Value Description UNDEFINED Doesn't set the <code>Same-Site</code> attribute, leaving the default to the client. LAX Sets <code>Same-Site=Lax</code> attribute. STRICT Sets <code>Same-Site=Strict</code> attribute NONE Sets <code>Same-Site=None</code> attribute <ul> <li>Strict: The browser sends the cookie only for same-site requests (that is,   requests originating from the same site that set the cookie). If the request   originated from a different URL than the current one, no cookies with the   SameSite=Strict attribute are sent.</li> <li>Lax: The cookie is not sent on cross-site requests, such as calls to load   images or frames, but is sent when a user is navigating to the origin site   from an external site (e.g. if following a link). This is the default   behavior if the SameSite attribute is not specified.</li> <li>None: The browser sends the cookie with both cross-site and same-site   requests. The <code>Secure</code> attribute is automatically set when <code>SameSite=None</code>.</li> </ul>"},{"location":"responses/#setting-many-cookies","title":"Setting many cookies","text":"<p>Use the <code>Response.set_cookies</code> method to set several cookies at once.</p> <pre><code>@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookies(\n        [\n            Cookie(\"A\", \"lorem\"),\n            Cookie(\"B\", \"ipsum\"),\n        ]\n    )\n\n    return response\n</code></pre>"},{"location":"responses/#unsetting-cookies","title":"Unsetting cookies","text":"<p>Use the <code>Response.unset_cookie</code> method to delete a cookie that was previously sent to a client.</p> <pre><code>@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.unset_cookie(\"foo\")\n\n    return response\n</code></pre> <p>The <code>unset_cookie</code> method is an abstraction layer, configuring a <code>Set-Cookie</code> response header containing an instruction to remove a cookie by name.</p>"},{"location":"responses/#removing-cookies","title":"Removing cookies","text":"<p>Use the <code>Response.remove_cookie</code> method to remove a cookie from the response object before it's sent to the client. This method does not generate a <code>Set-Cookie</code> header. Use <code>unset_cookie</code> if the intention is to instruct the client to discard a previously sent cookie.</p>"},{"location":"responses/#response-streaming","title":"Response streaming","text":"<p>BlackSheep supports response streaming using <code>StreamedContent</code> objects bound to a generator yielding bytes, like described in the following paragraph. If the content length is not known in advance, chunked encoding is used by default. If the content length is known in advance, it can be set in the instance of <code>StreamedContent</code> (in this case, it is responsibility of the user to ensure the generator will return the correct amount of bytes).</p>"},{"location":"responses/#chunked-encoding","title":"Chunked encoding","text":"<p>The following example illustrates how response streaming can be used in responses, using a <code>StreamedContent</code> object bound to a generator yielding bytes.</p> <pre><code>import asyncio\nfrom blacksheep import Application, Response, StreamedContent, get\n\napp = Application()\n\n\n@get(\"/chunked-text\")\nasync def get_chunked_text(request):\n    async def provider():\n        yield b\"Lorem \"\n        await asyncio.sleep(0.01)\n        yield b\"ipsum\"\n        await asyncio.sleep(0.01)\n        yield b\" dolor\"\n        yield b\" sit\"\n        yield b\"\"\n\n    return Response(200, content=StreamedContent(b\"text/plain\", provider))\n</code></pre> <p>Alternatively, it is possible to use the <code>file</code> function from <code>blacksheep.server.responses</code> or directly from <code>blacksheep</code>:</p> <pre><code>import asyncio\nfrom blacksheep import Application, ContentDispositionType, file, get\n\napp = Application(show_error_details=True)\n\n\n@router.get(\"/chunked-text\")\nasync def get_chunked_text(request):\n    async def provider():\n        yield b\"Lorem \"\n        await asyncio.sleep(0.01)\n        yield b\"ipsum\"\n        await asyncio.sleep(0.01)\n        yield b\" dolor\"\n        yield b\" sit\"\n        yield b\"\"\n\n    return file(\n        provider, \"text/plain\", content_disposition=ContentDispositionType.INLINE\n    )\n</code></pre> <p>Info</p> <p>BlackSheep uses chunked encoding by default when serving static files.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"routing/","title":"Routing","text":"<p>Server side routing refers to the ability of a web application to handle web requests using different functions, depending on the URL path and HTTP method. Each BlackSheep application is bound to a router, which provides several ways to define routes. A function that is bound to a route is called a \"request handler\", since its responsibility is to handle web requests and produce responses.</p> <p>This page describes:</p> <ul> <li> How to define request handlers.</li> <li> How to use route parameters.</li> <li> How to define a catch-all route.</li> <li> How to define a fallback route.</li> <li> How to use sub-routers and filters.</li> <li> How to use the default router and other routers.</li> </ul>"},{"location":"routing/#defining-request-handlers","title":"Defining request handlers","text":"<p>A request handler is a function used to produce responses. To become request handlers, functions must be bound to a route, that represents a certain URL path pattern. The <code>Router</code> class provides several methods to define request handlers: with decorators (\ud83d\udde1\ufe0f in the table below) and without decorators (\ud83d\udee1\ufe0f):</p> Router method HTTP method Type head HEAD \ud83d\udde1\ufe0f get GET \ud83d\udde1\ufe0f post POST \ud83d\udde1\ufe0f put PUT \ud83d\udde1\ufe0f delete DELETE \ud83d\udde1\ufe0f trace TRACE \ud83d\udde1\ufe0f options OPTIONS \ud83d\udde1\ufe0f connect CONNECT \ud83d\udde1\ufe0f patch PATCH \ud83d\udde1\ufe0f add_head HEAD \ud83d\udee1\ufe0f add_get GET \ud83d\udee1\ufe0f add_post POST \ud83d\udee1\ufe0f add_put PUT \ud83d\udee1\ufe0f add_delete DELETE \ud83d\udee1\ufe0f add_trace TRACE \ud83d\udee1\ufe0f add_options OPTIONS \ud83d\udee1\ufe0f add_connect CONNECT \ud83d\udee1\ufe0f add_patch PATCH \ud83d\udee1\ufe0f"},{"location":"routing/#with-decorators","title":"With decorators","text":"<p>The following example shows how to define a request handler for the root path of a web application \"/\":</p> <pre><code>from blacksheep import get\n\n\n@get(\"/\")\ndef hello_world():\n    return \"Hello World\"\n</code></pre> <p>Alternatively, the application router offers a <code>route</code> method:</p> <pre><code>from blacksheep import route\n\n\n@route(\"/example\", methods=[\"GET\", \"HEAD\", \"TRACE\"])\nasync def example():\n    # HTTP GET /example\n    # HTTP HEAD /example\n    # HTTP TRACE /example\n    return \"Hello, World!\"\n</code></pre>"},{"location":"routing/#without-decorators","title":"Without decorators","text":"<p>Request handlers can be registered without decorators:</p> <pre><code>def hello_world():\n    return \"Hello World\"\n\n\napp.router.add_get(\"/\", hello_world)\napp.router.add_options(\"/\", hello_world)\n</code></pre>"},{"location":"routing/#request-handlers-as-class-methods","title":"Request handlers as class methods","text":"<p>Request handlers can also be configured as class methods, defining classes that inherit the <code>blacksheep.server.controllers.Controller</code> class:</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import Application, text, json\nfrom blacksheep.server.controllers import Controller, get, post\n\n\napp = Application()\n\n\n# example input contract:\n@dataclass\nclass CreateFooInput:\n    name: str\n    nice: bool\n\n\nclass Home(Controller):\n\n    def greet(self):\n        return \"Hello World\"\n\n    @get(\"/\")\n    async def index(self):\n        # HTTP GET /\n        return text(self.greet())\n\n    @get(\"/foo\")\n    async def foo(self):\n        # HTTP GET /foo\n        return json({\"id\": 1, \"name\": \"foo\", \"nice\": True})\n\n    @post(\"/foo\")\n    async def create_foo(self, foo: CreateFooInput):\n        # HTTP POST /foo\n        # with foo instance automatically injected parsing\n        # the request body as JSON\n        # if the value cannot be parsed as CreateFooInput,\n        # Bad Request is returned automatically\n        return json({\"status\": True})\n</code></pre>"},{"location":"routing/#route-parameters","title":"Route parameters","text":"<p>BlackSheep supports three ways to define route parameters:</p> <ul> <li><code>\"/:example\"</code> - using a single colon after a slash</li> <li><code>\"/{example}\"</code> - using curly braces</li> <li><code>\"/&lt;example&gt;\"</code> - using angle brackets (i.e. Flask notation)</li> </ul> <p>Route parameters can be read from <code>request.route_values</code>, or bound automatically by the request handler's signature:</p> Using the signature (recommended)Using the Request object <pre><code>from blacksheep import get\n\n@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id):\n    # cat_id is bound automatically\n    ...\n</code></pre> <pre><code>from blacksheep import Request, get\n\n@get(\"/{example}\")\ndef handler(request: Request):\n    # reading route values from the request object:\n    value = request.route_values[\"example\"]\n    ...\n</code></pre> <p>It is also possible to specify the expected type, using <code>typing</code> annotations:</p> <pre><code>@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id: int):\n    ...\n</code></pre> <pre><code>from uuid import UUID\n\n\n@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id: UUID):\n    ...\n</code></pre> <p>In this case, BlackSheep will automatically produce an <code>HTTP 400 Bad Request</code> response if the input cannot be parsed into the expected type, producing a response body similar to this one:</p> <pre><code>Bad Request: Invalid value ['asdas'] for parameter `cat_id`; expected a valid\nUUID.\n</code></pre>"},{"location":"routing/#value-patterns","title":"Value patterns","text":"<p>By default, route parameters are matched by any string until the next slash \"/\" character. Having the following route:</p> <pre><code>@get(\"/api/movies/{movie_id}/actors/{actor_id}\")\ndef get_movie_actor_details(movie_id: str, actor_id: str):\n    ...\n</code></pre> <p>HTTP GET requests having the following paths are all matched:</p> <pre><code>/api/movies/12345/actors/200587\n\n/api/movies/Trading-Places/actors/Denholm-Elliott\n\n/api/movies/b5317165-ad31-47e2-8a2d-42dba8619b31/actors/a601d8f2-a1ab-4f20-aebf-60eda8e89df0\n</code></pre> <p>However, the framework supports more granular control on the expected value pattern. For example, to specify that <code>movie_id</code> and <code>actor_id</code> must be integers, it is possible to define route parameters this way:</p> <pre><code>\"/api/movies/{int:movie_id}/actors/{int:actor_id}\"\n</code></pre> <p>Warning</p> <p>Value patterns only affect the regular expression used to match requests' URLs. They don't affect the type of the parameter after a web request is matched. Use type annotations as described above to enforce types of the variables as they are passed to the request handler.</p> <p>The following value patterns are built-in:</p> Value pattern Description <code>str</code> Any value that doesn't contain a slash \"/\". <code>int</code> Any value that contains only numeric characters. <code>float</code> Any value that contains only numeric characters and eventually a dot with digits. <code>path</code> Any value to the end of the path. <code>uuid</code> Any value that matches the UUID value pattern. <p>To define custom value patterns, extend the <code>Route.value_patterns</code> dictionary. The key of the dictionary is the name used by the parameter, while the value is a regular expression used to match the parameter's fragment. For example, to define a custom value pattern for route parameters composed of exactly two letters between <code>a-z</code> and <code>A-Z</code>:</p> <pre><code>Route.value_patterns[\"example\"] = r\"[a-zA-Z]{2}\"\n</code></pre> <p>And then use it in routes:</p> <pre><code>\"/{example:foo}\"\n</code></pre>"},{"location":"routing/#catch-all-routes","title":"Catch-all routes","text":"<p>To define a catch-all route that will match every request, use a route parameter with a path value pattern, like:</p> <ul> <li><code>{path:name}</code>, or <code>&lt;path:name&gt;</code></li> </ul> <pre><code>from blacksheep import text\n\n\n@get(\"/catch-all/{path:sub_path}\")\ndef catch_all(sub_path: str):\n    return text(sub_path)\n</code></pre> <p>For example, a request at <code>/catch-all/anything/really.js</code> would be matched by the route above, and the <code>sub_path</code> value would be <code>anything/really.js</code>.</p> <p>It is also possible to define a catch-all route using a star sign <code>*</code>. To read the portion of the path caught by the star sign from the request object, read the \"tail\" property of <code>request.route_values</code>. But in this case the value of the caught path can only be read from the request object.</p> <pre><code>@get(\"/catch-all/*\")\ndef catch_all(request):\n    sub_path = request.route_values[\"tail\"]\n</code></pre>"},{"location":"routing/#defining-a-fallback-route","title":"Defining a fallback route","text":"<p>To define a fallback route that handles web requests not handled by any other route, use <code>app.router.fallback</code>:</p> <pre><code>def fallback():\n    return \"OOPS! Nothing was found here!\"\n\n\napp.router.fallback = fallback\n</code></pre>"},{"location":"routing/#using-sub-routers-and-filters","title":"Using sub-routers and filters","text":"<p>The <code>Router</code> class supports filters for routes and sub-routers. In the following example, a web request for the root of the service \"/\" having a request header \"X-Area\" == \"Test\" gets the reply of the <code>test_home</code> request handler, and without such header the reply of the <code>home</code> request handler is returned.</p> <pre><code>from blacksheep import Application, Router\n\n\ntest_router = Router(headers={\"X-Area\": \"Test\"})\n\nrouter = Router(sub_routers=[test_router])\n\n@router.get(\"/\")\ndef home():\n    return \"Home 1\"\n\n@test_router.get(\"/\")\ndef test_home():\n    return \"Home 2\"\n\n\napp = Application(router=router)\n</code></pre> <p>A router can have filters based on headers, host name, query string parameters, and custom user-defined filters.</p> <p>Query string filters can be defined using the <code>params</code> parameter, and host name filters can be defined using the <code>host</code> parameter:</p> <pre><code>filter_by_query = Router(params={\"version\": \"1\"})\n\nfilter_by_host  = Router(host=\"neoteroi.xyz\")\n</code></pre>"},{"location":"routing/#custom-filters","title":"Custom filters","text":"<p>To define a custom filter, define a type of <code>RouteFilter</code> and set it using the <code>filters</code> parameter:</p> <pre><code>from blacksheep import Application, Request, Router\nfrom blacksheep.server.routing import RouteFilter\n\n\nclass CustomFilter(RouteFilter):\n\n    def handle(self, request: Request) -&gt; bool:\n        # implement here the desired logic\n        return True\n\n\nexample_router = Router(filters=[CustomFilter()])\n</code></pre>"},{"location":"routing/#using-the-default-router-and-other-routers","title":"Using the default router and other routers","text":"<p>The examples in the documentation show how to register routes using methods imported from the BlackSheep package:</p> <pre><code>from blacksheep import get\n\n@get(\"\")\nasync def home():\n    ...\n</code></pre> <p>Or, for controllers:</p> <pre><code>from blacksheep.server.controllers import Controller, get\n\n\nclass Home(Controller):\n\n    @get(\"/\")\n    async def index(self):\n        ...\n</code></pre> <p>In this case, routes are registered using default singleton routers, used if an application is instantiated without specifying a router:</p> <pre><code>from blacksheep import Application\n\n\n# This application uses the default singleton routers exposed by BlackSheep:\napp = Application()\n</code></pre> <p>This works in most scenarios, when a single <code>Application</code> instance per process is used. For more complex scenarios, it is possible to instantiate a router and use it as desired:</p> <pre><code># app/router.py\n\nfrom blacksheep import Router\n\n\nrouter = Router()\n</code></pre> <p>And use it when registering routes:</p> <pre><code>from app.router import router\n\n\n@router.get(\"/\")\nasync def home():\n    ...\n</code></pre> <p>It is also possible to expose the router methods to reduce code verbosity, like the BlackSheep package does:</p> <pre><code># app/router.py\n\nfrom blacksheep import Router\n\n\nrouter = Router()\n\n\nget = router.get\npost = router.post\n\n# ...\n</code></pre> <pre><code>from app.router import get\n\n\n@get(\"/\")\nasync def home():\n    ...\n</code></pre> <p>Then specify the router when instantiating the application:</p> <pre><code>from blacksheep import Application\n\nfrom app.router import router\n\n\n# This application uses the router instantiated in app.router:\napp = Application(router=router)\n</code></pre>"},{"location":"routing/#controllers-dedicated-router","title":"Controllers dedicated router","text":"<p>Controllers need a different kind of router, an instance of <code>blacksheep.server.routing.RoutesRegistry</code>. If using a dedicated router for controllers is desired, do this instead:</p> <pre><code># app/controllers.py\n\nfrom blacksheep import RoutesRegistry\n\n\ncontrollers_router = RoutesRegistry()\n\n\nget = controllers_router.get\npost = controllers_router.post\n\n# ...\n</code></pre> <p>Then when defining your controllers:</p> <pre><code>from blacksheep.server.controllers import Controller\n\nfrom app.controllers import get, post\n\n\nclass Home(Controller):\n\n    @get(\"/\")\n    async def index(self):\n        ...\n</code></pre> <pre><code>from blacksheep import Application\n\nfrom app.controllers import controllers_router\n\n\n# This application uses the controllers' router instantiated in app.controllers:\napp = Application()\napp.controllers_router = controllers_router\n</code></pre> <p>About Router and RoutesRegistry</p> <p>Controller routes use a \"RoutesRegistry\" to support the dynamic generation of paths by controller class name. Controller routes are evaluated and merged into <code>Application.router</code> when the application starts.</p>"},{"location":"routing/#routing-prefix","title":"Routing prefix","text":"<p>In some scenarios, it may be necessary to centrally manage prefixes for all request handlers. To set a prefix for all routes in a <code>Router</code>, use the <code>prefix</code> parameter in its constructor.</p> <pre><code>router = Router(prefix=\"/foo\")\n</code></pre> <p>To globally configure a prefix for all routes, use the environment variable <code>APP_ROUTE_PREFIX</code> and specify the desired prefix as its value.</p> <p>This feature is intended for applications deployed behind proxies. For more information, refer to Behind proxies.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRVT"},{"location":"server-sent-events/","title":"Server-Sent Events","text":"<p>Server-Sent Events (SSE) enable creating a persistent, one-way connection between a client and a server. When using SSE, a client can receive automatic updates from a server via an HTTP connection.</p> <p>BlackSheep implements built-in support for server-side events since version <code>2.0.6</code>, offering features to simplify their use. This page describes how to use the built-in features for server-sent events.</p> <p>Tip</p> <p>Older versions of the web framework can also be configured to use SSE, because they all support response streaming, but don't offer dedicated features to simplify their use.</p>"},{"location":"server-sent-events/#defining-a-server-sent-events-route","title":"Defining a server-sent events route","text":"<p>The following example describes how to configure a route for server-sent events, defining a request handler as asynchronous generator:</p> <pre><code>import asyncio\nfrom collections.abc import AsyncIterable\n\nfrom blacksheep import Application, get\nfrom blacksheep.server.sse import ServerSentEvent\n\napp = Application()\n\n\n# A request handler defined as async generator yielding ServerSentEvent...\n@get(\"/events\")\nasync def events_handler() -&gt; AsyncIterable[ServerSentEvent]:\n    for i in range(3):\n        yield ServerSentEvent({\"message\": f\"Hello World {i}\"})\n        await asyncio.sleep(1)\n</code></pre> <ol> <li>Import <code>ServerSentEvent</code> from <code>blacksheep.server.sse</code>.</li> <li>Import <code>AsyncIterable</code> from <code>collections.abc</code>, or from <code>typing</code> if support    for Python 3.8 is desired.</li> <li>Define a request handler as asynchronous generator with a return type    annotation of <code>AsyncIterable[ServerSentEvent]</code> (the function must be <code>async</code>    and must include at least one <code>yield</code> statement like above).</li> </ol> <p>In this case the return type annotation on the request handler is mandatory because the request handler is normalized automatically.</p> <p>BlackSheep supports request handlers defined as asynchronous generators since version <code>2.0.6</code> especially for this use case, to support less verbose code when using server-sent events. Previous versions already supported response streaming, but required returning a <code>Response</code> bound to a <code>StreamedContent</code> and an asynchronous generator yielding bytes. Using <code>async generators</code> with custom classes require configuring the type of <code>Response</code> that is used to convert those classes into bytes, like described in the responses page.</p> <p>The following example demonstrates how to define a server-sent event route controlling the <code>Response</code> object.</p>"},{"location":"server-sent-events/#defining-a-server-sent-events-route-controlling-the-response-object","title":"Defining a server-sent events route controlling the Response object","text":"<p>To define a server-sent events route and maintain control of the <code>Response</code> object, refer to the following example:</p> <pre><code>import asyncio\nfrom collections.abc import AsyncIterable\n\nfrom blacksheep import Application, get\nfrom blacksheep.server.sse import ServerSentEvent, ServerSentEventsResponse\n\napp = Application()\n\n\n# An AsyncGenerator yielding ServerSentEvent...\nasync def events_provider() -&gt; AsyncIterable[ServerSentEvent]:\n    for i in range(3):\n        yield ServerSentEvent({\"message\": f\"Hello World {i}\"})\n        await asyncio.sleep(1)\n\n\n# A request handler returning a streaming response bound to the generator...\n@get(\"/events\")\ndef events_handler():\n    return ServerSentEventsResponse(events_provider)\n</code></pre> <p>In this case the return type annotation is optional.</p> <p>Tip</p> <p>If you need to access the request object or other injected objects inside the generator, use <code>functools.partial</code> for the function argument of the <code>ServerSentEventsResponse</code>.</p>"},{"location":"server-sent-events/#using-controllers","title":"Using controllers","text":"<p>Server-sent events routes are also supported in controllers.</p> <pre><code>import asyncio\nfrom collections.abc import AsyncIterable\n\nfrom blacksheep import Application, Request\nfrom blacksheep.server.process import is_stopping\nfrom blacksheep.server.sse import ServerSentEvent\nfrom blacksheep.server.controllers import Controller, get\n\napp = Application()\n\n\nclass Home(Controller):\n    @get(\"/events\")\n    async def events_handler(self, request: Request) -&gt; AsyncIterable[ServerSentEvent]:\n        i = 0\n\n        while True:\n            if await request.is_disconnected():\n                print(\"The request is disconnected!\")\n                break\n\n            if is_stopping():\n                print(\"The application is stopping!\")\n                break\n\n            i += 1\n            yield ServerSentEvent({\"message\": f\"Hello World {i}\"})\n\n            try:\n                await asyncio.sleep(1)\n            except asyncio.exceptions.CancelledError:\n                break\n</code></pre>"},{"location":"server-sent-events/#the-serversentevent-class","title":"The ServerSentEvent class","text":"Property Description <code>data</code> An object that will be transmitted to the client, in JSON. <code>event</code> Optional event type name. <code>id</code> Optional event ID to set the EventSource's last event ID value. <code>retry</code> Optional reconnection delay time, in milliseconds, when a the connection to the server is lost. <code>comment</code> Optional comment. <p>For more information on events properties, please refer to the MDN documentation.</p>"},{"location":"server-sent-events/#handling-client-disconnections-and-application-shutdown","title":"Handling client disconnections and application shutdown","text":"<p>When using a technique that relies on persistent HTTP connections, it is generally necessary to handle:</p> <ul> <li>client disconnections, to stop handling requests that were disconnected.</li> <li>application shutdown gracefully, to close pending connections.</li> </ul> <p>To check if a request is disconnected, use the <code>request.is_disconnected()</code> method where appropriate.</p> <p>To check if the server process is shutting down, use the <code>is_stopping</code> function from <code>blacksheep.server.process</code>.</p> <pre><code>from blacksheep.server.process import is_stopping\n</code></pre> <p>The following example demonstrates a basic usage of both features:</p> <pre><code>import asyncio\nfrom collections.abc import AsyncIterable\n\nfrom blacksheep import Application, Request, get\nfrom blacksheep.server.process import is_stopping\nfrom blacksheep.server.sse import ServerSentEvent\n\napp = Application()\n\n\n@get(\"/events\")\nasync def events_handler(request: Request) -&gt; AsyncIterable[ServerSentEvent]:\n    i = 0\n\n    while True:\n        if await request.is_disconnected():\n            print(\"The request is disconnected!\")\n            break\n\n        if is_stopping():\n            print(\"The application is stopping!\")\n            break\n\n        i += 1\n        yield ServerSentEvent({\"message\": f\"Hello World {i}\"})\n\n        try:\n            await asyncio.sleep(1)\n        except asyncio.exceptions.CancelledError:\n            break\n</code></pre>"},{"location":"server-sent-events/#example-in-github","title":"Example in GitHub","text":"<p>Refer to the server-sent events example for an example that handles application shutdown and client disconnections, and also presents a basic example in JavaScript to use SSE.</p>"},{"location":"server-sent-events/#using-sse-in-older-versions-of-blacksheep","title":"Using SSE in older versions of BlackSheep","text":"<p>The following example illustrates how to use server-sent events in older versions of the web framework.</p> <pre><code>import asyncio\nimport json\nfrom blacksheep import Application, Response, StreamedContent, get\n\napp = Application()\n\n\n@get(\"/events\")\ndef events_handler(request):\n    async def provider():\n        i = 0\n        while True:\n            # TODO: implement way to detect if the process is stopping,\n            # and if the request is still active,\n            # use await request.is_disconnected() if available...\n            obj = {\"message\": f\"Hello World {i}\"}\n            yield b\"data: \" + json.dumps(obj).encode(\"utf8\") + b\"\\r\\n\\r\\n\"\n            i += 1\n\n            try:\n                await asyncio.sleep(1)\n            except asyncio.CancelledError:\n                pass\n\n    return Response(\n        200,\n        headers=[(b\"Cache-Control\", b\"no-cache\"), (b\"Connection\", b\"Keep-Alive\")],\n        content=StreamedContent(b\"text/event-stream\", provider),\n    )\n</code></pre>"},{"location":"server-sent-events/#related-technologies","title":"Related technologies","text":"<p>Server-sent events are often related to WebSockets, which instead enable bi-directional communication between a server and a client, and to long-polling, which is often used as a fall-back when SSE or WebSockets are not supported.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RP"},{"location":"sessions/","title":"Sessions","text":"<p>This page describes features to support sessions, handled with digitally signed cookies.</p> <p>Sessions are stored in cookies.</p> <p>The built-in sessions store data in cookies on the client side. Therefore, web applications using these features must implement Anti-Forgery validation to prevent Cross-Site Request Forgery (XSRF/CSRF).</p>"},{"location":"sessions/#enabling-sessions","title":"Enabling sessions","text":"<p>To enable sessions, use the <code>app.use_sessions</code> method as in the example below:</p> <pre><code>from blacksheep import Application, Request, get, text\n\napp = Application()\n\n\napp.use_sessions(\"&lt;SIGNING_KEY&gt;\")\n\n\n@get(\"/\")\ndef home(request: Request):\n    session = request.session\n\n    session[\"example\"] = \"Lorem ipsum\"\n\n    return text(session[\"example\"])\n</code></pre> <p>The <code>use_sessions</code> method accepts the following parameters:</p> Name Description Defaults to secret_key Required secret key used for signing cookies. N/A session_cookie Optional session cookie name. \"session\" serializer Optional <code>blacksheep.sessions.Serializer</code> to serialize and deserialize session values. <code>blacksheep.sessions.JSONSerializer</code> signer Optional <code>itsdangerous.Serializer</code> to sign and encrypt the session cookie. <code>itsdangerous.URLSafeTimedSerializer</code> session_max_age Optional session max age, in seconds. <code>None</code> <pre><code>    def use_sessions(\n        self,\n        secret_key: str,\n        *,\n        session_cookie: str = \"session\",\n        serializer: Optional[SessionSerializer] = None,\n        signer: Optional[Signer] = None,\n        session_max_age: Optional[int] = None,\n    ) -&gt; None:\n        ...\n</code></pre> <p>The built-in sessions middleware uses <code>itsdangerous</code> to sign, encrypt, and verify session cookies. Refer to data protection for more information on how tokens are signed and encrypted.</p>"},{"location":"sessions/#using-sessions","title":"Using sessions","text":"<p>When sessions are enabled, they are always populated for the <code>request</code> object, and can be accessed through the <code>request.session</code> property.</p> <p>The sessions middleware takes care of setting a response cookie whenever the session is modified, session cookies are signed and encrypted by default.</p> <pre><code>@get(\"/\")\ndef home(request: Request):\n    session = request.session\n\n    # setting a value\n    session[\"example\"] = \"Lorem ipsum\"\n\n    # getting a value\n    foo = session.get(\"foo\")\n\n    # getting a value with default\n    foo = session.get(\"foo\", 100)\n\n    # getting a value (can produce KeyError)\n    foo = session[\"foo\"]\n\n    # checking if a key is set\n    if \"something\" in session:\n        ...\n\n    # deleting a key\n    del session[\"something\"]\n\n    # update with many values\n    session.update({\"a\": 1, \"b\": 2})\n\n    return text(session[\"example\"])\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPRV"},{"location":"settings/","title":"Settings","text":"<p>While most settings are described in sections that are dedicated to other topics, this page describes other settings that can be used in BlackSheep. This page describes:</p> <ul> <li> features to describe the environment of a BlackSheep web application.</li> <li> features to control JSON serialization and deserialization</li> </ul>"},{"location":"settings/#environmental-variables","title":"Environmental variables","text":"Name Category Description APP_ENV Settings This environment variable is read to determine the environment of the application. For more information, refer to Defining application environment. APP_SHOW_ERROR_DETAILS Settings If \"1\" or \"true\", configures the application to display web pages with error details in case of HTTP 500 Internal Server Error. APP_MOUNT_AUTO_EVENTS Settings If \"1\" or \"true\", automatically binds lifecycle events of mounted apps between children and parents BlackSheep applications. APP_ROUTE_PREFIX Settings Allows configuring a global prefix for all routes handled by the application. For more information, refer to: Behind proxies. APP_SECRET_i Secrets Allows configuring the secrets used by the application to protect data. BLACKSHEEP_SECRET_PREFIX Secrets Allows specifying the prefix of environment variables used to configure application secrets, defaults to \"APP_SECRET\" if not specified."},{"location":"settings/#defining-application-environment","title":"Defining application environment","text":"<p>BlackSheep implements a strategy to configure the environment of the application. This configuration is useful to support enabling certain features depending on the environment. For example:</p> <ul> <li>HTTP Strict Transport Security can be disabled for local development.</li> <li>Displaying error details can be enabled only when developing locally.</li> <li>When developing locally, application settings can be read from the user's   folder.</li> </ul> <p>The module <code>blacksheep.server.env</code> offers two functions that can be used to control behavior depending on the app environment:</p> Function True if <code>APP_ENV</code> is... Description <code>is_development</code> \"local\", \"dev\", or \"development\" Returns a value indicating whether the application is running for a development environment. <code>is_production</code> <code>None</code>, \"prod\", or \"production\" Returns a value indicating whether the application is running for a production environment. <p>The two functions read the environment variable <code>APP_ENV</code>. If <code>APP_ENV</code> is not specified, the application defaults to production.</p> <p>In the following example, the error details page displayed for unhandled exceptions is enabled only for development, while HTTP Strict Transport Security is only enabled for all other environments.</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.env import is_development\nfrom blacksheep.server.security.hsts import HSTSMiddleware\n\napp = Application()\n\n\nif is_development():\n    app.show_error_details = True\nelse:\n    app.middlewares.append(HSTSMiddleware())\n</code></pre>"},{"location":"settings/#configuring-json-settings","title":"Configuring JSON settings","text":"<p>BlackSheep supports configuring the functions that are used for JSON serialization and deserialization in the web framework.</p> <p>By default, the built-in <code>json</code> module is used for serializing and deserializing objects, but this can be changed in the way illustrated below.</p> <pre><code>from blacksheep.settings.json import json_settings\n\n\ndef custom_loads(value):\n    \"\"\"\n    This function is responsible for parsing JSON into instances of objects.\n    \"\"\"\n\n\ndef custom_dumps(value):\n    \"\"\"\n    This function is responsible for creating JSON representations of objects.\n    \"\"\"\n\n\njson_settings.use(\n    loads=custom_loads,\n    dumps=custom_dumps,\n)\n</code></pre> <p>Info</p> <p>BlackSheep uses by default a friendlier handling of <code>json.dumps</code> that supports serialization of common objects such as <code>UUID</code>, <code>date</code>, <code>datetime</code>, <code>bytes</code>, <code>@dataclass</code>, <code>pydantic</code> models, etc.</p>"},{"location":"settings/#example-using-orjson","title":"Example: using orjson","text":"<p>To use <code>orjson</code> for JSON serialization and deserialization with the built-in <code>responses</code> and <code>JSONContent</code> class, it can be configured this way:</p> <pre><code>import orjson\n\nfrom blacksheep.settings.json import json_settings\n\n\ndef serialize(value) -&gt; str:\n    return orjson.dumps(value).decode(\"utf8\")\n\n\njson_settings.use(\n    loads=orjson.loads,\n    dumps=serialize,\n)\n</code></pre> <p>Note: the <code>decode(\"utf8\")</code> call is required when configuring <code>orjson</code> for the built-in <code>responses</code> functions and the <code>JSONContent</code> class. This is because <code>orjson.dumps</code> function returns <code>bytes</code> instead of <code>str</code>, and this is something specific to <code>orjson</code> implementation, different than the behavior of the built-in <code>json</code> package and other libraries like <code>rapidjson</code>, <code>UltraJSON</code>, and <code>fast-json</code>. The API implemented in <code>blacksheep</code> expects a JSON serialize function that returns a <code>str</code> like in the built-in package.</p> <p>For users using <code>orjson</code> who want to achieve the best performance and avoid the fee of the superfluous <code>decode -&gt; encode</code> passage, it is recommended to:</p> <ul> <li>not use the built-in <code>responses</code> functions and the built-in <code>JSONContent</code>   class</li> <li>use a custom-defined function for JSON responses like the following example:</li> </ul> <pre><code>def my_json(data: Any, status: int = 200) -&gt; Response:\n    \"\"\"\n    Returns a response with application/json content,\n    and given status (default HTTP 200 OK).\n    \"\"\"\n    return Response(\n        status,\n        None,\n        Content(\n            b\"application/json\",\n            orjson.dumps(data),\n        ),\n    )\n</code></pre>"},{"location":"settings/#example-applying-transformations-during-json-operations","title":"Example: applying transformations during JSON operations","text":"<p>The example below illustrates how to apply transformations to objects while they are serialized and deserialized. Beware that the example only illustrates this possibility, it doesn't handle objects inside lists, <code>@dataclass</code>, or <code>pydantic</code> models!</p> <pre><code>import json\nfrom typing import Any\n\nfrom blacksheep.settings.json import json_settings\nfrom essentials.json import dumps\n\n\ndef default_json_dumps(obj):\n    return dumps(obj, separators=(\",\", \":\"))\n\n\ndef custom_loads(value: str) -&gt; Any:\n    # example: applies a transformation when deserializing an object from JSON\n    # this can be used for example to change property names upon deserialization\n\n    obj = json.loads(value)\n\n    if isinstance(obj, dict) and \"@\" in obj:\n        obj[\"modified_key\"] = obj[\"@\"]\n        del obj[\"@\"]\n\n    return obj\n\n\ndef custom_dumps(value: Any) -&gt; str:\n    # example: applies a transformation when serializing an object into JSON\n    # this can be used for example to change property names upon serialization\n\n    if isinstance(value, dict) and \"@\" in value:\n        value[\"modified_key\"] = value[\"@\"]\n        del value[\"@\"]\n\n    return default_json_dumps(value)\n\n\njson_settings.use(\n    loads=custom_loads,\n    dumps=custom_dumps,\n)\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPDEW"},{"location":"static-files/","title":"Serving static files","text":"<p>This page covers:</p> <ul> <li> How to serve static files.</li> <li> Options for static files.</li> <li> Non-obvious features handled when serving static files.</li> <li> How to serve a Single Page Application (SPA) that uses the HTML5 History API</li> </ul> <p>To serve static files, use the method <code>app.serve_files</code> as in the following example:</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\n# serve files contained in a \"static\" folder relative to the server cwd\napp.serve_files(\"static\")\n</code></pre> <p>The path can be a relative one compared to the application <code>cwd</code>, or an absolute path.</p> <p>When serving files this way, a match-all route (\"*\") is configured in the application router for <code>GET</code> and <code>HEAD</code>, and files are read from the configured folder upon web requests.</p> <p>It is also possible to serve static files from sub-folders:</p> <pre><code>app.serve_files(\"app/static\")\n</code></pre> <p>Enable file discovery (in such case, requests for directories will generate an HTML response with a list of files):</p> <pre><code>app.serve_files(\"app/static\", discovery=True)\n</code></pre> <p>BlackSheep also supports serving static files from multiple folders, and specifying a prefix for the route path:</p> <pre><code>app = Application()\n\n# serve files contained in a \"static\" folder relative to the server cwd\napp.serve_files(\"app/images\", root_path=\"images\")\napp.serve_files(\"app/videos\", root_path=\"videos\")\n</code></pre>"},{"location":"static-files/#file-extensions","title":"File extensions","text":"<p>Only files with a configured extension are served to the client. By default, only files with these extensions are served (case insensitive check):</p> <pre><code>'.txt',\n'.css',\n'.js',\n'.jpeg',\n'.jpg',\n'.html',\n'.ico',\n'.png',\n'.woff',\n'.woff2',\n'.ttf',\n'.eot',\n'.svg',\n'.mp4',\n'.mp3',\n'.webp',\n'.webm'\n</code></pre> <p>To configure extensions, use the dedicated parameter:</p> <pre><code>app.serve_files(\"static\", extensions={'.foo', '.config'})\n</code></pre>"},{"location":"static-files/#accept-ranges-and-range-requests","title":"Accept-Ranges and Range requests","text":"<p>Range requests are enabled and handled by default, meaning that BlackSheep supports serving big files with the pause and resume feature, and serving videos and audio files with the possibility to jump to specific points.</p>"},{"location":"static-files/#etag-and-if-none-match","title":"ETag and If-None-Match","text":"<p><code>ETag</code>, <code>If-None-Match</code> and <code>HTTP Status 304 Not Modified</code> responses are handled automatically, as well as support for <code>HEAD</code> requests returning only headers with information about the files.</p>"},{"location":"static-files/#configurable-cache-control","title":"Configurable Cache-Control","text":"<p>To control <code>Cache-Control</code> <code>max-age</code> HTTP header, use <code>cache_time</code> parameter, defaulting to 10800 seconds (3 hours).</p> <pre><code>app.serve_files(\"static\", cache_time=90000)\n</code></pre>"},{"location":"static-files/#how-to-serve-spas-that-use-html5-history-api","title":"How to serve SPAs that use HTML5 History API","text":"<p>To serve an SPA that uses the HTML5 History API, configure a <code>fallback_document=\"index.html\"</code> if the index file is called \"index.html\".</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\napp.serve_files(\n    \"app/static\",\n    fallback_document=\"index.html\",\n)\n</code></pre> <p>If the SPA uses a file with a different name, specify both the index file name and the fallback document to be the same:</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\napp.serve_files(\n    \"app/static\",\n    index_document=\"example.html\",\n    fallback_document=\"example.html\",\n)\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"templating/","title":"Server Side Rendering (SSR)","text":"<p>Server-side templating refers to a web application's ability to generate HTML pages using templates and dynamic variables. By default, BlackSheep uses the <code>Jinja2</code> library library developed by the Pallets team, but it also supports custom renderers.</p> <p>This page covers:</p> <ul> <li> Configuring server-side templating.</li> <li> Returning views using response functions.</li> <li> Returning views with MVC features.</li> <li> Using alternatives to <code>Jinja2</code>.</li> </ul> <p>Info</p> <p>The BlackSheep MVC project template includes a ready-to-use solution having an application with templates and layout configured.</p>"},{"location":"templating/#configuration","title":"Configuration","text":"<p>This example illustrates how to use Jinja2 templating engine with BlackSheep:</p> <pre><code>from blacksheep import Application, get\nfrom blacksheep.server.responses import view\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre> <p>The expected folder structure for this example: <pre><code>\u2b11 app\n     \u2b11 views\n          home.jinja   &lt;-- template file loaded by `view` function\n     __init__.py\n\nserver.py\n</code></pre></p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{example}}&lt;/h1&gt;\n  &lt;p&gt;{{foo}}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"templating/#async-mode","title":"Async mode","text":"<p>It is possible to enable Jinja2 async mode, in the following way:</p> <pre><code>from blacksheep import Application, get\nfrom blacksheep.server.rendering.jinja2 import JinjaRenderer\nfrom blacksheep.server.responses import view_async\nfrom blacksheep.settings.html import html_settings\n\napp = Application()\nhtml_settings.use(JinjaRenderer(enable_async=True))\n\n@get(\"/\")\nasync def home():\n    return await view_async(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre>"},{"location":"templating/#loading-templates","title":"Loading templates","text":"<p>It is possible to load templates by name including <code>.jinja</code>, or without file extension; <code>.jinja</code> extension is added automatically if no extension is specified. The extension must be lowercase.</p> <pre><code>@get(\"/\")\nasync def home(request):\n    return view(\"home.jinja\", {\"example\": \"Hello\", \"foo\": \"World\"})\n\n\n# or...\n\n\n@get(\"/\")\nasync def home(request):\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre>"},{"location":"templating/#helpers-and-filters","title":"Helpers and filters","text":"<p>To configure custom helpers and filters for Jinja, access the renderer through <code>blacksheep.settings.html.html_settings</code>:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.jinja\n\u2514\u2500\u2500 server.py\n</code></pre> <pre><code>from datetime import datetime\n\nfrom blacksheep.server import Application\nfrom blacksheep.server.rendering.jinja2 import JinjaRenderer\nfrom blacksheep.settings.html import html_settings\n\ndef configure_templating(\n    application: Application\n) -&gt; None:\n    \"\"\"\n    Configures server side rendering for HTML views.\n    \"\"\"\n    renderer = html_settings.renderer\n    assert isinstance(renderer, JinjaRenderer)\n\n    def get_copy():\n        now = datetime.now()\n        return \"{} {}\".format(now.year, \"Example\")\n\n    helpers = {\"_\": lambda x: x, \"copy\": get_copy}\n\n    env = renderer.env\n    env.globals.update(helpers)\n</code></pre> <pre><code>&lt;!-- index.jinja --&gt;\n&lt;p&gt;Hello, World!&lt;/p&gt;\n{{ copy() }}\n</code></pre>"},{"location":"templating/#using-alternatives-to-jinja2","title":"Using alternatives to Jinja2","text":"<p>To use alternative classes for server-side rendering:</p> <ol> <li>Define an implementation of <code>blacksheep.server.rendering.abc.Renderer</code></li> <li>Configure it using <code>from blacksheep.settings.html import html_settings</code></li> </ol> <pre><code>from blacksheep.server.csrf import AntiForgeryHandler\nfrom blacksheep.settings.html import html_settings\nfrom blacksheep.server.rendering.abc import Renderer\n\n\nclass CustomRenderer(Renderer):\n\n    def render(self, template: str, model, **kwargs) -&gt; str:\n        \"\"\"Renders a view synchronously.\"\"\"\n        ...\n\n    async def render_async(self, template: str, model, **kwargs) -&gt; str:\n        \"\"\"Renders a view asynchronously.\"\"\"\n        ...\n\n    def bind_anti_forgery_handler(self, handler: AntiForgeryHandler) -&gt; None:\n        \"\"\"\n        Applies extensions for an anti-forgery handler.\n\n        This method can be used to generate HTML fragments containing\n        anti-forgery tokens, for the built-in implementation of AF validation.\n        \"\"\"\n\n\nhtml_settings.use(CustomRenderer())\n</code></pre> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"testing/","title":"Testing a BlackSheep app","text":"<p>This page describes how a BlackSheep web application can be tested, documenting the built-in <code>TestClient</code> class and providing a tutorial that shows how it can be used with <code>pytest</code> to test an API. It covers the following:</p> <ul> <li> How to use the provided <code>TestClient</code>.</li> <li> How to configure tests using <code>pytest</code>.</li> <li> How to run integration tests using a server process.</li> </ul> <p>TL;DR A complete example with testing configured for <code>pytest</code> is available at: ./testing-api. Those who don't want to follow the tutorial on this page can read the code in the example.</p>"},{"location":"testing/#overview-of-the-testclient-class","title":"Overview of the TestClient class","text":"<p>The <code>TestClient</code> class provides useful methods to test a <code>blacksheep</code> application, simulating web requests from an <code>ASGI</code> server. Simulating web requests has the benefit that tests execute fast and don't require a real HTTP Server and actual HTTP client-server interactions. At the same time, they recreate a full end-to-end scenario of how requests are handled by an application server.</p> <p>A basic example of the <code>TestClient</code> would look like this:</p> <pre><code>import asyncio\nfrom blacksheep import Application, get\nfrom blacksheep.testing import TestClient\n\napp = Application()\n\n\n@get(\"/\")\nasync def hello(name: str = \"World\"):\n    return f\"Hello, {name}!\"\n\n\nasync def test():\n    # the application needs to handle its start event, to recreate a valid scenario\n    await app.start()\n\n    client = TestClient(app)\n\n    response = await client.get(\"/\")\n    text = await response.text()\n\n    assert response.status == 200\n    assert text == \"Hello, World!\"\n\n    response = await client.get(\"/\", query={\"name\": \"Foo\"})\n    text = await response.text()\n\n    assert response.status == 200\n    assert text == \"Hello, Foo!\"\n\n    print(\"OK\")\n\n\nasyncio.run(test())\n</code></pre> <p>A test client provides the following methods:</p> Method Description get Simulates an HTTP GET request. post Simulates an HTTP POST request. put Simulates an HTTP PUT request. patch Simulates an HTTP PATCH request. delete Simulates an HTTP DELETE request. head Simulates an HTTP HEAD request. options Simulates an HTTP OPTIONS request. trace Simulates an HTTP TRACE request. <p>Info</p> <p>By default a <code>TestClient</code> simulates web requests creating <code>ASGI</code> scopes, however, it can be configured with a custom implementation of <code>AbstractTestSimulator</code> to generate real HTTP requests against a real HTTP server. For simplicity, this is not documented here.</p>"},{"location":"testing/#tutorial","title":"Tutorial","text":"<p>This tutorial illustrates how to create a basic TODOs API and prepare tests for it, step by step.</p>"},{"location":"testing/#requirements","title":"Requirements","text":"<ul> <li>The requirements described for the getting started tutorial</li> <li>Familiarity with test frameworks and common concepts like <code>fixtures</code>; if you   are not familiar with this subject, read <code>pytest</code> documentation for an   overview (e.g. pytest home, what are   fixtures)</li> <li>Basic knowledge about <code>pydantic</code>   models is a plus, however, the same principles can be applied to Python   built-in <code>dataclasses</code></li> </ul>"},{"location":"testing/#preparing-the-project-structure","title":"Preparing the project structure","text":"<p>Prepare a Python virtual environment, as described in the getting started tutorial. In addition to <code>blacksheep</code> and <code>uvicorn</code>, install the following packages in the virtual environment:</p> <pre><code>pip install pytest pytest-asyncio pydantic\n</code></pre> <p>Then create a basic folder structure, like described by the following tree:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 routes\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 domain.py\n\u2514\u2500\u2500 server.py\n</code></pre> <p>For example, using GNU Bash:</p> <pre><code>mkdir app\ntouch app/app.py\ntouch app/__init__.py\n\nmkdir app/routes\ntouch app/routes/__init__.py\n\ntouch domain.py\ntouch server.py\n</code></pre> <p>Edit <code>domain.py</code> file, to define two domain classes:</p> <pre><code>from pydantic import BaseModel\n\n\nclass ToDo(BaseModel):\n    id: int\n    title: str\n    description: str\n\n\nclass CreateToDoInput(BaseModel):\n    title: str\n    description: str\n</code></pre> <p>Create a <code>todos.py</code> file in <code>app.routes</code> package, that will contain the definition of the TODOs API. Start with the following contents:</p> <pre><code># ./app/routes/todos.py\n\nfrom blacksheep import get, post, delete\nfrom domain import ToDo, CreateToDoInput\n\n\n@get(\"/api/todos\")\nasync def get_todos() -&gt; list[ToDo]:\n    ...\n\n\n@get(\"/api/todos/{todo_id}\")\nasync def get_todo(todo_id) -&gt; ToDo | None:\n    ...\n\n\n@post(\"/api/todos\")\nasync def create_todo(data: CreateToDoInput) -&gt; ToDo:\n    ...\n\n\n@delete(\"/api/todos/{todo_id}\")\nasync def delete_todo(todo_id) -&gt; None:\n    ...\n</code></pre> <p>Create a <code>main.py</code> file in <code>app</code> package, that declares an application:</p> <pre><code>from blacksheep import Application\n\napp = Application()\n</code></pre> <p>And finally a <code>server.py</code> file at the project's root:</p> <pre><code>from app.main import app\n</code></pre>"},{"location":"testing/#navigating-the-api-using-openapi-documentation","title":"Navigating the API using OpenAPI Documentation","text":"<p>At this point, the application can already be started. The API methods are not implemented, yet, so they cannot do anything interesting. However, the framework can generate OpenAPI Documentation and expose a documentation UI.</p> <p>To do so, create a <code>docs.py</code> file in the <code>app</code> package:</p> <pre><code># ./app/docs.py\n\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Demo API\", version=\"0.0.1\"), anonymous_access=True\n)\n\n# include only endpoints whose path starts with \"/api/\"\ndocs.include = lambda path, _: path.startswith(\"/api/\")\n</code></pre> <p>And modify <code>/app/main.py</code> file to configure the generation of OpenAPI Documentation:</p> <pre><code>from blacksheep import Application\n\nfrom .docs import docs  # +++\n\n\napp = Application()\ndocs.bind_app(app)  # +++\n</code></pre> <p>Start the application using the following command:</p> <pre><code>uvicorn server:app --reload --port=44555\n</code></pre> <p>And navigate to the http://127.0.0.1:44555/docs to see the documentation generated automatically by BlackSheep:</p> <p></p> <p>Note how, thanks to type annotations and support for <code>pydantic</code>, blacksheep generates automatically OpenAPI Documentation version 3 for all responses and input request bodies and parameters.</p>"},{"location":"testing/#creating-a-mocked-todos-api","title":"Creating a mocked TODOs API","text":"<p>For the sake of the testing demo, let's mock the implementation of the TODOs API to work with data stored in memory:</p> <pre><code># ./app/routes/todos.py\n\nfrom blacksheep import get, delete, not_found, post\nfrom domain import CreateToDoInput, ToDo\n\n\n_MOCKED: dict[int, ToDo] = {\n    1: ToDo(\n        id=1,\n        title=\"BlackSheep Documentation\",\n        description=\"Update the documentation with information about the new features.\",\n    ),\n    2: ToDo(\n        id=2,\n        title=\"Transfer the documentation\",\n        description=\"Transfer the documentation from Azure DevOps to GitHub.\",\n    ),\n    3: ToDo(\n        id=3,\n        title=\"Mow the grass\",\n        description=\"Like in title.\",\n    ),\n}\n\n\n@get(\"/api/todos\")\nasync def get_todos() -&gt; list[ToDo]:\n    return list(_MOCKED.values())\n\n\n@get(\"/api/todos/{todo_id}\")\nasync def get_todo(todo_id: int) -&gt; ToDo | None:\n    try:\n        return _MOCKED[todo_id]\n    except KeyError:\n        return not_found()  # type: ignore\n\n\n@post(\"/api/todos\")\nasync def create_todo(data: CreateToDoInput) -&gt; ToDo:\n    item = ToDo(id=len(_MOCKED) + 1, title=data.title, description=data.description)\n    _MOCKED[item.id] = item\n    return item\n\n\n@delete(\"/api/todos/{todo_id}\")\nasync def delete_todo(todo_id: int) -&gt; None:\n    try:\n        del _MOCKED[todo_id]\n    except KeyError:\n        pass\n</code></pre> <p>Now that the API is mocked, let's see how to add tests for it.</p>"},{"location":"testing/#using-the-testclient-with-pytest","title":"Using the TestClient with pytest","text":"<p>Create a <code>tests</code> package and the following files:</p> <pre><code>\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 conftest.py\n    \u2514\u2500\u2500 test_todos_api.py\n</code></pre> <p><code>conftest.py</code> is a special file used by <code>pytest</code> to arrange fixtures. Edit this file to include fixtures definition to arrange tests for the web application:</p> <pre><code># ./tests/conftest.py\n\nimport asyncio\n\nimport pytest\nimport pytest_asyncio\nfrom blacksheep.testing import TestClient\nfrom server import app as app_server\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop(request):\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture(scope=\"session\")\nasync def api():\n    await app_server.start()\n    yield app_server\n    await app_server.stop()\n\n\n@pytest_asyncio.fixture(scope=\"session\")\nasync def test_client(api):\n    return TestClient(api)\n</code></pre> <p>Note how the file contains three fixtures:</p> <ol> <li><code>event_loop</code>, for asyncio: it needs to be redefined to support <code>session</code>    scope</li> <li><code>api</code>, which yields an instance of the started web application</li> <li><code>test_client</code>, which returns the instance of <code>TestClient</code> that can be used    to fire web requests on the web application</li> </ol> <p>These fixtures enable testing all request handlers defined in the application.</p> <p>Info</p> <p>\ud83d\udca1 It is possible to apply special configuration to the application server, for example overriding services in the DI container just for tests, for example replacing a class that interacts with a PostgreSQL Server to use instead SQLite for tests.</p> <p>Finally, define a first test for the TODOs API:</p> <pre><code># ./tests/test_todos_api.py\n\nimport pytest\nfrom blacksheep.contents import JSONContent\nfrom blacksheep.testing import TestClient\nfrom domain import CreateToDoInput, ToDo\n\n\n@pytest.mark.asyncio\nasync def test_create_and_get_todo(test_client: TestClient) -&gt; None:\n\n    create_input = CreateToDoInput(\n        title=\"Update documentation\",\n        description=\"Update blacksheep's documentation to describe all new features.\",\n    )\n\n    response = await test_client.post(\n        \"/api/todos\",\n        content=JSONContent(create_input),\n    )\n\n    assert response is not None\n\n    data = await response.json()\n\n    assert data is not None\n    assert \"id\" in data\n\n    todo_id = data[\"id\"]\n    response = await test_client.get(f\"/api/todos/{todo_id}\")\n\n    assert response is not None\n    data = await response.json()\n\n    assert data is not None\n\n    todo = ToDo(**data)\n\n    assert todo.title == create_input.title\n    assert todo.description == create_input.description\n</code></pre> <p>Now it's possible to start the tests using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> <p>If the steps above were done correctly, the test succeeds and <code>pytest</code> produces feedback like in the following picture (using the verbose flag <code>-v</code>):</p> <p></p>"},{"location":"testing/#how-to-run-integration-tests-using-a-server-process","title":"How to run integration tests using a server process.","text":"<p>The following example shows how to configure a <code>@pytest.fixture</code> that starts an <code>uvicorn</code> process in memory to run integration tests against a real <code>ASGI</code> server:</p> <pre><code># example server fixture\n\nimport os\nfrom multiprocessing import Process\nfrom time import sleep\n\nimport pytest\nimport uvicorn\nfrom server import app\n\n\ndef get_sleep_time():\n    # when starting a server process,\n    # a longer sleep time is necessary on Windows\n    if os.name == \"nt\":\n        return 1.5\n    return 0.5\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\ndef _start_server():\n    uvicorn.run(app, host=server_host, port=server_port, log_level=\"debug\")\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef server():\n    server_process = Process(target=_start_server)\n    server_process.start()\n    sleep(get_sleep_time())\n\n    if not server_process.is_alive():\n        raise TypeError(\"The server process did not start!\")\n\n    yield 1\n\n    sleep(1.2)\n    server_process.terminate()\n</code></pre> <p>The same server <code>host</code> and <code>port</code> can then be used with the desired HTTP Client implementation to run tests on the server, to recreate a full HTTP client-server communication.</p> <p>The following code shows an example of <code>@pytest.fixture</code> returning an HTTP client that can make requests to the running servers, using requests library:</p> <pre><code>import requests\nfrom urllib.parse import urljoin\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\nclass ClientSession(requests.Session):\n    def __init__(self, base_url):\n        self.base_url = base_url\n        super().__init__()\n\n    def request(self, method, url, *args, **kwargs):\n        return super().request(method, urljoin(self.base_url, url), *args, **kwargs)\n\n\n@pytest.fixture(scope=\"session\")\ndef session_two(server_host, server_port_two):\n    return ClientSession(f\"http://{server_host}:{server_port_two}\")\n</code></pre> <p>And a full example for the TODO API described in the tutorial could look like the following (the example requires the <code>requests</code> library):</p> <pre><code>import os\nfrom multiprocessing import Process\nfrom time import sleep\nfrom urllib.parse import urljoin\n\nimport pytest\nimport requests\nimport uvicorn\nfrom server import app\n\n\nclass ClientSession(requests.Session):\n    def __init__(self, base_url):\n        self.base_url = base_url\n        super().__init__()\n\n    def request(self, method, url, *args, **kwargs):\n        return super().request(method, urljoin(self.base_url, url), *args, **kwargs)\n\n\ndef get_sleep_time():\n    # when starting a server process,\n    # a longer sleep time is necessary on Windows\n    if os.name == \"nt\":\n        return 1.5\n    return 0.5\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\n@pytest.fixture(scope=\"session\")\ndef client_session():\n    return ClientSession(f\"http://{server_host}:{server_port}\")\n\n\ndef _start_server():\n    uvicorn.run(app, host=server_host, port=server_port, log_level=\"debug\")\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef server():\n    server_process = Process(target=_start_server)\n    server_process.start()\n    sleep(get_sleep_time())\n\n    if not server_process.is_alive():\n        raise TypeError(\"The server process did not start!\")\n\n    yield 1\n\n    sleep(1.2)\n    server_process.terminate()\n\n\n@pytest.mark.asyncio\nasync def test_get(client_session):\n    response = client_session.get(\"/api/todos/1\")\n\n    assert response.status_code == 200\n</code></pre> <p>Info</p> <p>Fixtures can be defined in a dedicated module, to keep the tests code clean.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPAEWRV"},{"location":"websocket/","title":"WebSocket","text":"<p>WebSocket is a technology that enables the creation of a persistent, bi-directional connection between a client and a server. It is commonly used in real-time applications, such as chat apps and similar use cases.</p> <p>BlackSheep can handle incoming WebSocket connections when used with an ASGI server that supports the WebSocket protocol (e.g., Uvicorn or Hypercorn).</p>"},{"location":"websocket/#creating-a-websocket-route","title":"Creating a WebSocket route","text":"<p>To make your request handler function as a WebSocket handler, use the <code>ws</code> decorator or the corresponding <code>add_ws</code> method provided by the app router. Note that the <code>ws</code> decorator does not have a default path pattern, so you must specify one.</p> <p>Route parameters can be used in the same way as with regular request handlers.</p> Using <code>ws</code> decoratorUsing <code>add_ws</code> method <pre><code>from blacksheep import Application, WebSocket, ws\n\napp = Application()\n\n\n@ws(\"/ws/{client_id}\")\nasync def ws_handler(websocket: WebSocket, client_id: str):\n    ...\n</code></pre> <pre><code>from blacksheep import Application, WebSocket\n\napp = Application()\n\n\nasync def ws_handler(websocket: WebSocket, client_id: str):\n    ...\n\n\napp.router.add_ws(\"/ws/{client_id}\", ws_handler)\n</code></pre> <p>When a client attempts to connect to the endpoint, a <code>WebSocket</code> object is bound to a parameter and injected into your handler function.</p> <p>Required function signature.</p> <p>Make sure that your function either has a parameter named websocket or a parameter type annotated with the <code>WebSocket</code> class. Otherwise, the route will not function properly.</p>"},{"location":"websocket/#accepting-the-connection","title":"Accepting the connection","text":"<p>The <code>WebSocket</code> class provides the <code>accept</code> method to accept a connection, allowing you to pass optional parameters to the client. These parameters include headers, which are sent back to the client with the handshake response, and subprotocol, which specifies the protocol your application agrees to use.</p> <p>For more information.</p> <p>The MDN article on writing WebSocket servers has some additional information regarding subprotocols and response headers.</p> <pre><code>@ws(\"/ws\")\nasync def ws_handler(websocket: WebSocket):\n    # Parameters are optional.\n    await websocket.accept(\n        headers=[(b\"x-custom-header\", b\"custom-value\")],\n        subprotocol=\"custom-protocol\"\n    )\n</code></pre> <p>As soon as the connection is accepted, you can start receiving and sending messages.</p>"},{"location":"websocket/#communicating-with-the-client","title":"Communicating with the client","text":"<p>There are three pairs of helper method for communicating with the client: <code>receive_text</code>/<code>send_text</code>, <code>receive_bytes</code>/<code>send_bytes</code> and <code>receive_json</code>/<code>send_json</code>.</p> <p>There is also the <code>receive</code> method that allows for receiving raw WebSocket messages. However, in most cases, you will want to use one of the helper methods.</p> <p>All send methods accept an argument of data to be sent. <code>receive_json</code>/<code>send_json</code> also accepts a mode argument. It defaults to <code>MessageMode.TEXT</code> and can be set to <code>MessageMode.BYTES</code> if, for example, your client sends you encoded JSON strings.</p> <p>Below is a simple example of an echo WebSocket handler.</p> <p>This function will receive a text message sent by the client and echo it back until either the client disconnects or the server shuts down.</p> TextBytesJSON <pre><code>@ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_text()\n        # \"Hello world!\"\n        await websocket.send_text(msg)\n</code></pre> <pre><code>@ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_bytes()\n        # b\"Hello world\"\n        await websocket.send_bytes(msg)\n</code></pre> <pre><code>@ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_json()\n        # {'msg': 'Hello world!'}\n        await websocket.send_json(msg)\n</code></pre>"},{"location":"websocket/#handling-client-disconnect","title":"Handling client disconnect","text":"<p>If a client disconnects, the <code>ASGI</code> server will close the connection and send a corresponding message to your application. When this message is received, the <code>WebSocket</code> object raises the <code>WebSocketDisconnectError</code> exception.</p> <p>You'll likely want to catch it and handle it somehow.</p> <pre><code>from blacksheep import WebSocket, WebSocketDisconnectError, ws\n\n...\n\n@ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    try:\n        while True:\n            msg = await websocket.receive_text()\n            await websocket.send_text(msg)\n    except WebSocketDisconnectError:\n        ... # Handle the disconnect.\n</code></pre>"},{"location":"websocket/#example-chat-application","title":"Example: chat application","text":"<p>Here you can find a basic example app using BlackSheep and VueJS.</p> <p>Last modified on: 2025-04-22 08:29:25</p>RPEWRV"},{"location":"examples/marshmallow/","title":"Using Marshmallow","text":"<p>The following example describes how <code>Marshmallow</code> can be used to implement validation of input bodies from the client. For the sake of simplicity, the example shows a case in which an array of items is validated (the marshmallow scheme is validated using <code>(many=True)</code>). A similar approach can be used with <code>msgspec</code></p> <p>Implementing a generic solution to validate input and produce user-friendly error messages is not in the scope of BlackSheep, but the framework offers ways to integrate with other libraries.</p> <p>This is possible by defining a couple of custom binders, a custom exception, and a custom exception handler like in the example below.</p> <pre><code>from typing import Any, TypeVar\n\nfrom marshmallow import Schema, ValidationError, fields\n\nfrom blacksheep import Application\nfrom blacksheep.messages import Request\nfrom blacksheep.server.bindings import Binder, BoundValue\nfrom blacksheep.server.responses import pretty_json\n\nSchemaType = TypeVar(\"SchemaType\", bound=Schema)\n\n\nclass InvalidBodyError(Exception):\n    \"\"\"\n    Kind of BadRequest exception that includes error details as complex objects.\n    \"\"\"\n\n    def __init__(self, data: Any):\n        super().__init__(\"Invalid payload\")\n        self.details = data\n\n\n# Example Marshmallow schema, from the marshmallow documentation\nclass BandMemberSchema(Schema):\n    name = fields.String(required=True)\n    email = fields.Email()\n\n\n# Example binding for a Marshmallow schema, to be used to obtain a list of objects\nclass FromMultiSchema(BoundValue[SchemaType]):\n    \"\"\"\n    Custom bound value that can be used to describe a list of objects validated using a\n    Marshmallow schema.\n    \"\"\"\n\n\nclass MultiSchemaBinder(Binder):\n    \"\"\"\n    Binder that handles a FromMultiSchema, returning a list of objects from a\n    Marshmallow schema.\n    \"\"\"\n\n    handle = FromMultiSchema\n\n    async def get_value(self, request: Request) -&gt; Any:\n        data = await request.json()\n        try:\n            return self.expected_type(many=True).load(data)\n        except ValidationError as err:\n            raise InvalidBodyError(err.messages)\n\n\napp = Application()\n\n\n@app.exception_handler(InvalidBodyError)\nasync def invalid_body_handler(app, request, exc: InvalidBodyError):\n    return pretty_json(exc.details, 400)\n\n\n@router.post(\"/\")\ndef example(data: FromMultiSchema[BandMemberSchema]):\n    return pretty_json(data.value)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, port=44555, lifespan=\"on\")\n</code></pre> <pre><code>curl -X POST http://127.0.0.1:44555 -H \"Content-Type: application/json\" -d '[{\"id\": 1, \"name\": \"foo\", \"permissions\": []}]'\n{\n    \"0\": {\n        \"permissions\": [\n            \"Unknown field.\"\n        ],\n        \"id\": [\n            \"Unknown field.\"\n        ]\n    }\n}\n\ncurl -X POST http://127.0.0.1:44555 -H \"Content-Type: application/json\" -d '[{\"id\": 1, \"name\": \"foo\", \"email\": \"wrong-value\"}]'\n{\n    \"0\": {\n        \"email\": [\n            \"Not a valid email address.\"\n        ],\n        \"id\": [\n            \"Unknown field.\"\n        ]\n    }\n}\n</code></pre> <p>Last modified on: 2025-04-01 23:22:49</p>RPEWT"},{"location":"versions/migrating-to-v2/","title":"From V1 to V2","text":"<p>This page describes the most relevant differences between version 1 and version 2 of the web framework. The most relevant changes are:</p> <ul> <li> Improved project templates and the <code>blacksheep-cli</code> to bootstrap new projects.</li> <li> Automatic import of <code>routes</code> and <code>controllers</code>.</li> <li> Added functions to support the notion of application environment.</li> <li> Improved dependency injection, with support for alternatives to <code>rodi</code>.</li> <li> Improved server side rendering, with support for alternatives to <code>Jinja2</code>.</li> <li> Added support for dependency injection in authentication and authorization handlers.</li> <li> Removed the <code>@app.route</code> decorator and moved it to the <code>Router</code> class.</li> <li> Improved the <code>Router</code> class to support sub-routers and filters.</li> <li> Improved the OIDC features to support storing tokens in the HTML5 Storage   API instead of cookies.</li> <li> Some classes have been renamed to better follow Python naming conventions.</li> </ul> <p>The full list of changes is at the bottom of this page. It includes changes that were applied to version 1 of the framework, too.</p>"},{"location":"versions/migrating-to-v2/#blacksheep-cli","title":"BlackSheep-CLI","text":"<p>The second version of the framework features improved project templates, with a dedicated CLI for project scaffolding. For more information on the CLI, read More about the CLI.</p> <p></p> <p>The improved project templates also include a strategy to validate settings using <code>Pydantic</code>.</p>"},{"location":"versions/migrating-to-v2/#automatic-import-of-routes-and-controllers","title":"Automatic import of routes and controllers","text":"<p>The second version of the framework includes features to considerably reduce code verbosity when defining routes and controllers.</p> <p>The framework now exposes methods of a default singleton <code>Router</code> instance, to be used to register routes independently from application instantiation. This enables a much cleaner code API, and consistent with the existing API to register controllers.</p> <pre><code>from blacksheep import get, post\n\n\n@get(\"/api/examples\")\nasync def get_examples() -&gt; list[str]:\n    ...\n\n\n@post(\"/api/examples\")\nasync def add_example(self, example: str):\n    ...\n</code></pre> <p>For more information on the above, read Using the default router and other routers.</p> <p>All modules inside <code>routes</code> and <code>controllers</code> packages are imported automatically in v2. Automatic import works relative to where a BlackSheep application is instantiated. In the structure described below, the modules in <code>app.controllers</code> and <code>app.routes</code> namespace are imported automatically when an application is instantiated inside <code>app.main</code>.</p> <pre><code>app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 controllers\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 home.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 example.py\n\u251c\u2500\u2500 routes\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 example.py\n\u2514\u2500\u2500main.py\n</code></pre> <p>The difference in code verbosity is considerable, because previously defining routes and controllers explicitly was not sufficient to have them registered in applications.</p>"},{"location":"versions/migrating-to-v2/#notion-of-application-environment","title":"Notion of application environment","text":"<p>The namespace <code>blacksheep.server.env</code> provides an abstraction layer to support the notion of application environment. It provides functions that can be used to apply logic depending on whether the application is running for local development, or a different kind of environment (e.g. <code>dev</code>, <code>test</code>, <code>prod</code>).</p> <p>These functions use the environment variable <code>APP_ENV</code> to determine the type of environment, defaulting to <code>production</code> if such variable is missing.</p> <pre><code>from blacksheep.server.env import is_development, is_production\n\n# is_development returns true if APP_ENV (lower) is in {\"local\", \"dev\", \"development\"}\n# is_production returns true if APP_ENV (lower) is missing or in {\"prod\", \"production\"}\n</code></pre>"},{"location":"versions/migrating-to-v2/#changes-to-dependency-injection","title":"Changes to dependency injection","text":"<p>In v2, <code>rodi</code> and BlackSheep have been modified to enable alternative implementations of dependency injection. <code>rodi</code> now defines a <code>ContainerProtocol</code> with a basic API to register and resolve dependencies, and BlackSheep relies on that protocol instead of its specific implementation in <code>rodi</code>.</p> <p>For more information, read the dedicated part in the Dependency Injection page.</p>"},{"location":"versions/migrating-to-v2/#changes-to-server-side-rendering","title":"Changes to server side rendering","text":"<p>BlackSheep v2 has been modified to not be strictly reliant on <code>Jinja2</code> for template rendering. To achieve this, two new namespaces have been added:</p> <ul> <li><code>blacksheep.server.rendering.abc</code>, defining an abstract <code>Renderer</code> class,</li> <li><code>blacksheep.settings.html</code>, defining a code API to control renderer settings</li> </ul> <p>The code API of the <code>view</code> and <code>view_async</code> functions in the <code>blacksheep.server.responses</code> namespace has been improved, using the renderer configured in <code>blacksheep.settings.html</code>.</p> <p>The following examples show how a view can be rendered, having a template defined at the path <code>views/home.jinja</code>:</p> Now in v2Before in v1 <pre><code>from blacksheep import Application, get\nfrom blacksheep.server.responses import view\n\napp = Application()\n\n\n@get(\"/\")\ndef home():\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre> <pre><code>from blacksheep import Application\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\napp = Application()\nget = app.router.get\n\nview = use_templates(app, loader=PackageLoader(\"app\", \"views\"))\n\n\n@get(\"/\")\ndef home():\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre> <p>Template:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n&lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{{example}}&lt;/h1&gt;\n        &lt;p&gt;{{foo}}&lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>For more information, read the updated page describing Server Side Rendering.</p>"},{"location":"versions/migrating-to-v2/#improvements-to-authentication-and-authorization-handlers","title":"Improvements to authentication and authorization handlers","text":"<p><code>GuardPost</code> has been modified to support the new <code>ContainerProtocol</code> in <code>rodi</code>, and authentication and authorization handlers now support dependency injection.</p>"},{"location":"versions/migrating-to-v2/#removed-the-approute-method","title":"Removed the app.route method","text":"<p>The <code>Application</code> class was modified to remove the <code>route</code> method, which is now available in the <code>Router</code> class. The reason for this change it to make the code API consistent between methods used to register request handlers. The <code>route</code> method of the singleton default <code>Router</code> instance is also exposed by <code>blacksheep</code> package like the other methods to register request handlers.</p> Now in v2Before in v1 <pre><code>from blacksheep import Application, route\n\napp = Application()\n\n\n@route(\"/\")\ndef home():\n    return \"Example\"\n</code></pre> <pre><code>from blacksheep import Application\n\napp = Application()\n\n\n@app.route(\"/\")\ndef home():\n    return \"Example\"\n</code></pre>"},{"location":"versions/migrating-to-v2/#improvements-to-the-router-class","title":"Improvements to the Router class","text":"<p>The <code>Router</code> class has been improved to support sub-routers and filters. For more information, read Using sub-routers and filters.</p>"},{"location":"versions/migrating-to-v2/#improvements-to-oidc-support","title":"Improvements to OIDC support","text":"<p>The functions that implement OpenID Connect (OIDC) support have been improved to support storing tokens (id_token, access_token, refresh_token) in any kind of store, and with built-in support for the HTML5 Storage API.</p> <p>Examples in GitHub</p> <p>Refer to the OIDC examples</p> <p>The following partial example shows how to use the <code>use_openid_connect</code> function to configure a web app to:</p> <ul> <li>use OpenID Connect with Entra ID to implement authentication</li> <li>store <code>id_token</code>, <code>access_token</code>, and <code>refresh_token</code> using the HTML5   Storage API</li> <li>configure the back-end API to use <code>JWT Bearer</code> authentication (clients must   send requests with <code>Authorization: Bearer &lt;JWT&gt;</code> headers)</li> </ul> <pre><code>\"\"\"\nThis example shows how to configure an OpenID Connect integration having tokens\nexchanged with the client using the HTML5 Storage API, instead of response cookies.\nThis scenario enables better reusability of web APIs.\nSee how the id_token is used in ./static/index.html to authenticate following requests\n('Authorization: Bearer ***' headers), and how the refresh token endpoint can be used\nto obtain fresh tokens.\n\"\"\"\nimport uvicorn\nfrom blacksheep.server.application import Application\nfrom blacksheep.server.authentication.jwt import JWTBearerAuthentication\nfrom blacksheep.server.authentication.oidc import (\n    JWTOpenIDTokensHandler,\n    OpenIDSettings,\n    use_openid_connect,\n)\nfrom dotenv import load_dotenv\n\nfrom common.routes import register_routes\nfrom common.secrets import Secrets\n\nload_dotenv()\nsecrets = Secrets.from_env()\napp = Application(show_error_details=True)\n\n\nAUTHORITY = (\n    \"https://login.microsoftonline.com/b62b317a-19c2-40c0-8650-2d9672324ac4/v2.0\"\n)\nCLIENT_ID = \"499adb65-5e26-459e-bc35-b3e1b5f71a9d\"\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=AUTHORITY,\n        client_id=CLIENT_ID,\n        client_secret=secrets.aad_client_secret,\n        scope=(\n            \"openid profile offline_access email \"\n            \"api://65d21481-4f1a-4731-9508-ad965cb4d59f/example\"\n        ),\n    ),\n    auth_handler=JWTOpenIDTokensHandler(\n        JWTBearerAuthentication(\n            authority=AUTHORITY,\n            valid_audiences=[CLIENT_ID],\n        ),\n    ),\n)\n\nregister_routes(app, static_home=True)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=5000, log_level=\"debug\")\n</code></pre>"},{"location":"versions/migrating-to-v2/#changes-to-follow-naming-conventions","title":"Changes to follow naming conventions","text":"<p>Some classes have been renamed to better follow Python naming conventions. For example the aliases 'HtmlContent' and 'JsonContent' that were kept for backward compatibility in <code>v1</code>, as alternative names for <code>HTMLContent</code> and <code>JSONContent</code>, were removed in <code>v2</code>.</p>"},{"location":"versions/migrating-to-v2/#list-of-changes","title":"List of changes","text":"<p>The full list of changes in alpha versions released for <code>v2</code>:</p> <ul> <li>Renames the <code>plugins</code> namespace to <code>settings</code>.</li> <li>Upgrades <code>rodi</code> to v2, which includes improvements.</li> <li>Adds support for alternative implementation of containers for dependency   injection, using the new <code>ContainerProtocol</code> in <code>rodi</code>.</li> <li>Upgrades <code>guardpost</code> to v1, which includes support for   dependency injection in authentication handlers and authorization requirements.</li> <li>Adds support for Binders instantiated using dependency injection. However,   binders are still instantiated once per request handler and are still   singletons.</li> <li>Adds a method to make the <code>Request</code> object accessible through dependency   injection (<code>register_http_context</code>). This is not a recommended practice,   but it can be desired in some circumstances.</li> <li>Removes the direct dependency on <code>Jinja2</code> and adds support for alternative   ways to achieve Server Side Rendering (SSR) of HTML; however, <code>Jinja2</code> is still   the default library if the user doesn\u00b4t specify how HTML should be rendered.</li> <li>Adds options to control <code>Jinja2</code> settings through environment variables.</li> <li>Removes the deprecated <code>ServeFilesOptions</code> class.</li> <li>Improves how custom binders can be defined, reducing code verbosity for   custom types. This is an important feature to implement common validation of   common parameters across multiple endpoints.</li> <li>Adds support for binder types defining OpenAPI Specification for their   parameters.</li> <li>Fixes bug #305 (<code>ClientSession ssl=False</code> not working as intended).</li> <li>Refactors the classes for OpenID Connect integration to support alternative   ways to share tokens with clients, and JWT Bearer token authentication out   of the box, in alternative to cookie-based authentication.</li> <li>It adds built-in support for storing tokens (<code>id_token</code>, <code>access_token</code>, and   <code>refresh_token</code>) using the HTML5 Storage API (supporting <code>localStorage</code> and   <code>sessionStorage</code>). Refresh tokens, if present, are automatically protected to   prevent leaking. See the OIDC   examples for   more information.</li> <li>Renames <code>blacksheep.server.authentication.oidc.TokensStore</code> to <code>TokensStore</code>.</li> <li>Removes the <code>tokens_store</code> parameter from the <code>use_openid_connect</code> method;   it is still available as an optional parameter of the two built-in classes   used to handle tokens.</li> <li>Replaces <code>request.identity</code> with <code>request.user</code>. The property <code>identity</code> is   still kept for backward compatibility, but it will be removed in <code>v3</code>.</li> <li>Removes 'HtmlContent' and 'JsonContent' that were kept as alternative names   for <code>HTMLContent</code> and <code>JSONContent</code>.</li> <li>Refactors the <code>ClientSession</code> to own by default a connections pool, if none   is specified for it. The connections pool is automatically disposed of when   the client is exited, if it was created for the client.</li> <li>Makes the <code>ClientSession</code> more user-friendly, supporting headers defined as   <code>dict[str, str]</code> or <code>list[tuple[str, str]]</code>.</li> <li>Improves the type annotations of the <code>ClientSession</code>.</li> <li>Corrects a bug in the <code>ClientSession</code> that would cause a task lock when the   connection is lost while downloading files.</li> <li>Corrects a bug in the <code>ClientSession</code> causing <code>set-cookie</code> headers to not be   properly handled during redirects.</li> <li>Renames the client connection pool classes to remove the prefix \"Client\".</li> <li>Corrects bug of the <code>Request</code> class that would prevent setting <code>url</code> using a   string instead of an instance of <code>URL</code>.</li> <li>Corrects bug of the <code>Request</code> class that prevented the <code>host</code> property from   working properly after updating <code>url</code> (causing <code>follow_redirects</code> to not work   properly in <code>ClientSession</code>.</li> <li>Upgrades the <code>essentials-openapi</code> dependency, fixing #316.</li> <li>Corrects the <code>Request</code> class to not generate more than one <code>Cookie</code> header   when multiple cookies are set, to respect the specification.</li> <li>Adds <code>@app.lifespan</code> to support registering objects that must be initialized   at application start, and disposed of at application shutdown.   The solution supports registering as many objects as desired.</li> <li>Adds features to handle <code>cache-control</code> response headers: a decorator for   request handlers and a middleware to set a default value for all <code>GET</code>   requests resulting in responses with status <code>200</code>.</li> <li>Adds features to control <code>cache-control</code> header for the default document   (e.g. <code>index.html</code>) when serving static files;   see issue 297.</li> <li>Fixes bug in <code>sessions</code> that prevented updating the session data when using   the <code>set</code> and <code>__delitem__</code> methods;   scottrutherford's contribution.</li> </ul> <p><code>@app.lifespan</code> example:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.client.session import ClientSession\n\napp = Application()\n\n\n@app.lifespan\nasync def register_http_client():\n    async with ClientSession() as client:\n        print(\"HTTP client created and registered as singleton\")\n        app.services.register(ClientSession, instance=client)\n        yield\n\n    print(\"HTTP client disposed of\")\n\n\n@router.get(\"/\")\nasync def home(http_client: ClientSession):\n    print(http_client)\n    return {\"ok\": True, \"client_instance_id\": id(http_client)}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=44777, log_level=\"debug\", lifespan=\"on\")\n</code></pre> <ul> <li>Adds support for user-defined filters for server routes (<code>RouteFilter</code> class).</li> <li>Adds built-in support for routing based on request headers.</li> <li>Adds built-in support for routing based on request query parameters.</li> <li>Adds built-in support for routing based on host header value.</li> <li>Adds a <code>query.setter</code> to the <code>Request</code> class, to set queries using   <code>dict[str, str | sequence[str]]</code> as input.</li> <li>The functions registered to application events don't need anymore to define   the <code>app</code> argument (they can be functions without any argument).</li> <li>Adds `Cache-Control: no-cache, no-store' to all responses generated for the   OpenID Connect flow.</li> <li>Adds support for automatic import of modules defined under <code>controllers</code> and   <code>routes</code> packages, relative to where the <code>Application</code> class is instantiated.   Fix #334.</li> <li>Adds a <code>GzipMiddleware</code> that can be used to enable <code>gzip</code> compression, using   the built-in module. Contributed by @tyzhnenko </li> <li>Improves how tags are generated for OpenAPI Documentation: adds the   possibility to document tags explicitly and control their order, otherwise   sorts them alphabetically by default, when using controllers or specifying   tags for routes. Contributed by @tyzhnenko </li> <li>Adds a strategy to control features depending on application environment:   <code>is_development</code>, <code>is_production</code> depending on <code>APP_ENV</code> environment   variable. For more information, see Defining application   environment.</li> <li>Makes the client <code>ConnectionPools</code> a context manager, its <code>__exit__</code> method   closes all its <code>TCP-IP</code> connections.</li> <li>Improves exception handling so it is possible to specify how specific types   of <code>HTTPException</code> must be handled (#342).</li> <li>Improves the error message when a list of objects if expected for an incoming   request body, and a non-list value is received (#341).</li> <li>Replaces <code>chardet</code> and <code>cchardet</code> with <code>charset-normalizer</code>. Contributed by   @mementum.</li> <li>Upgrades all dependencies.</li> <li>Adopts <code>pyproject.toml</code>.</li> <li>Fixes bug in CORS handling when multiple origins are   allowed.</li> <li>Adds a <code>Vary: Origin</code> response header for CORS requests when the value of   <code>Access-Control-Allow-Origin</code> header is a specific URL.</li> <li>Adds algorithms parameter to JWTBearerAuthentication constructor, by @tyzhnenko.</li> <li>Improves the code API to define security definitions in OpenAPI docs, by @tyzhnenko.</li> <li>Applies a correction to the auto-import function for routes and controllers.</li> <li>Add support for <code>StreamedContent</code> with specific content length; fixing   #374 both on the client   and the server side.</li> <li>Fix #373, about missing   closing ASGI message when an async generator does not yield a closing empty   bytes sequence (<code>b\"\"</code>).</li> <li>Make version dynamic in <code>pyproject.toml</code>, simplifying how the version can be   queried at runtime (see #362).</li> <li>Fix #372. Use the ASGI   scope <code>root_path</code> when possible, as <code>base_path</code>.</li> <li>Fix #371. Returns status   403 Forbidden when the user is authenticated but not authorized to perform an   action.</li> <li>Fixes <code>TypeError</code> when writing a request without a host header.</li> <li>Add support for <code>Pydantic</code> <code>v2</code>: meaning feature parity with support for   Pydantic v1 (generating OpenAPI Documentation).</li> <li>Add support for <code>Union</code> types in sub-properties of request handlers input and   output types, for generating OpenAPI Documentation, both using simple classes   and Pydantic #389</li> <li>Resolves bug in <code>2.0a10</code> caused by incompatibility issue with <code>Cython 3</code>.</li> <li>Pins <code>Cython</code> to <code>3.0.2</code> in the build job.</li> <li>Fixes bug #394, causing the <code>Content</code> max body size to be 2147483647.   (C int max value). Reported and fixed by @thomafred.</li> <li>Add support for <code>.jinja</code> extension by @thearchitector.</li> <li>Makes the <code>.jinja</code> extension default for Jinja templates.</li> <li>Adds support for Python 3.12, by @bymoye</li> <li>Replaces <code>pkg_resources</code> with <code>importlib.resources</code> for all supported Python   versions except for <code>3.8</code>.</li> <li>Runs tests against Pydantic <code>2.4.2</code> instead of Pydantic <code>2.0</code> to check   support for Pydantic v2.</li> <li>Adds <code>.webp</code> and <code>.webm</code> to the list of extensions of files that are served   by default.</li> </ul> <p>Last modified on: 2025-04-22 08:29:25</p>RPEW"}]}