{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BlackSheep is an asynchronous web framework to build event based web applications with Python.","text":"<pre><code>pip install blacksheep\n</code></pre>"},{"location":"#blacksheep-offers","title":"BlackSheep offers...","text":"<ul> <li>A rich code API, based on dependency injection and inspired by Flask and   ASP.NET Core</li> <li>A typing-friendly codebase, which enables a comfortable development   experience thanks to hints when coding with IDEs</li> <li>Built-in generation of OpenAPI Documentation, supporting version 3, YAML, and   JSON</li> <li>A cross platform framework, using the most modern versions of Python</li> <li>Good performance</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>To get started with BlackSheep, read these tutorials:</p> <ul> <li>Basics</li> <li>The MVC template</li> </ul> <p>Last modified on: 2023-11-19 11:42:25</p>"},{"location":"about/","title":"About BlackSheep","text":"<p>BlackSheep is a web framework for Python asyncio designed to facilitate the implementation of stateless APIs and general purpose web applications. It is inspired by Flask and ASP.NET Core; it recreates several features from both these web frameworks. The concept of automatic binding of request parameters by request handler's signature and dependency injection of required services (as it happens in ASP.NET Core) is what makes BlackSheep unique today, in the context of Python web frameworks.</p> <p>The project, as several other web frameworks for Python, is the fruit of the creative ferment around Yury Selivanov\u2019s work, and the article uvloop: Blazing fast Python networking from 2016.</p> <p>The project originally included an implementation of HTTP Server, but this was removed, and the web framework was abstracted from an exact HTTP Server and made compatible with ASGI HTTP Servers. This was a good move because the effort on the project can stay focused on higher-level features, while benefitting from the existing ecosystem and help from the Python community in implementing HTTP Servers (e.g. support for HTTP2).</p>"},{"location":"about/#the-projects-home","title":"The project's home","text":"<p>The project is hosted in GitHub, handled following DevOps good practices, features 100% code coverage, and is published to pypi.org.</p> <p> </p>"},{"location":"about/#why-the-name-blacksheep","title":"Why the name BlackSheep","text":"<p>The name BlackSheep was chosen for two reasons:</p> <ul> <li>to refer to the \"black sheep\" idiom, used to describe one who is unlike   other members of a family, group, or organization, sometimes due to   intentional   rebelliousness -   especially for the choice of giving so much importance to dependency   injection (which is not very popular in Python community), asynchronous   coding and type annotations (which are still debated upon in Python   community), and for being a Python web framework inspired by ASP.NET\u00a0Core.</li> <li>as a tribute to the song The Sinking Belle (Black Sheep) of the album   Altar, by Boris and   Sunn\u00a0O))).</li> </ul> <p>Last modified on: 2022-01-29 11:24:25</p>"},{"location":"anti-request-forgery/","title":"Preventing Cross-Site Request Forgery (XSRF/CSRF)","text":"<p>Cross-site request forgery, also known as XSRF or CSRF, is a kind of attack that exploits situations in which browsers automatically include credentials in web requests.</p> <p>Example of such situations are:</p> <ul> <li>Cookies are automatically included in web requests, so if an application uses   cookie-based authentication, credentials are sent automatically</li> <li>After a user signs in with Basic or Digest authentication, the browser automatically   sends the credentials until the session ends</li> </ul> <p>If a web application uses cookie based authentication or other features that cause credentials to be automatically included in web requests, it requires anti-forgery measures.</p> <p>BlackSheep implements built-in support for anti request forgery validation, this page describes how to use the built-in solution.</p> <p>Tip</p> <p>Applications that store access tokens (for example JWTs) in the HTML5 storage and include them in <code>Authorization: Bearer {...}</code> headers, are not vulnerable to CSRF and do not require anti-forgery measures.</p>"},{"location":"anti-request-forgery/#how-to-use-the-built-in-anti-forgery-validation","title":"How to use the built-in anti-forgery validation","text":"<p>To enable anti-forgery validation, use the module <code>blacksheep.server.csrf</code>:</p> <pre><code>from blacksheep import Application, FromForm\nfrom blacksheep.server.csrf import use_anti_forgery\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\n\napp = Application(show_error_details=True)\n\nuse_templates(app, PackageLoader(\"app\", \"views\"))\n\nuse_anti_forgery(app)\n</code></pre> <p>The call to <code>use_anti_forgery(app)</code> configures a middleware that can issue and validate anti-forgery tokens, and extensions for Jinja2 templates to render anti-forgery tokens in HTML templates. It is important to configure templating before anti-forgery because the latter configures the extensions on the Jinja2 environment.</p> <p>Consider an example having this folder structure:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.html\n\u2514\u2500\u2500 server.py\n</code></pre> <p>Where <code>server.py</code> contains the following code:</p> <pre><code>from blacksheep import Application, FromForm\nfrom blacksheep.server.csrf import use_anti_forgery\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\n\napp = Application(show_error_details=True)\n\nrender = use_templates(app, PackageLoader(\"app\", \"views\"))\n\nuse_anti_forgery(app)\n\n\n@app.router.get(\"/\")\nasync def home(request):\n    return render(\"index\", {}, request=request)\n\n\nclass CreateUserInput:\n    def __init__(self, username: str, **kwargs):\n        self.username = username\n\n\n@app.router.post(\"/user\")\nasync def create_user(data: FromForm[CreateUserInput]):\n\"\"\"Calls to this endpoint require an anti-forgery token.\"\"\"\n    return {\"example\": True, \"username\": data.value.username}\n</code></pre> <p>And <code>index.html</code> contains the following template:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"/user\" method=\"post\"&gt;\n        {% af_input %}\n        &lt;input type=\"text\" name=\"username\" /&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The <code>{% af_input %}</code> custom tag is used to render an HTML input element containing an anti-forgery token. The built-in solution uses the Double-Token strategy: when an anti-forgery token is required to render HTML for a response, a corresponding HTTP-only cookie is configured for the response. The value of the cookie and the control parameter are matched in following requests for validation. Contextually, response headers are also set to protect the HTML view against click-jacking and to forbid iframes.</p> <p>Alternative tags</p> <p>In alternative to <code>{% af_input %}</code>, it is possible to use the tag <code>{% csrf_input %}</code> (like Django). However, <code>af_input</code> is recommended since the objective of the tag is to obtain an input element containing an anti-forgery token, not to achieve Cross-Site Request Forgery!</p> <p>An example of rendered view looks like the following:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"/user\" method=\"post\"&gt;\n        &lt;input type=\"hidden\" name=\"__RequestVerificationToken\" value=\"IlY2ejJ2MmQyWkZoUVo0ekxLdE9WVU9wQzhtR0dKbDNrdm1KVlc2SGwi.kAXPtBV3gFePzQQXRd0cO9fWOt0\" /&gt;\n        &lt;input type=\"text\" name=\"username\" /&gt;\n        &lt;input type=\"submit\" value=\"Submit\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Validation is applied by default to all <code>DELETE PATCH POST PUT</code> web requests. Requests using other methods are not validated as they are not supposed to change the state and should execute read-only operations.</p> <p>Important note about tokens generation</p> <p>Tokens are signed using symmetric encryption. For your production environments, configure application secrets using environment variables as described in data protection.</p>"},{"location":"anti-request-forgery/#how-to-send-the-anti-forgery-token","title":"How to send the anti-forgery token","text":"<p>The anti-forgery token can be sent to the server in one of these ways:</p> Location Parameter Name Form parameter <code>__RequestVerificationToken</code> Header <code>RequestVerificationToken</code> <p>To use custom parameter names, refer to the <code>AntiForgeryHandler</code> class in <code>blacksheep.server.csrf</code>.</p>"},{"location":"anti-request-forgery/#example-using-controllers","title":"Example using Controllers","text":"<pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 home\n\u2502\u00a0\u00a0      \u00a0\u00a0 \u2514\u2500\u2500 index.html\n\u2514\u2500\u2500 server.py\n</code></pre> <p><code>server.py</code></p> <pre><code>from blacksheep import Application, FromForm\nfrom blacksheep.server.controllers import Controller, get, post\nfrom blacksheep.server.csrf import use_anti_forgery\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\napp = Application(show_error_details=True)\n\nuse_templates(app, PackageLoader(\"app\", \"views\"))\n\nuse_anti_forgery(app)\n\n\nclass CreateUserInput:\n    def __init__(self, username: str, **kwargs):\n        self.username = username\n\n\nclass Home(Controller):\n    @get(\"/\")\n    async def index(self, request):\n        return self.view(\"index\", {}, request=request)\n\n    @post(\"/user\")\n    async def create_user(self, data: FromForm[CreateUserInput]):\n\"\"\"Calls to this endpoint require an anti-forgery token.\"\"\"\n        return {\"example\": True, \"username\": data.value.username}\n</code></pre> <p><code>index.html</code> (like in the previous example).</p>"},{"location":"anti-request-forgery/#rendering-anti-forgery-tokens-without-input-elements","title":"Rendering anti-forgery tokens without input elements","text":"<p>The tag <code>{% af_token %}</code> can be used to render an anti-forgery value without rendering an HTML input element. For example to render it inside JavaScript:</p> <pre><code>&lt;script&gt;\nEXAMPLE = {\"token\": \"{% af_token %}\"}\n&lt;/script&gt;\n</code></pre>"},{"location":"anti-request-forgery/#excluding-request-handlers-from-validation","title":"Excluding request handlers from validation","text":"<p>Use the <code>ignore_anti_forgery</code> decorator to exclude particular request handlers from anti-forgery validation:</p> <pre><code>from blacksheep.server.csrf import ignore_anti_forgery\n\n\n@ignore_anti_forgery()\n@app.router.post(\"/example\")\nasync def create_example():\n\"\"\"This endpoint does not require an anti-forgery token.\"\"\"\n</code></pre>"},{"location":"anti-request-forgery/#custom-antiforgeryhandler-classes","title":"Custom AntiForgeryHandler classes","text":"<p>The following example shows how to override methods of the <code>AntiForgeryHandler</code> class:</p> <pre><code>from blacksheep.server.csrf import AntiForgeryHandler, use_anti_forgery\n\n\nclass CustomAntiForgeryHandler(AntiForgeryHandler):\n    pass\n\n\nuse_anti_forgery(app, handler=CustomAntiForgeryHandler())\n</code></pre> <p>Last modified on: 2022-03-13 13:09:28</p>"},{"location":"application/","title":"The Application class","text":"<p>The <code>Application</code> class in BlackSheep is responsible of handling the application life cicle (start, working state, stop), routing, web requests, exceptions. This page describes details of the <code>Application</code> class:</p> <ul> <li> How to handle errors.</li> <li> Application events and life cycle.</li> </ul>"},{"location":"application/#handling-errors","title":"Handling errors","text":"<p>BlackSheep catches any unhandled exception that happens during the execution of request handlers, producing a <code>HTTP 500 Internal Server Error</code> response. To see this in practice, start an application like the following:</p> <pre><code>from blacksheep import Application\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\ndef crash_test():\n    raise Exception(\"Crash test\")\n</code></pre> <p>And observe how a request to its root produces a response with HTTP status 500, and the text \"Internal server error\".</p> <p>Exception details are hidden to the client by default: it would be a security issue if the web application returned error details to the client. However, while developing and occasionally while investigating issues, it is useful to be able to obtain error details directly from the web requests that are failing. To enable error details, update the app declaration as follows:</p> <pre><code>app = Application(show_error_details=True)\n</code></pre> <p>Now the application returns the details of the exception with the full stack trace, serving a page like the following:</p> <p></p> <p>Consider using environmental variables to handle this kind of settings that can vary across environments. For example:</p> <pre><code>import os\nfrom blacksheep import Application\n\napp = Application(show_error_details=bool(os.environ.get(\"SHOW_ERROR_DETAILS\", None)))\nget = app.router.get\n\n\n@get(\"/\")\ndef crash_test():\n    raise Exception(\"Crash test\")\n</code></pre> <p>Info</p> <p>BlackSheep project templates use a library to handle application settings and configuration roots. Consider using <code>essentials-configuration</code> for this.</p>"},{"location":"application/#configuring-exceptions-handlers","title":"Configuring exceptions handlers","text":"<p>The BlackSheep <code>Application</code> object has a <code>exceptions_handlers</code> dictionary that defines how errors should be handled. When an exception happens while handling a web request and reaches the application, the application checks if there is a matching handler for that kind of exception. An exception handler is defined as a function with the following signature:</p> <pre><code>from blacksheep import Request, Response\n\nasync def exception_handler(self, request: Request, exc: Exception) -&gt; Response:\n    pass\n</code></pre> <p>In the exception below <pre><code>class CustomException(Exception):\n    pass\n\nasync def exception_handler(self, request, exc: CustomException):\n    nonlocal app\n    assert self is app\n    assert isinstance(exc, CustomException)\n    return Response(200, content=TextContent('Called'))\n\n\n# Register the exception handler for the CustomException type:\napp.exceptions_handlers[CustomException] = exception_handler\n\n\n@app.router.get(b'/')\nasync def home(request):\n    # of course, the exception can be risen at any point\n    # for example in the business logic layer\n    raise CustomException()\n</code></pre></p> <p>Exceptions inheriting from <code>HTTPException</code> can be mapped to handlers by their type or by their status code, using <code>int</code> keys; while user defined exceptions are mapped to handlers by their type.</p> <p>When an exception handler is registered for a type of exception, all subclasses are also handled by that handler. It is however possible to define a more specific handler for one of the descendant classes.</p>"},{"location":"application/#configuring-exception-handlers-using-decorators","title":"Configuring exception handlers using decorators","text":"<p>It is also possible to register exception handlers using decorators, instead of interacting with <code>app.exceptions_handlers</code> dictionary:</p> <pre><code>class CustomException(Exception):\n    pass\n\n\n@app.exception_handler(CustomException)\nasync def handler_example(self, request, exc: CustomException):\n    ...\n</code></pre>"},{"location":"application/#overriding-the-default-exception-handler-for-unhandled-exceptions","title":"Overriding the default exception handler for unhandled exceptions","text":"<p>To override how unhandled exceptions are handled, define a custom <code>Application</code> class overriding its <code>handle_internal_server_error</code> method, like in the following example:</p> <pre><code>from blacksheep import Application, json\nfrom blacksheep.messages import Request\n\n\nclass MyApp(Application):\n    async def handle_internal_server_error(self, request: Request, exc: Exception):\n        # TODO: handle this like you wish!\n        return json({\"message\": \"Oh, no!\"}, 500)\n</code></pre>"},{"location":"application/#application-events","title":"Application events","text":"<p>A BlackSheep application exposes three events: on_start, after_start, on_stop. These events can be used to configure callbacks and services that depend on application lifecycle. The application class also offers a useful method to configure objects that need to be initialized when the application starts, and disposed when the application stops: lifespan.</p>"},{"location":"application/#using-the-lifespan-decorator","title":"Using the lifespan decorator","text":"<p>The <code>Application.lifespan</code> method can be used to register objects bound to the application life cycle. Common examples of such objects are HTTP clients and database clients, since they use connection pools that can be initialized and must be disposed when the application stops.</p> <p>The following example illustrates how to use the <code>@app.lifespan</code> decorator to create an HTTP <code>ClientSession</code> that will be disposed when the application stops. Note how the instance of <code>ClientSession</code> is also bound to application services, so that it can be injected into request handlers that need it.</p> <pre><code>import asyncio\nfrom blacksheep import Application\nfrom blacksheep.client.pool import ClientConnectionPools\nfrom blacksheep.client.session import ClientSession\n\napp = Application()\n\n\n@app.lifespan\nasync def register_http_client():\n    async with ClientSession(\n        pools=ClientConnectionPools(asyncio.get_running_loop())\n    ) as client:\n        print(\"HTTP client created and registered as singleton\")\n        app.services.register(ClientSession, instance=client)\n        yield\n\n    print(\"HTTP client disposed\")\n\n\n@app.router.get(\"/\")\nasync def home(http_client: ClientSession):\n    print(http_client)\n    return {\"ok\": True, \"client_instance_id\": id(http_client)}\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, host=\"127.0.0.1\", port=44777, log_level=\"debug\", lifespan=\"on\")\n</code></pre> <p>Info</p> <p>The method leverages <code>contextlib.asynccontextmanager</code>. What is defined before the <code>yield</code> statement executes when the application starts, and what is defined after the <code>yield</code> statement executes when the application stops.</p> <p>The following example illustrates how a <code>redis-py</code> connection can be disposed using the same method:</p> <pre><code>import redis.asyncio as redis\n\n...\n\n@app.lifespan\nasync def configure_redis():\n\"\"\"\n    Configure an async Redis client, and dispose its connections when the\n    application stops.\n    See:\n    https://redis.readthedocs.io/en/stable/examples/asyncio_examples.html\n    \"\"\"\n    connection = redis.Redis()\n    print(f\"Ping successful: {await connection.ping()}\")\n\n    app.services.register(redis.Redis, instance=connection)\n\n    yield connection\n\n    print(\"Disposing the Redis connection pool...\")\n    await connection.close()\n</code></pre> <p>Example using Redis</p> <p>The <code>BlackSheep-Examples</code> repository includes an example where <code>Redis</code> is used to store access tokens and refresh tokens obtained using <code>OpenID Connect</code>: example. For more information on <code>redis-py</code> and its async interface, refer to its official documentation.</p>"},{"location":"application/#on_start","title":"on_start","text":"<p>This event should be used to configure things such as new request handlers, and service registered in <code>app.services</code>, such as database connection pools, HTTP client sessions.</p>"},{"location":"application/#after_start","title":"after_start","text":"<p>This event should be used to configure things that must happen after request handlers are normalized. At this point, the application router contains information about actual routes handled by the web application, and routes can be inspected. For example, the built-in generation of OpenAPI Documentation generates the API specification file at this point.</p>"},{"location":"application/#on_stop","title":"on_stop","text":"<p>This event should be used to fire callbacks that need to happen when the application is stopped. For example, disposing of services that require disposal, such as database connection pools, HTTP client sessions using connection pools.</p>"},{"location":"application/#application-life-cycle","title":"Application life cycle","text":"<p>Refer to the following diagram to know more about when application events are fired, and the state of the application when they are executed.</p> <p></p>"},{"location":"application/#how-to-register-event-handlers","title":"How to register event handlers","text":"Using decoratorsUsing += <p>Event handlers can be registered using decorators.</p> <pre><code>from blacksheep import Application, Request, Response, text\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\nasync def home(request: Request) -&gt; Response:\n    return text(\"Example Async\")\n\n\n@app.on_start\nasync def before_start(application: Application) -&gt; None:\n    print(\"Before start\")\n\n\n@app.after_start\nasync def after_start(application: Application) -&gt; None:\n    print(\"After start\")\n\n\n@app.on_stop\nasync def on_stop(application: Application) -&gt; None:\n    print(\"On stop\")\n</code></pre> <p>In alternative to decorators, event handlers can be registered using <code>+=</code>:</p> <pre><code>from blacksheep import Application, Request, Response, text\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\nasync def home(request: Request) -&gt; Response:\n    return text(\"Example Async\")\n\n\nasync def before_start(application: Application) -&gt; None:\n    print(\"Before start\")\n\n\nasync def after_start(application: Application) -&gt; None:\n    print(\"After start\")\n\n\nasync def on_stop(application: Application) -&gt; None:\n    print(\"On stop\")\n\n\napp.on_start += before_start\napp.after_start += after_start\napp.on_stop += on_stop\n</code></pre> <p>Info</p> <p>For example, to define an <code>after_start</code> callback that logs all routes registered in the application router:</p> <pre><code>@app.after_start\nasync def after_start_print_routes(application: Application) -&gt; None:\n    print(application.router.routes)\n</code></pre>"},{"location":"application/#next","title":"Next","text":"<p>Read about the details of routing in BlackSheep.</p> <p>Last modified on: 2023-07-16 08:51:27</p>DRV"},{"location":"asgi/","title":"ASGI Servers","text":"<p>BlackSheep belongs to the category of ASGI web frameworks, so it requires an ASGI HTTP server to run, such as uvicorn, or hypercorn. All examples in this documentation use <code>Uvicorn</code>, but the framework has been tested also with <code>Hypercorn</code> and should work with any server that implements ASGI.</p>"},{"location":"asgi/#uvicorn","title":"Uvicorn","text":""},{"location":"asgi/#hypercorn","title":"Hypercorn","text":"<p>Many details, such as how to run the server in production, depend on the chosen ASGI server.</p> <p>Last modified on: 2022-01-29 11:24:25</p>"},{"location":"authentication/","title":"Authentication in BlackSheep","text":"<p>The words \"authentication strategy\" in the context of a web application refer to the ability to identify the user who is using the application. BlackSheep implements a built-in authentication strategy for request handlers. This page describes:</p> <ul> <li> How to use the built-in authentication strategy.</li> <li> How to configure a custom authentication handler.</li> <li> How to use the built-in support for JWT Bearer authentication.</li> <li> How to read the user's context in request handlers.</li> </ul> <p>Warning</p> <p>Using JWT Bearer and OpenID integrations requires more dependencies: use <code>pip install blacksheep[full]</code> to use these features</p>"},{"location":"authentication/#underlying-library","title":"Underlying library","text":"<p>The authentication and authorization logic implemented for BlackSheep was packed and published into a dedicated library: <code>guardpost</code> (in pypi).</p>"},{"location":"authentication/#how-to-use-built-in-authentication","title":"How to use built-in authentication","text":"<p>Examples of common strategies to identify users in web applications include:</p> <ul> <li>reading an <code>Authorization: Bearer xxx</code> request header containing a JWT   with claims that identify the user</li> <li>reading a signed token from a cookie</li> </ul> <p>The next paragraphs explain first how to use the built-in support for JWT Bearer tokens, and how to write a custom authentication handler.</p> <p>Info</p> <p>The word \"user\" is usually used only to refer to human users, while the word \"service\" is used to describe non-human clients. In Java and .NET, a common word to describe a generic client is \"principal\".</p>"},{"location":"authentication/#oidc","title":"OIDC","text":"<p>BlackSheep implements built-in support for OpenID Connect authentication, meaning that it can be easily integrated with identity provider services such as:</p> <ul> <li>Auth0</li> <li>Azure Active Directory</li> <li>Azure Active Directory B2C</li> <li>Okta</li> </ul> <p>A basic example integration with any of the identity providers above, having implicit flow enabled for <code>id_token</code> (meaning that the code doesn't need to handle any secret), looks like the following:</p> <pre><code>from blacksheep import Application, html, pretty_json\nfrom blacksheep.server.authentication.oidc import OpenIDSettings, use_openid_connect\nfrom guardpost.authentication import Identity\n\napp = Application()\n\n\n# basic Auth0 integration that handles only an id_token\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"&lt;YOUR_AUTHORITY&gt;\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        callback_path=\"&lt;CALLBACK_PATH&gt;\",\n    ),\n)\n\n\n@app.route(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        response = pretty_json(user.claims)\n\n        return response\n\n    return html(\"&lt;a href='/sign-in'&gt;Sign in&lt;/a&gt;&lt;br/&gt;\")\n</code></pre> <p>Where:</p> Parameter Description YOUR_AUTHORITY The URL to your account, like <code>https://neoteroi.eu.auth0.com</code> CLIENT_ID Your app registration ID CALLBACK_PATH The path that is enabled for <code>reply_uri</code> in your app settings, for example if you enabled for localhost: <code>http://localhost:5000/authorization-callback</code>, the value should be <code>/authorization-callback</code> <p>For more information and examples, refer to the dedicated page about OpenID Connect authentication.</p>"},{"location":"authentication/#jwt-bearer","title":"JWT Bearer","text":"<p>BlackSheep implements built-in support for JWT Bearer authentication, and validation of JWTs:</p> <ul> <li>issued by identity providers implementing OpenID Connect (OIDC) discovery   (such as Auth0, Azure Active Directory)</li> <li>and more in general, JWTs signed using asymmetric encryption and verified   using public RSA keys</li> </ul> <p>The following example shows how to configure JWT Bearer authentication for an application registered in <code>Azure Active Directory</code>, and also how to configure authorization to restrict access to certain methods, only for users who are successfully authenticated:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.authorization import auth\nfrom guardpost.common import AuthenticatedRequirement, Policy\n\nfrom blacksheep.server.authentication.jwt import JWTBearerAuthentication\n\n\napp = Application()\n\napp.use_authentication().add(\n    JWTBearerAuthentication(\n        authority=\"https://login.microsoftonline.com/&lt;YOUR_TENANT_NAME&gt;.onmicrosoft.com\",\n        valid_audiences=[\"&lt;YOUR_APP_CLIENT_ID&gt;\"],\n        valid_issuers=[\n            \"https://login.microsoftonline.com/&lt;YOUR_TENANT_ID&gt;/v2.0\"\n        ],\n    )\n)\n\n# configure authorization, to restrict access to methods using @auth decorator\nauthorization = app.use_authorization()\n\nauthorization += Policy(\"example_name\", AuthenticatedRequirement())\n\nget = app.router.get\n\n\n@get(\"/\")\ndef home():\n    return \"Hello, World\"\n\n\n@auth(\"example_name\")\n@get(\"/api/message\")\ndef example():\n    return \"This is only for authenticated users\"\n\n\n@get(\"/open/\")\nasync def open(user: User | None):\n    if user is None:\n        return json({\"anonymous\": True})\n    else:\n        return json(user.claims)\n</code></pre> <p>The built-in handler for JWT Bearer authentication does not support JWTs signed with symmetric keys. Support for symmetric keys might be added in the future, inside guardpost library.</p> <p>Info</p> <p>\ud83d\udca1 It is possible to configure several JWTBearerAuthentication handlers, for applications that need to support more than one identity provider. For example, for applications that need to support sign-in through Auth0, Azure Active Directory, Azure Active Directory B2C.</p>"},{"location":"authentication/#writing-a-custom-authentication-handler","title":"Writing a custom authentication handler","text":"<p>The example below shows how to configure a custom authentication handler that obtains user's identity for each web request.</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request, json\nfrom guardpost.asynchronous.authentication import AuthenticationHandler, Identity\nfrom guardpost.authentication import User\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Identity | None:\n        # TODO: apply the desired logic to obtain a user's identity from\n        # information in the web request, for example reading a piece of\n        # information from a header (or cookie).\n        header_value = context.get_first_header(b\"Authorization\")\n\n        if header_value:\n            # implement your logic to obtain the user\n            # in this example, an identity is hard-coded just to illustrate\n            # testing in the next paragraph\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            # if the request cannot be authenticated, set the context.identity\n            # to None - do not throw exception because the app might support\n            # different ways to authenticate users\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n</code></pre> <p>It is possible to configure several authentication handlers to implement different ways to identify users. To differentiate the way the user has been authenticated, use the second parameter of <code>Identity</code>'s constructor:</p> <pre><code>identity = Identity({\"name\": \"Jan Kowalski\"}, \"AUTHENTICATION_MODE\")\n</code></pre> <p>The authentication context is the instance of <code>Request</code> created to handle the incoming web request. Authentication handlers must set the <code>identity</code> property on the request, to enable automatic injection of <code>user</code> by dependency injection.</p>"},{"location":"authentication/#testing-the-example","title":"Testing the example","text":"<p>To test the example above, start a web server as explained in the getting started guide, then navigate to its root. A web request to the root of the application without an <code>Authorization</code> header will produce a response with the following body:</p> <pre><code>{\"anonymous\":true}\n</code></pre> <p>While a web request with an <code>Authorization</code> header will produce a response with the following body:</p> <pre><code>{\"name\":\"Jan Kowalski\"}\n</code></pre> <p>For example, to generate web requests using <code>curl</code>:</p> <pre><code>$ curl  http://127.0.0.1:44555/open {\"anonymous\":true}\n\n$ curl -H \"Authorization: foo\" http://127.0.0.1:44555/open {\"name\":\"Jan\nKowalski\"}\n</code></pre> <p>The application has been started on port 44555 (e.g. <code>uvicorn server:app --port=44555</code>).</p>"},{"location":"authentication/#reading-users-context","title":"Reading user's context","text":"<p>The example below show how the user's identity can be read from the web request</p> Using binders (recommended)Directly from the request <pre><code>from guardpost.authentication import Identity\n\n\n@get(\"/\")\nasync def for_anybody(user: Identity | None):\n    ...\n</code></pre> <pre><code>@get(\"/\")\nasync def for_anybody(request: Request):\n    user = request.identity\n    # user can be None or an instance of Identity (set in the authentication\n    # handler)\n</code></pre>"},{"location":"authentication/#next","title":"Next","text":"<p>While authentication deals with identifying users, authorization deals with determining whether the user is authorized to do the action of the web request. The next page describes the built-in authorization strategy in BlackSheep.</p> <p>Last modified on: 2022-12-03 15:44:07</p>RV"},{"location":"authorization/","title":"Authorization in BlackSheep","text":"<p>The words \"authorization strategy\" in the context of a web application refer to the ability to determine whether the user is allowed to do certain operations. BlackSheep implements a built-in authorization strategy for request handlers. This page describes:</p> <ul> <li> How to use the built-in authorization strategy.</li> <li> How to apply authorization rules to request handlers.</li> </ul> <p>It is recommended to read about authentication before reading this page.</p>"},{"location":"authorization/#how-to-use-built-in-authorization","title":"How to use built-in authorization","text":"<p>Examples of common strategies to authorize users in web applications include:</p> <ul> <li>verifying that the user's context obtained from a JWT includes certain   claims (e.g. <code>scope</code>, <code>role</code>)</li> <li>verifying that a web request includes a certain key, like an instrumentation   key or a key signed by a private RSA key (owned by the user) that can be   verified by a public RSA key (used by the server to validate)</li> </ul> <p>The example below shows how to configure an authorization handler that requires an authenticated user. It is modified from the example in the authentication page:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request, json, ok\nfrom blacksheep.server.authorization import Policy, auth\nfrom guardpost.asynchronous.authentication import AuthenticationHandler, Identity\nfrom guardpost.authentication import User\nfrom guardpost.common import AuthenticatedRequirement\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        header_value = context.get_first_header(b\"Authorization\")\n        if header_value:\n            # TODO: parse and validate the value of the authorization\n            # header to get an actual user's identity\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n\nAuthenticated = \"authenticated\"\n\n# enable authorization, and add a policy that requires an authenticated user\napp.use_authorization().add(Policy(Authenticated, AuthenticatedRequirement()))\n\n\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n\n\n@auth(Authenticated)\n@get(\"/account\")\nasync def only_for_authenticated_users():\n    return ok(\"example\")\n</code></pre> <p>Note:</p> <ul> <li>authorization is enabled using <code>app.use_authorization()</code></li> <li>this method returns an instance of <code>AuthorizationStrategy</code>, which handles   the authorization rules</li> <li>the method <code>.add(Policy(Authenticated, AuthenticatedRequirement()))</code>   configures an authorization policy with a single requirement, to have an   authenticated user</li> <li>the authorization policy is applied to request handlers using the <code>@auth</code>   decorator from <code>blacksheep.server.authorization</code> with an argument that   specifies the policy to be used</li> </ul> <p>It is possible to define several authorization policies, each specifying one or more requirements to be satisfied in order for authorization to succeed. The next example explains how to configure an authorization policy that checks for user's roles from claims.</p>"},{"location":"authorization/#defining-an-authorization-policy-that-checks-users-claims","title":"Defining an authorization policy that checks user's claims","text":"<p>The example below shows how to configure an authorization handler that validates user's claims (looking for a \"role\" claim that might be coming from a JWT).</p> <pre><code>from blacksheep.server.authorization import Policy, auth\n\nfrom guardpost.authorization import AuthorizationContext\nfrom guardpost.synchronous.authorization import Requirement\n\n\nclass AdminRequirement(Requirement):\n    def handle(self, context: AuthorizationContext):\n        identity = context.identity\n\n        if identity is not None and identity.claims.get(\"role\") == \"admin\":\n            context.succeed(self)\n\n\nclass AdminsPolicy(Policy):\n    def __init__(self):\n        super().__init__(\"admin\", AdminRequirement())\n</code></pre> <p>Full example:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request, json, ok\nfrom blacksheep.server.authorization import Policy, auth\nfrom guardpost.asynchronous.authentication import AuthenticationHandler, Identity\nfrom guardpost.authentication import User\nfrom guardpost.authorization import AuthorizationContext\nfrom guardpost.common import AuthenticatedRequirement\nfrom guardpost.synchronous.authorization import Requirement\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nclass ExampleAuthHandler(AuthenticationHandler):\n    def __init__(self):\n        pass\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        header_value = context.get_first_header(b\"Authorization\")\n        if header_value:\n            # TODO: parse and validate the value of the authorization\n            # header to get an actual user's identity\n            context.identity = Identity({\"name\": \"Jan Kowalski\"}, \"MOCK\")\n        else:\n            context.identity = None\n        return context.identity\n\n\napp.use_authentication().add(ExampleAuthHandler())\n\nAuthenticated = \"authenticated\"\n\n\nclass AdminRequirement(Requirement):\n    def handle(self, context: AuthorizationContext):\n        identity = context.identity\n\n        if identity is not None and identity.claims.get(\"role\") == \"admin\":\n            context.succeed(self)\n\n\nclass AdminPolicy(Policy):\n    def __init__(self):\n        super().__init__(\"admin\", AdminRequirement())\n\n\napp.use_authorization().add(Policy(Authenticated, AuthenticatedRequirement())).add(\n    AdminPolicy()\n)\n\n\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    # This method can be used by anybody\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n\n\n@auth(Authenticated)\n@get(\"/account\")\nasync def only_for_authenticated_users():\n    # This method can be used by any authenticated user\n    return ok(\"example\")\n\n\n@auth(\"admin\")\n@get(\"/admin\")\nasync def only_for_administrators():\n    # This method requires \"admin\" role in user's claims\n    return ok(\"example\")\n</code></pre>"},{"location":"authorization/#using-the-default-policy","title":"Using the default policy","text":"<p>The method <code>app.use_authorization()</code>, when used without arguments, returns an instance of <code>AuthorizationStrategy</code> from <code>guardpost</code> library. This object can be configured to use a default policy, for example to require an authenticated user by default for all request handlers.</p> <pre><code>authorization = app.use_authorization()\n\n# configure a default policy to require an authenticated user for all handlers\nauthorization.default_policy = Policy(\"authenticated\", AuthenticatedRequirement())\n</code></pre> <p>The default policy is used when the <code>@auth</code> decorator is used without arguments.</p> <p>To enable anonymous access for certain handlers in this scenario, use the <code>allow_anonymous</code> decorator from <code>blacksheep.server.authorization</code>:</p> <pre><code>from blacksheep.server.authorization import allow_anonymous\n\n\n@allow_anonymous()\n@get(\"/\")\nasync def for_anybody(user: Optional[User]):\n    if user is None:\n        return json({\"anonymous\": True})\n\n    return json(user.claims)\n</code></pre>"},{"location":"authorization/#specifying-authentication-schemes-for-request-handlers","title":"Specifying authentication schemes for request handlers","text":"<p>In some scenarios it is necessary to specify multiple authentication schemes for web applications: for example the same application might handle authentication obtained through <code>GitHub</code> OAuth app and <code>Azure Active Directory (AAD)</code>. In such scenarios, it might be necessary to restrict access to some endpoints by authentication method, too.</p> <p>To do so:</p> <ol> <li>specify different authentication handlers, configuring schemes overriding    the <code>scheme</code> property as in the example below.</li> <li>use the <code>authentication_schemes</code> parameter in the <code>@auth</code> decorator</li> </ol> <pre><code>class GitHubAuthHandler(AuthenticationHandler):\n\n    @property\n    def scheme(self) -&gt; str:\n      return \"github\"\n\n    async def authenticate(self, context: Request) -&gt; Optional[Identity]:\n        ...\n\n\n@auth(\"authenticated\", authentication_schemes=[\"github\"])\n@get(\"/admin\")\nasync def only_for_user_authenticated_with_github():\n    # This method only tries to authenticate users using the \"github\"\n    # authentication scheme, defined overriding the scheme @property\n    return ok(\"example\")\n</code></pre>"},{"location":"authorization/#failure-response-codes","title":"Failure response codes","text":"<p>When a request fails because of authorization reasons, the web framework returns:</p> <ul> <li>status <code>401 Unauthorized</code> if authentication failed, and no valid credentials were provided</li> <li>status <code>403 Forbidden</code> if   authentication succeeded as valid credentials were provided, but the user is   not authorized to perform an action</li> </ul> <p>Last modified on: 2023-07-16 08:51:27</p>RV"},{"location":"background-tasks/","title":"Background tasks","text":"<p>This page describes how to start background tasks in request handlers, and how to configure background tasks that run periodically during the application's lifetime.</p>"},{"location":"background-tasks/#how-to-handle-a-request-in-background","title":"How to handle a request in background","text":"<p>The following example shows how to handle a web request in background, which is the use case for the HTTP 202 Accepted response status code.</p> <pre><code>import asyncio\nfrom blacksheep import Application, Response, accepted\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nasync def background_work():\n    # simulate a delay...\n    await asyncio.sleep(1)\n    print(\"Done!\")\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    # start a task in background\n    asyncio.create_task(background_work())\n\n    # note: the server returns a response immediately, so before the conclusion\n    # of the background task\n    return accepted(\"Operation accepted\")\n</code></pre>"},{"location":"background-tasks/#how-to-configure-background-tasks","title":"How to configure background tasks","text":"<p>The following example shows how to configure a background tasks, including the activation of a service resolved by the DI container, running periodically once every second:</p> <pre><code>import asyncio\nfrom datetime import datetime\n\nfrom blacksheep import Application\n\napp = Application()\n\n\n@app.route(\"/\")\ndef home():\n    return f\"Hello, World! {datetime.utcnow().isoformat()}\"\n\n\ndef get_current_timestamp():\n    return datetime.utcnow().isoformat()\n\n\nclass Foo:\n    def __init__(self) -&gt; None:\n        pass\n\n\nasync def task_example(app: Application) -&gt; None:\n    # example background task, running once every second,\n    # this example also shows how to activate a service using the CI container\n    while True:\n        print(get_current_timestamp())\n\n        my_foo = app.service_provider.get(Foo)\n        assert isinstance(my_foo, Foo)\n        print(\"Foo id: \", id(my_foo))\n\n        await asyncio.sleep(1)\n\n\nasync def configure_background_tasks(app):\n    asyncio.get_event_loop().create_task(task_example(app))\n\n\napp.on_start += configure_background_tasks\n\napp.services.add_exact_scoped(Foo)\n</code></pre> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"binders/","title":"Binders","text":"<p>BlackSheep implements automatic binding of parameters for request handlers, a feature inspired by \"Model Binding\" in the ASP.NET web framework. This feature improves code quality and developer's experience, since it provides a strategy to read values from request objects in a consistent way and removes the need to write parts that read values from the request object inside request handlers. It also enables a more accurate generation of OpenAPI Documentation, since the framework is aware of what kind of parameters are used by the request handlers (e.g. headers, cookies, query).</p> <p>This page describes:</p> <ul> <li> Implicit and explicit bindings.</li> <li> Built-in binders.</li> <li> How to define a custom binder.</li> </ul> <p>It is recommended to read the following pages before this one:</p> <ul> <li>Getting started: Basics</li> <li>Getting started: MVC</li> <li>Requests</li> </ul>"},{"location":"binders/#introduction","title":"Introduction","text":"<p>Automatic binding of request query strings and route parameters has been described in several places in the previous pages, and explicit and implicit binding is introduced in the section about requests.</p> <p>Binding is implicit when the source of a parameter is inferred by conventions, or explicit when the programmer specifies exact binders from <code>blacksheep.server.bindings</code>.</p>"},{"location":"binders/#implicit-binding","title":"Implicit binding","text":"<p>An example of implicit binding is when a request handler parameter is read from the request URL's route parameters because its name matches the name of a route parameter:</p> <pre><code>@get(\"/api/cats/{cat_id}\")\nasync def get_cat(cat_id: str):\n    ...\n</code></pre> <p>Another example of implicit binding is when a request handler parameter is annotated with a type that is configured in <code>application.services</code>:</p> <pre><code>class Foo:\n    ...\n\n\napp.services.add_instance(Foo())\n\n\n@get(\"/something\")\nasync def do_something(foo: Foo):\n    ...\n</code></pre> <p>In this case, <code>Foo</code> is obtained from application services since the type is registered in <code>app.services</code>.</p> <p>Binding happens implicitly when parameters in the request handler's signature are not annotated with types, or are not annotated with types that inherit from <code>BoundValue</code> class, defined in <code>blacksheep.server.bindings</code>.</p> <p>Warning</p> <p>A parameter with name \"request\" is always bound to the instance of the <code>Request</code> of the web request.</p>"},{"location":"binders/#explicit-binding","title":"Explicit binding","text":"<p>Binders can be defined explicitly, using type annotations and classes from <code>blacksheep.server.bindings</code> (or just <code>blacksheep</code>).</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import FromJSON, FromServices\n\nfrom your_business_logic.handlers.cats import CreateCatHandler  # example\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n\n\n@post(\"/api/cats\")\nasync def create_cat(\n    create_cat_handler: FromServices[CreateCatHandler],\n    input: FromJSON[CreateCatInput],\n):\n    ...\n</code></pre> <p>In the example above, <code>create_cat_handler</code> is obtained from <code>application.services</code>, an exception is thrown if the the service cannot be resolved. This happens if the service is not registered in application services, or any of services on which it depends is not registered (see Service resolution for more information on services that depend on other services).</p> <p><code>input</code> is obtained reading the request payload, parsing it as JSON, and creating an instance of CreateCatInput from it. If an exception occurs while trying to parse the request payload or when instantiating the <code>CreateCatInput</code>, the framework produces automatically a <code>400 Bad Request</code> response for the client.</p> <p>When mapping the request's payload to an instance of the desired type, the type is instantiated using <code>cls(**data)</code>. If it necessary to parse dates or other complex types that are not handled by JSON deserialization, this must be done in the constructor of the class. To handle gracefully a JSON payload having extra unused properties, use <code>*args</code> in your class constructor: <code>__init__(one, two, three, *args)__</code>.</p>"},{"location":"binders/#optional-parameters","title":"Optional parameters","text":"<p>Optional parameters can be defined in one of these ways:</p> <ol> <li>using <code>typing.Optional</code> annotation</li> <li>specifying a default value</li> </ol> <pre><code>@get(\"/foo\")\nasync def example(\n    page: int = 1,\n    search: str = \"\",\n):\n    # page is read from query string, if specified, otherwise defaults to 1\n    # search is read from query string, if specified, otherwise defaults to \"\"\n    ...\n</code></pre> <pre><code>from typing import Optional\n\n\n@get(\"/foo\")\nasync def example(\n    page: Optional[int],\n    search: Optional[str],\n):\n    # page is read from query string, if specified, otherwise defaults to None\n    # search is read from query string, if specified, otherwise defaults to None\n    ...\n</code></pre> <pre><code>from blacksheep import FromQuery\n\n\n@get(\"/foo\")\nasync def example(\n    page: FromQuery[int] = FromQuery(1),\n    search: FromQuery[str] = FromQuery(\"\"),\n):\n    # page.value defaults to 1\n    # search.value defaults to \"\"\n    ...\n</code></pre> <pre><code>from typing import Optional\n\nfrom blacksheep import FromQuery\n\n\n@get(\"/foo\")\nasync def example(\n    page: FromQuery[Optional[int]],\n    search: FromQuery[Optional[str]],\n):\n    # page.value defaults to None\n    # search.value defaults to None\n    ...\n</code></pre> <pre><code>from typing import Optional\n\nfrom blacksheep import FromQuery\n\n\n@get(\"/foo\")\nasync def example(\n    page: Optional[FromQuery[int]],\n    search: Optional[FromQuery[str]],\n):\n    # page defaults to None\n    # search defaults to None\n    ...\n</code></pre>"},{"location":"binders/#built-in-binders","title":"Built-in binders","text":"Binder Description FromHeader A parameter obtained from a header. FromQuery A parameter obtained from URL query. FromCookie A parameter obtained from a cookie. FromServices Service from <code>application.services</code>. FromJSON Request body read as JSON and optionally parsed. FromForm A parameter obtained from Form request body: either application/x-www-form-urlencoded or multipart/form-data. FromText Request payload read as text, using UTF-8 encoding. FromBytes Request payload read as raw bytes. FromFiles Request payload of file type. ClientInfo Client ip and port information obtained from the request ASGI scope, as Tuple[str, int]. ServerInfo Server ip and port information obtained from the request scope. RequestUser Request's identity. RequestURL Request's URL. RequestMethod Request's HTTP method. <p><code>FromHeader</code> and <code>FromCookie</code> binders must be subclassed because they require a <code>name</code> class property:</p> <pre><code>from blacksheep import FromCookie, FromHeader\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\nclass FromFooCookie(FromCookie[Optional[str]]):\n    name = \"foo\"\n\n\n@get(\"/\")\ndef home(accept: FromAcceptHeader, foo: FromFooCookie) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Foo: {foo.value}\n        \"\"\"\n    )\n</code></pre>"},{"location":"binders/#defining-a-custom-binder","title":"Defining a custom binder","text":"<p>To define a custom binder, define a <code>BoundValue[T]</code> class and a <code>Binder</code> class having <code>handle</code> class property referencing the custom <code>BoundValue</code> class. The following example demonstrates how to define a custom binder:</p> <pre><code>from typing import Optional\n\nfrom blacksheep import Application, Request\nfrom blacksheep.server.bindings import Binder, BoundValue\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nclass FromCustomValue(BoundValue[str]):\n    pass\n\n\nclass CustomBinder(Binder):\n\n    handle = FromCustomValue\n\n    async def get_value(self, request: Request) -&gt; Optional[str]:\n        # TODO: implement here the desired logic to read a value from\n        # the request object\n        return \"example\"\n\n\n@get(\"/\")\ndef home(something: FromCustomValue):\n    assert something.value == \"example\"\n    return f\"OK {something.value}\"\n</code></pre> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"cache-control/","title":"Cache control","text":"<p>BlackSheep offers features to configure <code>Cache-Control</code> response headers. This page explains:</p> <ul> <li> How to use the <code>cache_control</code> decorator to configure a header for specific   request handlers</li> <li> How to use the <code>CacheControlMiddleware</code> to configure a common header for all   request handlers globally</li> </ul>"},{"location":"cache-control/#about-cache-control","title":"About Cache-Control","text":"<p>The <code>Cache-Control</code> response header can be used to describe how responses can be cached by clients. For information on this subject, it is recommended to refer to the <code>mozilla.org</code> documentation.</p>"},{"location":"cache-control/#using-the-cache_control-decorator","title":"Using the cache_control decorator","text":"<p>The following example illustrates how the <code>cache_control</code> decorator can be used to control caching for specific request handlers:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.headers.cache import cache_control\n\n\napp = Application()\n\n\n@app.router.get(\"/\")\n@cache_control(no_cache=True, no_store=True)\nasync def home():\n    return \"This response should not be cached or stored!\"\n\n\n@app.router.get(\"/api/cats\")\n@cache_control(max_age=120)\nasync def get_cats():\n    ...\n</code></pre> <p>Decorators order</p> <p>The order of decorators matters: the router decorator must be the outermost decorator in this case.</p> <p>For controllers:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.controllers import Controller, get\nfrom blacksheep.server.headers.cache import cache_control\n\n\napp = Application()\n\n\nclass Home(Controller):\n    @get(\"/\")\n    @cache_control(no_cache=True, no_store=True)\n    async def index(self):\n        return \"Example\"\n</code></pre>"},{"location":"cache-control/#using-the-cachecontrolmiddleware","title":"Using the CacheControlMiddleware","text":"<p>While the <code>cache_control</code> decorator described above can be used to configure specific request handlers, in some circumstances it might be desirable to configure a default <code>Cache-Control</code> strategy for all paths at once.</p> <p>To configure a default <code>Cache-Control</code> for all <code>GET</code> request handlers resulting in successful responses with status <code>200</code>.</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.controllers import Controller, get\nfrom blacksheep.server.headers.cache import cache_control, CacheControlMiddleware\n\n\napp = Application()\n\n\napp.middlewares.append(CacheControlMiddleware(no_cache=True, no_store=True))\n</code></pre> <p>It is then possible to override the default rule in specific request handlers:</p> <pre><code>app.middlewares.append(CacheControlMiddleware(no_cache=True, no_store=True))\n\n\nclass Home(Controller):\n    @get(\"/\")\n    @cache_control(max_age=120)\n    async def index(self):\n        return \"Example\"\n</code></pre> <p>The provided <code>CacheControlMiddleware</code> can be subclassed to control what requests should be affected:</p> <pre><code>from blacksheep import Request, Response\nfrom blacksheep.server.headers.cache import CacheControlMiddleware\n\n\nclass MyCacheControlMiddleware(CacheControlMiddleware):\n    def should_handle(self, request: Request, response: Response) -&gt; bool:\n        # TODO: implement here the desired logic\n        ...\n</code></pre> <p>For example, a middleware that disables cache-control by default can be defined in the following way:</p> <pre><code>class NoCacheControlMiddleware(CacheControlMiddleware):\n\"\"\"\n    Disable client caching globally, by default, setting a\n    Cache-Contro: no-cache, no-store for all responses.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(no_cache=True, no_store=True)\n\n    def should_handle(self, request: Request, response: Response) -&gt; bool:\n        return True\n</code></pre> <p>Last modified on: 2023-04-27 22:57:30</p>"},{"location":"client/","title":"HTTP Client","text":"<p>BlackSheep includes an implementation of HTTP Client for HTTP 1.1.</p>"},{"location":"client/#client-features","title":"Client features","text":"<ul> <li>HTTP connection pooling</li> <li>User friendly handling of SSL contexts (safe by default)</li> <li>Support for client side middlewares</li> <li>Automatic handling of redirects (can be disabled, validates circular   redirects and maximum number of redirects - redirects to URN are simply   returned to code using the client)</li> <li>Automatic handling of cookies (can be disabled, <code>Set-Cookie</code> and <code>Cookie</code>   headers)</li> </ul> <p>Example: <pre><code>import asyncio\nfrom blacksheep.client import ClientSession\n\n\nasync def client_example(loop):\n    async with ClientSession() as client:\n        response = await client.get(\"https://docs.python.org/3/\")\n\n        assert response is not None\n        text = await response.text()\n        print(text)\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(client_example(loop))\n</code></pre></p>"},{"location":"client/#http-connection-pooling","title":"HTTP Connection pooling","text":"<p>The HTTP client in BlackSheep implements connection pooling. Meaning that connections to the same host and port are kept in memory and reused for different request-response cycles, when possible. By default, connections are not disposed as long as they are kept open.</p> <p>Implementation: /blacksheep/client/pool.py.</p> <p>Connections are created using <code>asyncio</code> function <code>loop.create_connection</code>.</p>"},{"location":"client/#client-middlewares","title":"Client middlewares","text":"<p>The HTTP Client supports middlewares. Middlewares on the server are functions that are executed in order, at every request-response cycle and enable manipulation of incoming requests and outgoing responses. Middlewares support interruption of the chain: that is, returning an HTTP response without firing all handlers in the chain, for example to return HTTP 401 Unauthorized when applying an authentication strategy. The HTTP client can benefit from the same design pattern, and this is supported in BlackSheep.</p>"},{"location":"client/#client-middleware-example","title":"Client middleware example","text":"<pre><code>async def client_example_middleware(request, next_handler):\n\n    # do something before the request is sent\n    response = await next_handler(request)\n\n    # do something with the response from remote server\n    return response\n\nclient = ClientSession()\nclient.middlewares.append(client_example_middleware)\nclient.configure()\n</code></pre>"},{"location":"client/#considerations-about-the-clientsession-class","title":"Considerations about the ClientSession class","text":"<p>To make the client more user-friendly, default connection pools are reused by loop id. This is to prevent users from killing the performance of their applications simply by instantiating many times <code>ClientSession</code> (for example, at every web request).</p> <p>However, it is recommended to instantiate a single instance of HTTP client and register it as service of the application:</p> <pre><code>async def configure_http_client(app):\n    http_client = ClientSession()\n    app.services.add_instance(http_client)  # register a singleton\n\napp.on_start += configure_http_client\n\nasync def dispose_http_client(app):\n    http_client = app.service_provider.get(ClientSession)\n    await http_client.close()\n\napp.on_stop += dispose_http_client\n</code></pre> <p>When following this approach, the http client can be automatically injected to request handlers, and services that need it, like in this example:</p> <pre><code>from blacksheep import html\n\n\n@app.route(\"/get-python-homepage\")\nasync def get_python_homepage(http_client):\n    response = await http_client.get(\"https://docs.python.org/3/\")\n\n    assert response is not None\n    data = await response.text()\n    return html(data)\n</code></pre> <p>Otherwise, instantiate a single connection pools and use it across several instances of HTTP clients:</p> <pre><code>from blacksheep.client import ClientSession\nfrom blacksheep.client.pool import ClientConnectionPools\n\n\nasync def client_pools():\n    # instantiate a single instance of pools\n    pools = ClientConnectionPools(loop)  # loop is an asyncio loop\n\n    # instantiate clients using the same pools\n    client_one = ClientSession(pools=pools)\n\n    client_two = ClientSession(pools=pools)\n\n    client_three = ClientSession(pools=pools)\n\n    await pools.close()\n</code></pre> <p>Dispose ClientConnectionPools</p> <p>When</p> <p>Last modified on: 2023-04-17 19:20:50</p>RV"},{"location":"compression/","title":"Compression","text":"<p>BlackSheep implements built-in features to handle automatic response compression. This page describes:</p> <ul> <li> How to use the <code>GzipMiddleware</code> to enable gzip compression</li> </ul>"},{"location":"compression/#gzipmiddleware","title":"GzipMiddleware","text":"<p>To enable automatic compression of response bodies using <code>gzip</code>, use the <code>GzipMiddleware</code> like in the following example:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.compression import GzipMiddleware\n\n\napp = Application()\n\n\napp.middlewares.append(GzipMiddleware())\n</code></pre> <p>Or, in alternative:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.compression import use_gzip_compression\n\n\napp = Application()\n\n\nuse_gzip_compression(app)\n</code></pre> <p>Not for streamed content</p> <p>The <code>GzipMiddleware</code> does not compress bytes streamed using the <code>StreamedContent</code> class (used by default when serving files), it only compress whole bodies like, for example, those that are generated when returning <code>JSON</code> content to the client.</p>"},{"location":"compression/#options","title":"Options","text":"<p>The following table describes options for the <code>GzipMiddleware</code> constructor.</p> Option Type Description min_size <code>int</code> (default 500) The minimum size before applying compression to response bodies. comp_level <code>int</code> (default 5) The compression level, as passed to <code>gzip.compress</code> function. handled_types <code>Optional[Iterable[bytes]]</code> Control which content types can be compressed by the specific instance of <code>GzipMiddleware</code>. executor <code>Optional[Executor]</code> (default <code>None</code>) Control which instance of <code>concurrent.future.Executor</code> is used to compress - if not specified the default executor handled by <code>run_in_executor</code> is used. <p>When <code>handled_types</code> is not specified for an instance of <code>GzipMiddleware</code>, compression is applied by default to content types containing any of the following strings:</p> <ul> <li>json</li> <li>xml</li> <li>yaml</li> <li>html</li> <li>text/plain</li> <li>application/javascript</li> <li>text/css</li> <li>text/csv</li> </ul> <p>Last modified on: 2023-04-27 22:57:30</p>"},{"location":"contributing/","title":"Contributing to BlackSheep","text":"<p>This page describes how to contribute to BlackSheep. Most of the information presented here applies also to other projects from <code>Neoteroi</code> (e.g. rodi, guardpost, essentials-openapi), although among these projects, only <code>BlackSheep</code> is using <code>Cython</code>.</p>"},{"location":"contributing/#system-requirements","title":"System requirements","text":"<p>Building <code>blacksheep</code> locally requires the following:</p> <ul> <li>one of the supported Python versions; it   is recommended to use one of the latest two stable versions (e.g. Python 3.8   or 3.9 as of the 1st of May 2021)</li> <li>a <code>C</code> compiler, required to use   Cython   (refer to Cython's documentation for more information on this subject)</li> </ul>"},{"location":"contributing/#preparing-a-development-environment","title":"Preparing a development environment","text":"<ol> <li>fork the main repository in GitHub</li> <li>clone the forked repository</li> <li>create a Python virtual environment in the desired location (<code>.gitignores</code>    is configured to ignore a <code>venv</code> folder, so if you name your virtual    environment this way, you can comfortably keep the virtual environment in    the same folder of the repository)</li> <li>install the dependencies that are required to develop, listed in    <code>requirements.txt</code> (pip install -r requirements.txt)</li> <li>compile the <code>C</code> extensions: if your system supports <code>Makefile</code>, use    <code>make compile</code>; otherwise run manually the commands described in the    <code>Makefile</code> for <code>cyt</code> and <code>compile</code> commands</li> <li>run the unit tests to verify if things were compiled correctly, using    <code>pytest</code> or <code>make test</code></li> </ol> <p>Watch the following video for instructions:</p> <p> </p>"},{"location":"contributing/#formatters-and-style-enforcement","title":"Formatters and style enforcement","text":"<p><code>BlackSheep</code> uses the following tools for code formatting:</p> <ul> <li><code>flake8</code></li> <li><code>black</code></li> <li><code>isort</code></li> </ul> <p><code>flake8</code>, <code>black</code>, and <code>isort</code> are used in the CI pipeline as a required step for successful build completion. The repository includes configuration files for <code>flake8</code> and <code>black</code>.</p> <p>The provided <code>Makefile</code> defines a task to run linters:</p> <ul> <li><code>make lint</code> - to run flake8, isort, and black validation</li> </ul>"},{"location":"contributing/#type-hints","title":"Type hints","text":"<p>BlackSheep aims at being type friendly, meaning:</p> <ul> <li>most functions, especially those whose arguments are not obvious, should be   type annotated</li> <li>when developers work with popular text editors and IDEs like <code>PyCharm</code> or   <code>Visual Studio Code</code>, they should benefit from proper help / auto-completion   of parameters required by functions and constructors</li> <li>the parts coded in <code>Cython</code> are documented using stub files (<code>.pyi</code>), see   PEP   484</li> <li>the code should be generally respectful of   <code>MyPy</code> and, when <code>Visual   Studio Code</code> is used,   <code>Pylance</code></li> </ul> <p>This being said, <code>blacksheep</code> doesn't aim at 100% typing coverage or full adherence to <code>MyPy</code>'s (or <code>pyright/Pylance</code>'s) notions of typing perfection. The most important thing is for features to work as intended and well (good enough!), and to be fully test-covered.</p> <p></p>"},{"location":"contributing/#code-coverage","title":"Code coverage","text":"<p><code>BlackSheep</code> features 100% code coverage, except for some rare cases where <code>#pragma: no cover</code> is used. New contributions should not decrease code coverage, unless there is a good reason to skip lines. Integration with <code>Codecov</code> checks code coverage in pull requests.</p> <p></p> <p>To create code coverage:</p> <pre><code>make test-cov\n</code></pre> <p>Or, for those who cannot use <code>make</code>:</p> <pre><code>pytest --cov-report html --cov=blacksheep\n</code></pre>"},{"location":"contributing/#how-to-name-branches","title":"How to name branches","text":"<p>It doesn't matter, as long as branch names don't contain anything that violates the Code of Conduct included in the project's repository. As a general rule of thumb, branch names should have a descriptive name, or refer the number of an issue in their name (e.g. <code>fix_102</code>).</p>"},{"location":"contributing/#setuppy","title":"setup.py","text":"<p>It is intention of <code>blacksheep</code>'s author to always keep <code>setup.py</code> files as stupid and simple as possible. So please don't modify the <code>setup.py</code> file to be \"smarter\" or more dynamic without prior discussion in an issue.</p>"},{"location":"contributing/#how-to-develop-and-debug-with-visual-studio-code","title":"How to develop and debug with Visual Studio Code","text":"<p>The following video shows I am using Visual Studio Code to work on BlackSheep:</p> <p> </p> <p>Last modified on: 2022-01-29 11:24:25</p>"},{"location":"controllers/","title":"Controllers","text":"<p>BlackSheep has built-in features to support MVC (Model, View, Controller) architecture. A <code>Controller</code> is a class having at least one method registered as request handler (i.e. associated to a route). A Controller is instantiated at each web request, when a web request is matched by a route defined in that type of controller.</p> <p>This page describes:</p> <ul> <li> Controller methods.</li> <li> API Controllers.</li> </ul> <p>It is recommended to follow the MVC tutorial before reading this page.</p> <p>For Flask users...</p> <p>If you come from Flask, controllers in BlackSheep would be the equivalent of Flask's Blueprints, as they allow to group request handlers in dedicated modules and classes.</p>"},{"location":"controllers/#the-controller-class","title":"The Controller class","text":"<p>Controllers implement several methods to simplify returning responses. These are the same described at Responses, but they can be overridden in subclasses of <code>Controller</code> and they remove the need to import functions.</p> Method Description ok Returns an HTTP 200 OK response, with optional message; sent as plain text or JSON. status_code Returns a plain response with given status, with optional message; sent as plain text or JSON. created Returns an HTTP 201 Created response, to the given location and with optional JSON content. accepted Returns an HTTP 202 Accepted response, with optional message; sent as plain text or JSON. no_content Returns an HTTP 204 No Content response. json Returns a response with application/json content, and given status (default HTTP 200 OK). pretty_json Returns a response with indented application/json content, and given status (default HTTP 200 OK). text Returns a response with text/plain content, and given status (default HTTP 200 OK). html Returns a response with text/html content, and given status (default HTTP 200 OK). moved_permanently Returns an HTTP 301 Moved Permanently response, to the given location. redirect Returns an HTTP 302 Found response (commonly called redirect), to the given location. see_other Returns an HTTP 303 See Other response, to the given location. not_modified Returns an HTTP 304 Not Modified response. temporary_redirect Returns an HTTP 307 Temporary Redirect response, to the given location. permanent_redirect Returns an HTTP 308 Permanent Redirect response, to the given location. bad_request Returns an HTTP 400 Bad Request response, with optional message; sent as plain text or JSON. unauthorized Returns an HTTP 401 Unauthorized response, with optional message; sent as plain text or JSON. forbidden Returns an HTTP 403 Forbidden response, with optional message; sent as plain text or JSON. not_found Returns an HTTP 404 Not Found response, with optional message; sent as plain text or JSON. view Returns a view rendered synchronously. view_async Returns a view rendered asynchronously. file Returns a binary file response with given content type and optional file name, for download (attachment) (default HTTP 200 OK). This method supports both call with bytes, or a generator yielding chunks. <p>For information on how to use these methods, refer to the type annotations provided in the code.</p> <p></p> <p>Info</p> <p>Using an IDE like JetBrains PyCharm, or Visual Studio Code (as in the screenshot above), enables automatic completion and hints thanks to type annotations.</p>"},{"location":"controllers/#on_request-and-on_response","title":"on_request and on_response","text":"<p>Using controllers it is possible to define methods that are always executed before handling a request and after producing a response:</p> <pre><code>class Example(Controller):\n\n    async def on_request(self, request: Request):\n        print(\"Received a request!\")\n\n    async def on_response(self, response: Response):\n        print(\"Produced response!\")\n</code></pre> <p>Using controllers involves a performance fee compared to using functions because a controller must be instantiated at each web request, but has the following benefits:</p> <ul> <li>Controllers support dependency injection to   receive services for their constructors, in addition to dependency   injection for every single request handler</li> <li>Controllers support defining an <code>on_request(request: Request)</code> method, that   gets called at every web request, <code>on_response(response: Response)</code> method,   and base <code>route</code> (defined as class method) for all handlers defined in the   class.</li> <li>Controllers provide methods to produce responses, that can be overridden in   base classes to personalize the behavior of the application without   monkey-patching functions</li> </ul> <p>Therefore they can help avoiding code repetition in some circumstances.</p> <p>The following example shows how dependency injection can be used for controllers' constructors, and an implementation of <code>on_request</code> method:</p> <pre><code>app = Application()\n\n\nclass Settings:\n\n    def __init__(self, greetings: str):\n        self.greetings = greetings\n\n\nclass Home(Controller):\n\n    def __init__(self, settings: Settings):\n        # controllers are instantiated dynamically at every web request\n        self.settings = settings\n\n    async def on_request(self, request: Request):\n        print(\"[*] Received a request!!\")\n\n    def greet(self):\n        return self.settings.greetings\n\n    @get(\"/\")\n    async def index(self, request: Request):\n        return text(self.greet())\n\n# when configuring the application, register\n# a singleton of the application settings,\n# this service is automatically injected into request handlers\n# having a signature parameter type annotated `: Settings`, or\n# having name \"settings\", without type annotations\napp.services.add_instance(Settings(value))\n</code></pre> <p>If route methods (e.g. <code>head</code>, <code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>) from <code>blacksheep.server.controllers</code> are used, then the default singleton <code>Router</code> instance for controllers is used. It is also possible to use a specific router, as long as this router is bound to the application object:</p> <pre><code>from blacksheep.server.routing import RoutesRegistry\n\n\napp = Application()\napp.controllers_router = RoutesRegistry()\nget = app.controllers_router.get\n</code></pre>"},{"location":"controllers/#the-apicontroller-class","title":"The ApiController class","text":"<p>The <code>ApiController</code> class is a kind of <code>Controller</code> dedicated to API definitions. An ApiController offers some properties to enable versioning of routes and adding a common path prefix to all routes, for example prepending \"/v1/\" fragment to all routes and the name of the controller class.</p> <pre><code>from blacksheep import Response, FromJSON, FromQuery\nfrom blacksheep.server.controllers import ApiController, delete, get, patch, post\n\n\nclass Cats(ApiController):\n    @get()\n    def get_cats(\n        self,\n        page: FromQuery[int] = FromQuery(1),\n        page_size: FromQuery[int] = FromQuery(30),\n        search: FromQuery[str] = FromQuery(\"\"),\n    ) -&gt; Response:\n\"\"\"Returns a list of paginated cats.\"\"\"\n\n    @get(\"{cat_id}\")\n    def get_cat(self, cat_id: UUID) -&gt; Response:\n\"\"\"Gets a cat by id.\"\"\"\n\n    @patch(\"{cat_id}\")\n    def update_cat(self, cat_id: str, input: UpdateCatInput) -&gt; Response:\n\"\"\"Updates a cat with given id.\"\"\"\n\n    @post()\n    def create_cat(self, input: FromJSON[CreateCatInput]) -&gt; Response:\n\"\"\"Creates a new cat.\"\"\"\n\n    @delete(\"{cat_id}\")\n    def delete_cat(self, cat_id: str) -&gt; Response:\n\"\"\"Deletes a cat by id.\"\"\"\n</code></pre> <p>In the example above, the routes defined on the <code>Cats</code> class will result in the following paths:</p> HTTP Method Path Request handler Description HTTP GET /api/cats <code>get_cats</code> Returns a list of paginated cats. HTTP GET /api/cats/{cat_id} <code>get_cat</code> Gets a cat by id. HTTP POST /api/cats/{cat_id} <code>create_cat</code> Creates a new cat. HTTP PATCH /api/cats/{cat_id} <code>update_cat</code> Updates a cat with given id. HTTP DELETE /api/cats/{cat_id} <code>delete_cat</code> Deletes a cat by id. <p>To include a version number in the API, implement a <code>version</code> <code>@classmethod</code> like in the following example:</p> <pre><code>class Cats(ApiController):\n\n    @classmethod\n    def version(cls) -&gt; str:\n        return \"v1\"\n\n    ...\n</code></pre> <p>In such case, the generated paths would be as follows:</p> HTTP Method Path Request handler Description HTTP GET /api/v1/cats <code>get_cats</code> Returns a list of paginated cats. HTTP GET /api/v1/cats/{cat_id} <code>get_cat</code> Gets a cat by id. HTTP POST /api/v1/cats/{cat_id} <code>create_cat</code> Creates a new cat. HTTP PATCH /api/v1/cats/{cat_id} <code>update_cat</code> Updates a cat with given id. HTTP DELETE /api/v1/cats/{cat_id} <code>delete_cat</code> Deletes a cat by id. <p>To specify a name for the API, different than the default one, implement a <code>route</code> <code>@classmethod</code> like in the following example:</p> <pre><code>class Cats(ApiController):\n\n    @classmethod\n    def route(cls) -&gt; str:\n        return \"catz\"\n\n    ...\n</code></pre> <p>Last modified on: 2023-07-16 08:51:27</p>RV"},{"location":"cors/","title":"Cross-Origin Resource Sharing","text":"<p>BlackSheep implements a strategy to handle Cross-Origin Resource Sharing (CORS). This page describes:</p> <ul> <li> How to enable CORS globally.</li> <li> How to enable CORS for specific endpoints.</li> </ul>"},{"location":"cors/#enabling-cors-globally","title":"Enabling CORS globally","text":"<p>The example below shows how to enable CORS globally on a BlackSheep application:</p> <pre><code>app.use_cors(\n    allow_methods=\"GET POST DELETE\",\n    allow_origins=\"https://www.example.dev\",\n    allow_headers=\"Authorization\",\n    max_age=300,\n)\n</code></pre> <p>When enabled this way, the framework handles <code>CORS</code> requests, including preflight <code>OPTIONS</code> requests.</p> <p>It is possible to use <code>*</code> to enable any origin or any method:</p> <pre><code>app.use_cors(\n    allow_methods=\"*\",\n    allow_origins=\"*\",\n    allow_headers=\"* Authorization\",\n    max_age=300,\n)\n</code></pre> Options Description allow_methods Controls the value of Access-Control-Allow-Methods. \ud83d\udde1\ufe0f allow_origins Controls the value of Access-Control-Allow-Origin. \ud83d\udde1\ufe0f allow_headers Controls the value of Access-Control-Allow-Headers. \ud83d\udde1\ufe0f allow_credentials Controls the value of Access-Control-Allow-Credentials. expose_headers Controls the value of Access-Control-Expose-Headers. \ud83d\udde1\ufe0f max_age Controls the value of Access-Control-Max-Age, defaults to 5 seconds. <p>\ud83d\udde1\ufe0f the value can be a string of values separated by space, comma, or semi-colon, or a list.</p>"},{"location":"cors/#enabling-cors-for-specific-endpoints","title":"Enabling CORS for specific endpoints","text":"<p>The example below shows how to enable CORS only for certain endpoints:</p> <pre><code>app.use_cors()\n\napp.add_cors_policy(\n    \"example\",\n    allow_methods=\"GET POST\",\n    allow_origins=\"*\",\n)\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\nasync def home():\n    ...\n\n@app.cors(\"example\")\n@app.route(\"/specific-rules\", methods=[\"GET\", \"POST\"])\nasync def enabled():\n    ...\n</code></pre> <p>Explanation:</p> <ol> <li>the function call <code>app.use_cors()</code> activates built-in handling of CORS    requests and registers a global CORS rule that doesn't allow anything by    default</li> <li>the call <code>app.add_cors_policy(...)</code> registers a new set of rules for CORS,    associated to the key \"example\"</li> <li>the set of rules for CORS called \"example\" is associated to specific    request handlers using the <code>@cors</code> decorator</li> </ol> <p>It is possible to register many sets of rules for CORS, each with its own key, and apply different rules to request handlers. It is also possible to define a global rule when calling <code>app.use_cors(...)</code> that enables certain operations for all request handlers, while defining specific rules.</p> <pre><code># the following settings are applied by default to all request handlers:\napp.use_cors(\n    allow_methods=\"GET POST\",\n    allow_origins=\"https://www.foo.org\",\n    allow_headers=\"Authorization\",\n)\n\napp.add_cors_policy(\n    \"one\",\n    allow_methods=\"GET POST PUT DELETE\",\n    allow_origins=\"*\",\n    allow_headers=\"Authorization\",\n)\n\napp.add_cors_policy(\"deny\")\n\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\nasync def home():\n    ...\n\n@app.cors(\"one\")\n@app.route(\"/specific-rules\", methods=[\"GET\", \"POST\"])\nasync def enabled():\n    ...\n\n@app.cors(\"deny\")\n@app.router.get(\"/disabled-for-cors\")\nasync def disabled():\n    ...\n</code></pre> <p>Last modified on: 2022-02-09 20:26:00</p>"},{"location":"dataprotection/","title":"Data protection","text":"<p>Web applications often need to protect data, so that it can be stored in cookies or other storages. BlackSheep uses <code>itsdangerous</code> to sign and encrypt information, for example when storing <code>claims</code> obtained from <code>id_token</code>s when using an integration with an identity provider using OpenID Connect, or when handling session cookies.</p> <p>This page documents:</p> <ul> <li> How to handle secrets</li> <li> Examples use of data protection</li> </ul>"},{"location":"dataprotection/#how-to-handle-secrets","title":"How to handle secrets","text":"<p>Symmetric encryption is used to sign and encrypt information in several scenarios. This means that BlackSheep applications need secrets to protect sensitive data in some circumstances. When keys are not specified, they are generated automatically in memory when the application starts, for best user's experience.</p> <p>Danger</p> <p>This means that keys are not persisted when applications restart, and not consistent when multiple instances of the same application are deployed across regions, or within a same server. This is acceptable during local development, but should not be the case in production environments.</p> <p>To use consistent keys, configure one or more environment variables like the following:</p> <ul> <li>APP_SECRET_1=\"***\"</li> <li>APP_SECRET_2=\"***\"</li> <li>APP_SECRET_3=\"***\"</li> </ul> <p>Keys can be configured in a host environment, or fetched from a dedicated service such as <code>AWS Secrets Manager</code> or <code>Azure Key Vault</code> at application start-up, and configured as environment settings for the application. DO NOT store secrets that are meant to be used in production under source control.</p>"},{"location":"dataprotection/#example","title":"Example","text":"<pre><code>from blacksheep.server.dataprotection import get_serializer\n\n\nserializer = get_serializer(purpose=\"example\")\n\ntoken = serializer.dumps({\"id\": 1, \"message\": \"This will be kept secret\"})\n\nprint(token)\n\ndata = serializer.loads(token)\n\nprint(data)\n</code></pre> <p>Last modified on: 2022-11-20 10:54:13</p>"},{"location":"dependency-injection/","title":"Dependency injection in BlackSheep","text":"<p>The getting started tutorials show how route and query string parameters can be injected directly in request handlers, by function signature. BlackSheep also supports dependency injection of services configured for the application. This page describes:</p> <ul> <li> An introduction to dependency injection in BlackSheep.</li> <li> Service resolution.</li> <li> Service lifetime.</li> <li> Options to create services.</li> <li> Examples of dependency injection.</li> </ul>"},{"location":"dependency-injection/#introduction","title":"Introduction","text":"<p>The <code>Application</code> object exposes a <code>services</code> property that can be used to configure services. When the function signature of a request handler references a type that is registered as service, an instance of that type is automatically injected when the request handler is called.</p> <p>Consider this example:</p> <ul> <li>some context is necessary to handle certain web requests (for example, a   database connection pool)</li> <li>a class that contains this context can be configured in application services   before the application starts</li> <li>request handlers have this context automatically injected</li> </ul>"},{"location":"dependency-injection/#demo","title":"Demo","text":"<p>Starting from a minimal environment as described in the getting started tutorial, create a <code>foo.py</code> file with the following contents, inside a <code>domain</code> folder:</p> <pre><code>.\n\u251c\u2500\u2500 domain\n\u2502   \u251c\u2500\u2500 foo.py\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 server.py\n</code></pre> <p>domain/foo.py: <pre><code>class Foo:\n\n    def __init__(self) -&gt; None:\n        self.foo = \"Foo\"\n</code></pre></p> <p>Import the new class in <code>server.py</code>, and register the type in <code>app.services</code> as in this example:</p> <p>server.py: <pre><code>from blacksheep import Application\n\nfrom domain.foo import Foo\n\n\napp = Application()\n\napp.services.add_exact_scoped(Foo)  # &lt;-- register Foo type as a service\n\n\n@app.route(\"/\")\ndef home(foo: Foo):  # &lt;-- foo is referenced in type annotation\n    return f\"Hello, {foo.foo}!\"\n</code></pre></p> <p>An instance of <code>Foo</code> is injected automatically at every web request to \"/\".</p> <p>Dependency injection is implemented in a dedicated library from the same author: <code>rodi</code>. <code>rodi</code> implements dependency injection in an unobstrusive way: it works by inspecting <code>__init__</code> methods and doesn't require to alter the source code of classes registered as services. <code>rodi</code> can also resolve dependencies inspecting class annotations, if an <code>__init__</code> method is not specified for the class to activate.</p>"},{"location":"dependency-injection/#service-resolution","title":"Service resolution","text":"<p><code>rodi</code> automatically resolves graphs of services, when a type that is resolved requires other types. In the following example, instances of <code>A</code> are created automatically when resolving <code>Foo</code> because the <code>__init__</code> method in <code>Foo</code> requires an instance of <code>A</code>:</p> <p>foo.py: <pre><code>class A:\n    def __init__(self) -&gt; None:\n        pass\n\n\nclass Foo:\n    def __init__(self, a: A) -&gt; None:\n        self.a = a\n</code></pre></p> <p>Note that both types need to be registered in <code>app.services</code>:</p> <p>server.py: <pre><code>from blacksheep import Application, text\n\nfrom domain.foo import A, Foo\n\n\napp = Application()\n\napp.services.add_exact_transient(A)\napp.services.add_exact_scoped(Foo)\n\n\n@app.route(\"/\")\ndef home(foo: Foo):\n    return text(\n        f\"\"\"\n        A: {id(foo.a)}\n        \"\"\"\n    )\n</code></pre></p> <p>Produces a response like the following at \"/\":</p> <pre><code>        A: 140289521293056\n</code></pre>"},{"location":"dependency-injection/#using-class-annotations","title":"Using class annotations","text":"<p>In alternative to defining <code>__init__</code> methods, it is also possible to use class annotations, like in the example below:</p> <pre><code>class A:\n    pass\n\n\nclass Foo:\n    a: A\n</code></pre>"},{"location":"dependency-injection/#understanding-services-lifetime","title":"Understanding services' lifetime","text":"<p><code>rodi</code> supports services having one of these lifetimes:</p> <ul> <li>singleton - instantiated only once per service provider</li> <li>transient - services are instantiated every time they are required</li> <li>scoped - instantiated once per web request</li> </ul> <p>Consider the following example, where a type <code>A</code> is registered as transient, <code>B</code> as scoped, <code>C</code> as singleton:</p> <p>foo.py: <pre><code>class A:\n    def __init__(self) -&gt; None:\n        pass\n\n\nclass B:\n    def __init__(self) -&gt; None:\n        pass\n\n\nclass C:\n    def __init__(self) -&gt; None:\n        pass\n\n\nclass Foo:\n    def __init__(self, a1: A, a2: A, b1: B, b2: B, c1: C, c2: C) -&gt; None:\n        self.a1 = a1\n        self.a2 = a2\n        self.b1 = b1\n        self.b2 = b2\n        self.c1 = c1\n        self.c2 = c2\n</code></pre></p> <p>server.py: <pre><code>from blacksheep import Application, text\n\nfrom domain.foo import A, B, C, Foo\n\n\napp = Application()\n\napp.services.add_exact_transient(A)\napp.services.add_exact_scoped(B)\napp.services.add_exact_singleton(C)\n\napp.services.add_exact_scoped(Foo)\n\n\n@app.route(\"/\")\ndef home(foo: Foo):\n    return text(\n        f\"\"\"\n        A1: {id(foo.a1)}\n\n        A2: {id(foo.a2)}\n\n        B1: {id(foo.b1)}\n\n        B2: {id(foo.b2)}\n\n        C1: {id(foo.c1)}\n\n        C2: {id(foo.c2)}\n        \"\"\"\n    )\n</code></pre></p> <p>Produces responses like the following at \"/\":</p> <p>Request 1: <pre><code>        A1: 139976289977296\n\n        A2: 139976289977680\n\n        B1: 139976289977584\n\n        B2: 139976289977584\n\n        C1: 139976289978736\n\n        C2: 139976289978736\n</code></pre></p> <p>Request 2: <pre><code>        A1: 139976289979888\n\n        A2: 139976289979936\n\n        B1: 139976289979984\n\n        B2: 139976289979984\n\n        C1: 139976289978736\n\n        C2: 139976289978736\n</code></pre></p> <p>Note how:</p> <ul> <li>transient services are always instantiated whenever they are activated (A)</li> <li>scoped services are instantiated once per web request (B)</li> <li>a singleton service is activated only once (C)</li> </ul>"},{"location":"dependency-injection/#options-to-create-services","title":"Options to create services","text":"<p><code>rodi</code> provides several ways to define and instantiate services.</p> <ol> <li>registering an exact instance as singleton</li> <li>registering a concrete class by its type</li> <li>registering an abstract class and one of its concrete implementations</li> <li>registering a service using a factory function</li> </ol>"},{"location":"dependency-injection/#singleton-example","title":"Singleton example","text":"<pre><code>class ServiceSettings:\n    def __init__(\n        self,\n        oauth_application_id: str,\n        oauth_application_secret: str\n    ):\n        self.oauth_application_id = oauth_application_id\n        self.oauth_application_secret = oauth_application_secret\n\napp.services.add_instance(ServiceSettings(\"00000000001\", \"APP_SECRET_EXAMPLE\"))\n</code></pre>"},{"location":"dependency-injection/#registering-a-concrete-class","title":"Registering a concrete class","text":"<pre><code>class HelloHandler:\n\n    def __init__(self):\n        pass\n\n    def greetings() -&gt; str:\n        return \"Hello\"\n\n\napp.services.add_exact_transient(HelloHandler)\n</code></pre>"},{"location":"dependency-injection/#registering-an-abstract-class","title":"Registering an abstract class","text":"<pre><code>from abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nfrom blacksheep.server.responses import json, not_found\n\n\n# domain class and abstract repository defined in a dedicated package for\n# domain objects\n@dataclass\nclass Cat:\n    id: str\n    name: str\n\n\nclass CatsRepository(ABC):\n\n    @abstractmethod\n    async def get_cat_by_id(self, id: str) -&gt; Optional[Cat]:\n        pass\n\n# ------------------\n\n# the concrete implementation will be defined in a dedicated package\nclass PostgreSQLCatsRepository(CatsRepository):\n\n    async def get_cat_by_id(self, id: str) -&gt; Optional[Cat]:\n        # TODO: implement\n        raise Exception(\"Not implemented\")\n\n# ------------------\n\n# register the abstract class and its concrete implementation when configuring\n# the application\napp.services.add_scoped(CatsRepository, PostgreSQLCatsRepository)\n\n\n# a request handler needing the CatsRepository doesn't need to know about\n# the exact implementation (e.g. PostgreSQL, SQLite, etc.)\n@app.route(\"/api/cats/{cat_id}\")\nasync def get_cat(cat_id: str, repo: CatsRepository):\n\n    cat = await repo.get_cat_by_id(cat_id)\n\n    if cat is None:\n        return not_found()\n\n    return json(cat)\n</code></pre>"},{"location":"dependency-injection/#using-a-factory-function","title":"Using a factory function","text":"<pre><code>class Something:\n    def __init__(self, value: str) -&gt; None:\n        self.value = value\n\n\ndef something_factory(services, activating_type) -&gt; Something:\n    return Something(\"Factory Example\")\n\n\napp.services.add_transient_by_factory(something_factory)\n</code></pre>"},{"location":"dependency-injection/#example-implement-a-request-context","title":"Example: implement a request context","text":"<p>A good example of scoped service is one used to assign each web request with a trace id that can be used to identify requests for logging purposes.</p> <pre><code>from uuid import UUID, uuid4\n\n\nclass OperationContext:\n    def __init__(self):\n        self._trace_id = uuid4()\n\n    @property\n    def trace_id(self) -&gt; UUID:\n        return self._trace_id\n</code></pre> <p>Register the <code>OperationContext</code> type as a scoped service, this way it is instantiated once per web request:</p> <pre><code>app.services.add_exact_scoped(OperationContext)\n\n\n@app.route(\"/\")\ndef home(context: OperationContext):\n    return text(\n        f\"\"\"\n        Request ID: {context.trace_id}\n        \"\"\"\n    )\n</code></pre>"},{"location":"dependency-injection/#services-that-require-asynchronous-initialization","title":"Services that require asynchronous initialization","text":"<p>Services that require asynchronous initialization can be configured inside <code>on_start</code> callbacks, like in the following example:</p> <pre><code>import asyncio\nfrom blacksheep import Application, text\n\n\napp = Application()\n\n\nclass Example:\n    def __init__(self, text):\n        self.text = text\n\n\nasync def configure_something(app: Application):\n    await asyncio.sleep(0.5)  # simulate 500 ms delay\n\n    app.services.add_instance(Example(\"Hello World\"))\n\n\napp.on_start += configure_something\n\n\n@app.route(\"/\")\nasync def home(service: Example):\n    return text(f\"{service.text}\")\n</code></pre> <p>Services configured this way are automatically injected in request handlers, when a parameter name or type annotation matches a key inside <code>app.services</code>.</p> <p>Services that require disposing should be disposed in <code>on_stop</code> callback:</p> <pre><code>async def dispose_example(app: Application):\n    # Note: after the application is started, services are read from\n    # app.service_provider:\n\n    service = app.service_provider[Example]\n    await service.dispose()\n\n\napp.on_stop += dispose_example\n</code></pre> <p>Last modified on: 2023-04-17 16:51:11</p>RVT"},{"location":"develop-with-https/","title":"Develop using HTTPS","text":"<p>To develop locally with HTTPS using a trusted certificate, it is recommended to use <code>mkcert</code>, which is a simple tool for making locally-trusted development certificates.</p> <ul> <li>Install <code>mkcert</code></li> <li>Install the root certificates authority (CA) using the <code>mkcert --install</code> command</li> <li>Generate a certificate for local development using the command: <code>mkcert localhost 127.0.0.1 ::1</code></li> <li>Use the feature of the <code>ASGI</code> server you select, to run with HTTPS.   For <code>uvicorn</code>, refer to this documentation: https://www.uvicorn.org/deployment/#running-with-https.</li> </ul> <p>Example:</p> <pre><code>mkcert --install\n\nmkcert localhost 127.0.0.1 ::1\n\nuvicorn server:app --port 44555 --ssl-keyfile=./localhost-key.pem --ssl-certfile=./localhost.pem\n</code></pre> <p></p> <p>Last modified on: 2023-07-16 08:51:27</p>"},{"location":"extensions/","title":"Extensions","text":"<p>This page provides a list of BlackSheep projects, extensions, or packages providing integration with BlackSheep.</p>"},{"location":"extensions/#torino","title":"Torino","text":"<p>Torino is an advanced project built using BlackSheep for its API part, including a single page application built using React, TypeScript, HTML5, and SASS. It consists in a private files storage and photo gallery for Azure Storage Account. The project provides examples of how to integrate a BlackSheep API to PostgreSQL or SQLite using SQLAlchemy, with migrations, and also how to structure a project using dependency injection, integrate with Azure Application Insights, and more.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#blacksheep-sqlalchemy","title":"BlackSheep-SQLAlchemy","text":"<p>Extension for BlackSheep that simplifies the use of SQLAlchemy in the web framework.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#blacksheep-prometheus","title":"BlackSheep-Prometheus","text":"<p>Prometheus integration for BlackSheep. This package provides integration to collect telemetries about web requests.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#piccolo-orm","title":"Piccolo-ORM","text":"<p>Piccolo is a fast, user friendly ORM and query builder which supports asyncio. Piccolo provides a CLI that lets scaffold new ASGI application, including support for BlackSheep.</p> <p>\ud83c\udfe0 Homepage</p>"},{"location":"extensions/#venezia","title":"Venezia","text":"<p>Venezia is an advanced demo project for a BlackSheep web service deployed to Azure App Service, using a PostgreSQL database, GitHub Workflows, and ARM templates. It includes an example integration with Azure Application Insights.</p> <p>\ud83c\udfe0 Homepage</p> <p>Last modified on: 2022-01-29 11:24:25</p>"},{"location":"getting-started/","title":"Getting started with BlackSheep","text":"<p>This tutorial explains how to create and start a minimal BlackSheep web application.  It provides a general view, covering the following topics:</p> <ul> <li> Creating a web application from scratch.</li> <li> Running the web application.</li> <li> Configuring routes.</li> <li> Handling parameters.</li> <li> Handling responses.</li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python version 3.8, 3.9, 3.10, or 3.11</li> <li>path to the python executable configured in the environment <code>$PATH</code> variable   (tip: if you install Python on Windows using the official installer, enable   the checkbox to update your <code>$PATH</code> variable during the installation)</li> </ul>"},{"location":"getting-started/#preparing-a-development-environment","title":"Preparing a development environment","text":"<p>Create a folder in the desired location on your file system, then open a command line terminal and navigate to the new folder. Create a virtual environment using the following command:</p> <pre><code>python -m venv venv\n</code></pre> <p>and activate it:</p> On Linux or MacOn Windows <pre><code>source venv/bin/activate\n</code></pre> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>BlackSheep belongs to the category of ASGI web frameworks, therefore it requires an ASGI HTTP server to run, such as uvicorn, or hypercorn. For this tutorial, install <code>uvicorn</code> together with <code>blacksheep</code>:</p> <pre><code>pip install blacksheep uvicorn\n</code></pre>"},{"location":"getting-started/#creating-and-running-a-web-application","title":"Creating and running a web application","text":"<p>Create a file <code>server.py</code>, and paste the following contents into it:</p> <pre><code>from datetime import datetime\nfrom blacksheep import Application\n\n\napp = Application()\n\n@app.route(\"/\")\ndef home():\n    return f\"Hello, World! {datetime.utcnow().isoformat()}\"\n</code></pre> <p>Use the command below to start the application using port <code>44777</code>, with automatic reload on file change:</p> <pre><code>uvicorn server:app --port 44777 --reload\n</code></pre> <p>The terminal should display information like in the picture below:</p> <p></p> <p>Open a web browser and navigate to http://127.0.0.1:44777. The web browser will display the text answer from the web application:</p> <p></p>"},{"location":"getting-started/#configuring-routes","title":"Configuring routes","text":"<p>The current code configures a request handler for HTTP GET method at the root path of the application: <code>\"/\"</code>. Note how a function decorator is used to register the <code>home</code> function as request handler:</p> <pre><code>@app.route(\"/\")\ndef home():\n    ...\n</code></pre> <p>This means that whenever a HTTP GET request is received at the root URL of the application (e.g. http://127.0.0.1:44777), the <code>home</code> function is used to handle the request and produce a response.</p> <p>The application object provides two ways of defining routes:</p> <ol> <li>using <code>app.route</code> method</li> <li>using <code>app.router</code>'s methods</li> </ol> <p>The first way enables defining request handlers specifying a path, and optional HTTP methods (defaults to \"GET\" only). The second way provides methods for each HTTP method.</p> <pre><code># Handles HTTP GET and HEAD requests at /some-route\n@app.route(\"/some-route\", methods=[\"GET\", \"HEAD\"])\ndef mix_example():\n    ...\n\n\n# Handles HTTP GET at /\n@app.router.get(\"/\")\ndef example_get():\n    ...\n\n\n# Handles HTTP POST at /\n@app.router.post(\"/\")\ndef example_post():\n    ...\n\n\n# Handles HTTP DELETE at /\n@app.router.delete(\"/\")\ndef example_delete():\n    ...\n</code></pre> <p>To reduce code verbosity when defining routes, it is possible to assign router methods to variables. Edit the previous <code>server.py</code> file to replace its contents with the following:</p> <pre><code>from blacksheep import Application\n\n\napp = Application()\nget = app.router.get\npost = app.router.post\n\n\n@get(\"/\")\ndef home(request):\n    return \"GET Example\"\n\n\n@post(\"/\")\ndef post_example(request):\n    return \"POST Example\"\n</code></pre> <p>Info</p> <p>Thanks to <code>uvicorn</code>'s auto reload feature (used with <code>--reload</code> argument), when the <code>server.py</code> file is updated, the application is automatically reloaded. This is extremely useful during development.</p> <p>Navigate again to <code>http://127.0.0.1:44777</code>, it should display the text: <code>\"GET Example\"</code>.</p> <p>To verify that the <code>post_example</code> request handler is handling <code>POST</code> requests, use a tool to generate a POST HTTP request at the server's address. For example, using <code>curl</code>:</p> curlPowerShell <pre><code>curl -X POST http://127.0.0.1:44777\n</code></pre> <pre><code>Invoke-WebRequest -Uri http://localhost:44777 -Method POST\n</code></pre> <p>Info</p> <p>The application automatically handles requests for any path that is not handled by the router, returning an <code>HTTP 404 Not Found</code> response; and returns <code>HTTP 500 Internal Server Error</code> in case of unhandled exceptions happening during code execution.</p>"},{"location":"getting-started/#handling-route-parameters","title":"Handling route parameters","text":"<p>So far the examples only showed request handlers that didn't use any input parameter. To define a request handler that uses a route parameter, define dynamic routes using the following syntax:</p> <pre><code>@app.route(\"/{name}\")\ndef greetings(name):\n    return f\"Hello, {name}!\"\n</code></pre> <p>Route parameters and function parameter are bound by matching name. Add the fragment of code above to <code>server.py</code> and try navigating to <code>http://127.0.0.1:44777/World</code>.</p> <p>A route can contain several named parameters, separated by slashes, and dynamic fragments mixed with static fragments:</p> <pre><code>@app.route(\"/{one}/{two}/{three}\")\ndef multiple_parameters(one, two, three):\n    return f\"1: {one}, 2: {two}, 3: {three}!\"\n\n\n@app.route(\"/movies/{movie_id}/actors/{actor_id}\")\ndef mix(movie_id, actor_id):\n    ...\n</code></pre> <p>Route parameters are by default treated as strings, but BlackSheep supports automatic parsing of values, when function arguments are annotated using built-in <code>typing</code> annotations. For example, to define a route that handles integer route parameters and returns <code>HTTP 400 Bad Request</code> for invalid values, it is sufficient to decorate the function argument this way:</p> <pre><code>@app.route(\"/lucky-number/{number}\")\ndef only_numbers_here(number: int):\n    return f\"Lucky number: {number}\\n\"\n</code></pre> curlPowerShell <pre><code>curl http://127.0.0.1:44777/lucky-number/777\nLucky number: 777\n\ncurl http://127.0.0.1:44777/lucky-number/x\nBad Request: Invalid value ['x'] for parameter `number`; expected a valid int.\n</code></pre> <pre><code>Invoke-WebRequest -Uri http://127.0.0.1:44777/lucky-number/777\n\nStatusCode        : 200\nStatusDescription : OK\nContent           : Lucky number: 777\n\nInvoke-WebRequest -Uri http://127.0.0.1:44777/lucky-number/x\nInvoke-WebRequest: Bad Request: Invalid value ['x'] for parameter `number`; expected a valid int.\n</code></pre> <p>Several built-in types are handled automatically: e.g. <code>str</code>, <code>bool</code>, <code>int</code>, <code>float</code>, <code>uuid.UUID</code>, <code>datetime.date</code>, <code>datetime.datetime</code>, <code>List[T]</code>, <code>Set[T]</code>.</p>"},{"location":"getting-started/#handling-query-string-parameters","title":"Handling query string parameters","text":"<p>In the same way route parameters are injected automatically into request handlers by route parameters with matching names, <code>blacksheep</code> can handle query string parameters automatically. Adds this new fragment to your application:</p> <pre><code>@app.route(\"/query/\")\ndef query_greetings(name: str):\n    return f\"Hello, {name}!\"\n</code></pre> <p>Then navigate to http://localhost:44777/query?name=World.</p> <p>A request handler can use different query strings and query string parameters support lists.</p> <pre><code>from typing import List\n\n@app.route(\"/query-list/\")\ndef greetings_many(name: List[str]):\n    return f\"Hello, {', '.join(name)}!\"\n\n# example:\n# http://localhost:44777/query-list?name=Charlie&amp;name=Lisa&amp;name=Snoopy\n# --&gt; Hello, Charlie, Lisa, Snoopy!\n</code></pre> <p>Every handler can have many input parameters from different sources: request headers, cookies, query, route, request body, configured application services. These are treated in more details in the dedicated page about Binders.</p>"},{"location":"getting-started/#accessing-the-request-object","title":"Accessing the request object","text":"<p>To access the HTTP Request object directly, add a parameter called \"request\" to the signature of a request handler (type annotation is optional):</p> <pre><code>from blacksheep import Request\n\n@app.route(\"/request-object/\")\ndef request_object(request: Request):\n    # the request object exposes methods to read headers, cookies,\n    # body, route parameters\n    ...\n</code></pre> <p>Info</p> <p>You can name the request parameter any way you like (e.g. <code>request</code>, <code>req</code>, <code>foo</code>, etc.), as long as you keep the correct type annotation (that is, <code>blacksheep.Request</code>).</p> <p>This subject will be treated in more details in a different section.</p>"},{"location":"getting-started/#handling-responses","title":"Handling responses","text":"<p>Request handlers must return an instance of <code>blacksheep.Response</code> class. The module <code>blacksheep.server.responses</code> provides several functions to produce responses. You can also import them directly from the <code>blacksheep</code> package.</p> <p>The following example shows how to serve a JSON response, using a class defined with <code>dataclass</code>. Delete all contents from the current <code>server.py</code> file and paste the following code:</p> <pre><code>from dataclasses import dataclass\nfrom uuid import UUID, uuid4\n\nfrom blacksheep import Application, json\n\n\n@dataclass\nclass Cat:\n    id: UUID\n    name: str\n    active: bool\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/api/cats\")\ndef get_cats():\n    return json(\n        [\n            Cat(uuid4(), \"Lampo\", True),\n            Cat(uuid4(), \"Milady\", True),\n            Cat(uuid4(), \"Meatball\", True),\n            Cat(uuid4(), \"Pilou\", True),\n        ]\n    )\n</code></pre> <p>Then navigate to http://127.0.0.1:44777/api/cats to see the result, it will look like this:</p> <pre><code>[{\"id\":\"9dea0080-0e92-46e0-b090-55454c23d37f\",\"name\":\"Lampo\",\"active\":true},\n{\"id\":\"3ce81720-de11-41b4-bad4-6fa63e00403d\",\"name\":\"Milady\",\"active\":true},\n{\"id\":\"2981d8a4-52c3-4ed9-96b8-30fafe62bc47\",\"name\":\"Meatball\",\"active\":true},\n{\"id\":\"b697358e-0f74-4449-840a-32c8db839244\",\"name\":\"Pilou\",\"active\":true}]\n</code></pre> <p>Info</p> <p>Try also the <code>pretty_json</code> function in <code>blacksheep.server.responses</code>.</p> <p>For more granular control, it is possible to use the <code>blacksheep.messages.Response</code> class directly (read <code>blacksheep.server.responses</code> module for examples), and it is possible to modify the response before returning it to the client: for example to set a response header.</p> <pre><code>@get(\"/api/cats\")\ndef get_cats():\n    response = json(\n        [\n            Cat(uuid4(), \"Lampo\", True),\n            Cat(uuid4(), \"Milady\", True),\n            Cat(uuid4(), \"Meatball\", True),\n            Cat(uuid4(), \"Pilou\", True),\n        ]\n    )\n\n    response.add_header(b\"X-Foo\", b\"Foo!\")\n\n    return response\n</code></pre>"},{"location":"getting-started/#asynchronous-request-handlers","title":"Asynchronous request handlers","text":"<p>The examples so far show synchronous request handlers. To define asynchronous request handlers, define <code>async</code> functions:</p> <pre><code>@app.route(\"/api/movies\")\nasync def get_movies():\n    # ... do something async (example)\n    movies = await movies_provider.get_movies()\n    return json(movies)\n</code></pre> <p>Asynchronous code is described more in other sections of the documentation.</p>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>This tutorial covered the ABCs of creating a BlackSheep application. The general concepts presented here apply to any kind of web framework:</p> <ul> <li>server side routing</li> <li>handling of query strings and route parameters</li> <li>handling of requests and responses</li> </ul> <p>The next page will describe a more articulated scenario, including handling of HTML views on the server side, serving static files, and more.</p> <ul> <li>Getting started with the MVC project template</li> </ul> <p>Last modified on: 2023-04-17 19:20:50</p>RV"},{"location":"hsts/","title":"HSTS","text":"<p>The HTTP Strict-Transport-Security response header (often abbreviated as HSTS) is a standard feature used to instruct clients that a site should only be accessed using HTTPS, and any attempt to access it using HTTP should be converted automatically to HTTPS.</p> <p>BlackSheep offers a middleware to configure HTTP Strict-Transport-Security response header globally. This page explains how to use the built-in middleware to enforce HSTS on a web application.</p>"},{"location":"hsts/#enabling-hsts","title":"Enabling HSTS","text":"<pre><code>from blacksheep import Application\nfrom blacksheep.server.env import is_development\nfrom blacksheep.server.security.hsts import HSTSMiddleware\n\napp = Application()\n\n\nif not is_development():\n    app.middlewares.append(HSTSMiddleware())\n</code></pre> <p>Considerations for local development</p> <p>It is generally undesirable enabling <code>HSTS</code> during local development, since browsers get instructed to require <code>HTTPS</code> for all traffic on <code>localhost</code>. This is why the example above configures the middleware only if the application is not running for development. See Defining application environment for more information.</p>"},{"location":"hsts/#options","title":"Options","text":"Option Type Description max_age <code>int</code> Control the <code>max-age</code> directive of the HSTS header (default 31536000) include_subdomains <code>bool</code> Control the <code>include-subdomains</code> directive of the HSTS header (default false)"},{"location":"hsts/#for-more-information","title":"For more information","text":"<p>For more information on HTTP Strict Transport Security, it is recommended to refer to the developer.mozilla.org documentation.</p> <p>Last modified on: 2023-04-17 19:20:50</p>"},{"location":"middlewares/","title":"Middlewares","text":"<p>A BlackSheep application supports middlewares, which provide a flexible way to define a chain of functions that handles every web requests.</p> <p>This page covers:</p> <ul> <li> Introduction to middlewares.</li> <li> How to use function decorators to avoid code repetition.</li> </ul>"},{"location":"middlewares/#introduction-to-middlewares","title":"Introduction to middlewares","text":"<p>Middlewares enable the definition of callbacks that are executed for each web request in a specific order.</p> <p>Info</p> <p>When a function should be called only for certain routes, use instead a decorator function.</p> <p>Middlewares are called in order: each receives the <code>Request</code> object as first parameter, and the next handler to be called as second parameter. Any middleware can decide to not call the next handler, and return a <code>Response</code> object instead. For example, a middleware can be used to return an <code>HTTP 401 Unauthorized</code> response in certain scenarios.</p> <pre><code>from blacksheep import Application, text\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\nasync def middleware_one(request, handler):\n    print(\"middleware one: A\")\n    response = await handler(request)\n    print(\"middleware one: B\")\n    return response\n\n\nasync def middleware_two(request, handler):\n    print(\"middleware two: C\")\n    response = await handler(request)\n    print(\"middleware two: D\")\n    return response\n\n\napp.middlewares.append(middleware_one)\napp.middlewares.append(middleware_two)\n\n\n@get(\"/\")\ndef home():\n    return \"OK\"\n</code></pre> <p>In this example, the following data would be printed to console: <pre><code>middleware one: A\nmiddleware two: C\nmiddleware two: D\nmiddleware one: B\n</code></pre></p>"},{"location":"middlewares/#middlewares-defined-as-classes","title":"Middlewares defined as classes","text":"<p>To define a middleware as a class, make the class async callable, like in the example below:</p> <pre><code>class ExampleMiddleware:\n    async def __call__(self, request, handler):\n        # do something before passing the request to the next handler\n\n        response = await handler(request)\n\n        # do something after the following request handlers prepared the response\n        return response\n</code></pre> <p>The same example including type annotations:</p> <pre><code>from typing import Awaitable, Callable\n\nfrom blacksheep import Request, Response\n\n\nclass ExampleMiddleware:\n    async def __call__(\n        self, request: Request, handler: Callable[[Request], Awaitable[Response]]\n    ) -&gt; Response:\n        # do something before passing the request to the next handler\n\n        response = await handler(request)\n\n        # do something after the following request handlers prepared the response\n        return response\n</code></pre>"},{"location":"middlewares/#resolution-chains","title":"Resolution chains","text":"<p>When middlewares are defined for an application, resolution chains are built at its start. Every handler configured in the application router is replaced by a chain, executing middlewares in order, down to the registered handler.</p>"},{"location":"middlewares/#wrapping-request-handlers","title":"Wrapping request handlers","text":"<p>When a common portion of logic should be applied to certain request handlers, but not to all of them, it is recommended to define a decorator.</p> <p>The following example shows how to define a decorator that applies certain response headers only for certain routes.</p> <pre><code>from functools import wraps\nfrom typing import Tuple\n\nfrom blacksheep.server.normalization import ensure_response\n\n\ndef headers(additional_headers: Tuple[Tuple[str, str], ...]):\n    def decorator(next_handler):\n        @wraps(next_handler)\n        async def wrapped(*args, **kwargs) -&gt; Response:\n            response = ensure_response(await next_handler(*args, **kwargs))\n\n            for (name, value) in additional_headers:\n                response.add_header(name.encode(), value.encode())\n\n            return response\n\n        return wrapped\n\n    return decorator\n</code></pre> <p>Then use the decorator on specific request handlers:</p> <pre><code>@get(\"/\")\n@headers(((\"X-Foo\", \"Foo\"),))\nasync def home():\n    return \"OK\"\n</code></pre> <p>The order of decorators matters: user defined decorators must be applied before the route decorator (before <code>@get</code> in the example above).</p>"},{"location":"middlewares/#define-a-wrapper-compatible-with-synchronous-and-asynchronous-functions","title":"Define a wrapper compatible with synchronous and asynchronous functions","text":"<p>To define a wrapper that is compatible with both synchronous and asynchronous functions, it is possible to use <code>inspect.iscoroutinefunction</code> function. For example, to alter the decorator above to be compatible with request handlers defined as synchronous functions (recommended):</p> <pre><code>import inspect\nfrom functools import wraps\nfrom typing import Tuple\n\nfrom blacksheep.server.normalization import ensure_response\n\n\ndef headers(additional_headers: Tuple[Tuple[str, str], ...]):\n    def decorator(next_handler):\n\n        if inspect.iscoroutinefunction(next_handler):\n            @wraps(next_handler)\n            async def wrapped(*args, **kwargs):\n                response = ensure_response(await next_handler(*args, **kwargs))\n\n                for (name, value) in additional_headers:\n                    response.add_header(name.encode(), value.encode())\n\n                return response\n\n            return wrapped\n        else:\n            @wraps(next_handler)\n            def wrapped(*args, **kwargs):\n                response = ensure_response(next_handler(*args, **kwargs))\n\n                for (name, value) in additional_headers:\n                    response.add_header(name.encode(), value.encode())\n\n                return response\n\n            return wrapped\n\n    return decorator\n</code></pre> <p>Warning</p> <p>The <code>ensure_response</code> function is necessary to support scenarios when the request handlers defined by the user doesn't return an instance of Response class (see request handlers normalization).</p> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"mounting/","title":"Mounting applications","text":"<p>The word \"mounting\" refers to the ability to plug ASGI applications into others, under specific routes. This enables reusing whole applications, or components, across web applications. This page describes:</p> <ul> <li> How to use the mount feature in BlackSheep.</li> <li> Details about mounting, and handling of application events.</li> <li> Mounting and OpenAPI Documentation.</li> <li> An example using Piccolo Admin.</li> </ul>"},{"location":"mounting/#how-to-use-mounts","title":"How to use mounts","text":"<p>To mount an application in another application, use the <code>mount</code> method:</p> <pre><code>parent_app.mount(\"/example-path\", child_app)\n</code></pre> <p>Example:</p> <pre><code>from blacksheep import Application\n\nparent = Application()\n\n\n@parent.router.get(\"/\")\ndef parent_home():\n    return \"Hello, from the parent app\"\n\n\nchild = Application()\n\n\n@child.router.get(\"/\")\ndef child_home():\n    return \"Hello, from the child app\"\n\n\n# Note: when mounting another BlackSheep application,\n# make sure to handle the start and stop events of the mounted app\nparent.mount_registry.auto_events = True\n\nparent.mount(\"/sub\", child)\n</code></pre> <p>In the example above, both <code>parent</code> and <code>child</code> are complete applications that can be started independently. If <code>child</code> is started alone, it replies to GET web requests at route \"/\" with the text \"Hello, from the child app\".</p> <p>Since <code>parent</code> mounts <code>child</code> under the path \"/sub\", when <code>parent</code> is started, it delegates requests starting with <code>/sub/*</code> to the mounted application, therefore when the <code>parent</code> is started, a GET request to the route \"/sub\" produces the greetings message from <code>child</code>. A GET request to the route \"/\" instead is replied with the text \"Hello, from the parent app\".</p> <p>Info</p> <p>Try to create a file <code>server.py</code> like in the example above, and run the applications using <code>uvicorn</code>, to verify how they work in practice.</p>"},{"location":"mounting/#side-effects-of-mounting","title":"Side effects of mounting","text":"<p>Even though mounting can enable interesting scenarios, it comes at a price.</p> <p>Applications that are supposed to be mounted by other applications need to be designed to be \"mount-friendly\", for example when they handle redirects or links to static files they serve. Absolute paths will not work when used by applications that are mounted by other applications, while relative paths will work.</p> <p>If an application is not designed to be mounted by other applications, it might create non-obvious side effects.</p> <p>Consider the following example:</p> <pre><code>from blacksheep import Application, redirect\n\napp_a = Application()\n\n\n@app_a.router.get(\"/\")\ndef a_home():\n    return \"Hello, from Application A\"\n\n\n@app_a.router.get(\"/test\")\ndef redirect_to_home():\n    # Note: app_a defines an absolute path for redirection - this won't work\n    # for mounted apps since the intention is most likely to redirect to a path\n    # handled by the same application\n    return redirect(\"/\")\n\n\napp_b = Application()\n\n\n@app_b.router.get(\"/\")\ndef b_home():\n    return \"Hello, from Application B\"\n\n\n@app_b.on_start\nasync def handle_app_a_start(_):\n    await app_a.start()\n\n\n@app_b.on_stop\nasync def handle_app_a_stop(_):\n    await app_a.stop()\n\n\napp_b.mount(\"/a\", app_a)\n</code></pre> <p>This won't produce the expected result in real-life scenarios! <code>app_a</code> in this case redirects to the absolute path \"/\", therefore a path that is handled by <code>app_b</code>! In general, mounted apps will be defined in dedicated packages with no knowledge of the applications that mount them. To fix this scenario, it is necessary to use a relative path for redirection, like:</p> <pre><code>@app_a.router.get(\"/test\")\ndef redirect_to_home():\n    return redirect(\"./\")\n</code></pre>"},{"location":"mounting/#handling-of-application-events","title":"Handling of application events","text":"<p>Applications often need to define actions that must happen when the application starts, and actions that must happen when the application stops.</p> <p>ASGI web frameworks handle lifecycle events when they get dedicated messages from the underlying ASGI server (<code>lifespan</code> messages), notifying the ASGI server when initialization logic has completed. However, when an application is mounted into another, it is not responsible of handling <code>lifespan</code> messages.</p> <p>When mounted apps define initialization and shutdown logic, the application that mounts them must register their initialization and shutdown functions as part of its own events.</p> <p>BlackSheep applications must always be started to work properly. To enable automatic handling of application events for mounted applications, use of the following options:</p> <ol> <li>use the env variable <code>APP_MOUNT_AUTO_EVENTS</code> set to a truthy value (\"1\", \"true\",    \"TRUE\") - recommended</li> <li>set the <code>parent.mount_registry.auto_events</code> property to <code>True</code></li> <li>handle application events explicitly like in the example below - necessary    when the mounted applications are other kinds of ASGI apps</li> </ol> <pre><code>@parent.on_start\nasync def handle_child_start(_):\n    await child.start()\n\n\n@parent.on_stop\nasync def handle_child_stop(_):\n    await child.stop()\n\n\nparent.mount(\"/some-route\", child)\n</code></pre> <p>This ensures that when the main application handles <code>lifespan</code> messages from the ASGI HTTP Server, the mounted app is also notified properly of those events.</p> <p>Info</p> <p>The way the mounted app must be started and stopped depend on the web framework used to implement it. The example above is correct when <code>child</code> is an instance of BlackSheep Application.</p> <p>Note</p> <p><code>APP_MOUNT_AUTO_EVENTS</code> is not the default to not introduce breaking changes. This will be the default behavior in BlackSheep 2.x</p>"},{"location":"mounting/#mounting-and-openapi-documentation","title":"Mounting and OpenAPI Documentation","text":"<p>Since version <code>1.2.5</code>, BlackSheep supports generating OpenAPI Documentation for mounted BlackSheep applications, meaning that parent applications can expose OpenAPI Documentation about all endpoints, including those of mounted apps and their descendants.</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\nfrom openapidocs.v3 import Info\n\nfrom blacksheep import Application\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\n\nparent = Application(show_error_details=True)\nparent.mount_registry.auto_events = True\nparent.mount_registry.handle_docs = True\n\n\ndocs = OpenAPIHandler(info=Info(title=\"Parent API\", version=\"0.0.1\"))\ndocs.bind_app(parent)\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n    email: str\n    foo: int\n\n\n@dataclass\nclass CreateDogInput:\n    name: str\n    email: str\n    example: int\n\n\n@dataclass\nclass CreateParrotInput:\n    name: str\n    email: str\n\n\n@parent.router.get(\"/\")\ndef a_home():\n\"\"\"Parent root.\"\"\"\n    return \"Hello, from the parent app - for information, navigate to /docs\"\n\n\n@parent.router.get(\"/cats\")\ndef get_cats_conflicting():\n\"\"\"Conflict!\"\"\"\n    return \"CONFLICT\"\n\n\nchild_1 = Application()\n\n\n@child_1.router.get(\"/\")\ndef get_cats():\n\"\"\"Gets a list of cats.\"\"\"\n    return \"Gets a list of cats.\"\n\n\n@child_1.router.post(\"/\")\ndef create_cat(data: CreateCatInput):\n\"\"\"Creates a new cat.\"\"\"\n    return \"Creates a new cat.\"\n\n\n@child_1.router.delete(\"/{cat_id}\")\ndef delete_cat(cat_id: str):\n\"\"\"Deletes a cat by id.\"\"\"\n    return \"Deletes a cat by id.\"\n\n\nchild_2 = Application()\n\n\n@child_2.router.get(\"/\")\ndef get_dogs():\n\"\"\"Gets a list of dogs.\"\"\"\n    return \"Gets a list of dogs.\"\n\n\n@child_2.router.post(\"/\")\ndef create_dog(data: CreateDogInput):\n\"\"\"Creates a new dog.\"\"\"\n    return \"Creates a new dog.\"\n\n\n@child_2.router.delete(\"/{dog_id}\")\ndef delete_dog(dog_id: str):\n\"\"\"Deletes a dog by id.\"\"\"\n    return \"Deletes a dog by id.\"\n\n\nchild_3 = Application()\n\n\n@child_3.router.get(\"/\")\ndef get_parrots():\n\"\"\"Gets a list of parrots.\"\"\"\n    return \"Gets a list of parrots\"\n\n\n@child_3.router.post(\"/\")\ndef create_parrot(data: CreateParrotInput):\n\"\"\"Creates a new parrot.\"\"\"\n    return \"Creates a new parrot\"\n\n\n@child_3.router.delete(\"/{parrot_id}\")\ndef delete_parrot(parrot_id: str):\n\"\"\"Deletes a parrot by id.\"\"\"\n    return \"Deletes a parrot by id.\"\n\n\nparent.mount(\"/cats\", child_1)\nparent.mount(\"/dogs\", child_2)\nparent.mount(\"/parrots\", child_3)\n</code></pre> <p>Produces OpenAPI Documentation for all endpoints.</p> <p></p>"},{"location":"mounting/#examples","title":"Examples","text":"<p>To see a working example where <code>mount</code> is used, see the Piccolo Admin example at BlackSheep-Examples.</p> <p>In this example, Piccolo Admin is configured as mounted app under \"/admin\" route, providing a UI to handle data stored in a <code>SQLite</code> database.</p> <p>Last modified on: 2022-03-13 17:53:31</p>RV"},{"location":"mvc-project-template/","title":"Getting started with the MVC project template","text":"<p>This tutorial explains how to create a BlackSheep application using the MVC (Model, View, Controller) project template, covering the following topics:</p> <ul> <li> Creating a blacksheep application from a project template.</li> <li> Routes defined using classes (controllers).</li> <li> Server side templating (views and models).</li> <li> Handling parameters in controllers.</li> <li> Serving static files</li> </ul> <p>It is recommended to follow the previous tutorial before reading this one.</p>"},{"location":"mvc-project-template/#requirements","title":"Requirements","text":"<ul> <li>Python version 3.7, 3.8, 3.9, or 3.10</li> <li>path to the python executable configured in the environment <code>$PATH</code> variable   (tip: if you install Python on Windows using the official installer, enable   the checkbox to update your <code>$PATH</code> variable automatically)</li> <li>a text editor: any is fine; this tutorial uses Visual Studio Code</li> </ul>"},{"location":"mvc-project-template/#downloading-the-project-template","title":"Downloading the project template","text":"<p>Navigate to the BlackSheep MVC project template repository in GitHub and download its code in one of the following ways:</p> <ul> <li>either clone the repository using <code>git</code></li> <li>or download the project as zip file, using the \"Download ZIP\" button, and unzip the contents into the desired location</li> </ul> <p></p> <p>Info</p> <p>If you have a GitHub account, you can use the \"Use this template\" button to create a new project, then clone it.</p> <p>Then create a Python virtual environment as explained in the previous tutorial, for example at the root folder of the project template, and install the dependencies of the project template, using the following command:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"mvc-project-template/#starting-the-application","title":"Starting the application","text":"<p>Start the application using the following command:</p> <pre><code>uvicorn server:app --port 44777 --reload\n</code></pre> <p>And navigate to the local page, opening a browser at <code>http://localhost:44777</code> (use the same port of the previous command).</p> <p>The browser should display this page:</p> <p></p> <p>Several things are happening because the web application is configured:</p> <ul> <li>to build and serve dynamic HTML pages</li> <li>to serve static files (e.g. pictures, JavaScript, CSS files)</li> <li>to expose an API and offer OpenAPI Documentation about the API</li> <li>to handle application settings and application start/stop events</li> </ul> <p>Let's see these elements in order, but first let's get acquainted with the project's structure.</p>"},{"location":"mvc-project-template/#project-structure","title":"Project structure","text":"<p>The project is organized with the following folder structure:</p> <pre><code>\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 (application files related to blacksheep front-end)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controllers\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 (controller files, defining routes)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 static\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 (static files served by the web app)\n\u2502\u00a0\u00a0 \u2502\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 (HTML templates, views compiled by the web app)\n\u2502\n\u251c\u2500\u2500 core\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 (core classes, common across front-end and business layer)\n\u2502\n\u251c\u2500\u2500 domain\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 (domain classes, POCO)\n\u2502\n\u251c\u2500\u2500 (root folder, where the main file starting the whole app resides)\n\u251c\u2500\u2500 server.py\n\u2514\u2500\u2500 settings.yaml\n</code></pre> <ul> <li>the <code>app</code> folder contains files that are specific to the web application,   settings, configuration, a folder for <code>controllers</code> that define routes,   folders for <code>static</code> files and one for <code>views</code> (HTML templates)</li> <li>other packages at the root of the project, like <code>core</code> and <code>domain</code>, should be   abstracted from the web server and should be reusable in other kinds of   applications (for example, a CLI)</li> <li>the root folder contains the <code>server.py</code> file to start the application, and   a <code>settings.yaml</code> file that is loaded when the application process starts, to   read settings for the application</li> </ul> <p>The project uses <code>onion architecture</code>. For example a valid scenario would be to add an additional package for the data access layer, and implement the business logic in sub-packages inside the <code>domain</code> folder.</p> <p>The root folder also contains a LICENSE file: this refers to the project template itself and can be deleted, a <code>mypy.ini</code> file for those who use <code>MyPy</code>, and a workspace file for <code>Visual Studio Code</code>, for developers who use this text editor.</p>"},{"location":"mvc-project-template/#open-the-project-with-a-text-editor","title":"Open the project with a text editor","text":"<p>Open the project's folder using your favorite text editor. The template includes a workspace file for <code>Visual Studio Code</code>, which contains recommended settings to work with Python (recommended extensions, and <code>black</code> formatter, <code>flake8</code>, <code>mypy</code>, and <code>pylance</code>). These are of course a matter of personal preference and can be ignored or removed.</p> <p></p>"},{"location":"mvc-project-template/#routes-defined-using-classes-controllers","title":"Routes defined using classes (controllers)","text":"<p>The previous tutorial described how routes can be defined using functions:</p> <pre><code>@app.route(\"/\")\nasync def home():\n    ...\n</code></pre> <p><code>blacksheep</code> offers an alternative way to define request handlers: using class methods. Both approaches have pros and cons, which will be described later in more detail. To see this in practice, create a new file <code>app/controllers/greetings.py</code> and copy the following code into it:</p> <pre><code>from blacksheep.server.controllers import Controller, get\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-world\")\n    def index(self):\n        return self.text(\"Hello, World!\")\n</code></pre> <p>Finally, open <code>app/controllers/__init__.py</code> and import the new controller, adding this line to it:</p> <pre><code>from .greetings import Greetings\n</code></pre> <p>If the application was run using the <code>--reload</code> option, its process should reload automatically; otherwise stop and restart the application manually.  Navigate to <code>http://localhost:44777/hello-world</code>: it will display the response from the <code>Greetings.index</code> method.</p> <p>When the path of a web request matches a route defined in a controller type, a new instance of that <code>Controller</code> is created. In other words, every instance of controller is scoped to a specific web request. Just like function handlers, controllers support automatic injection of parameters into request handlers, and also dependency injection into their constructors (<code>__init__</code> methods). This is an excellent feature that improves development speed and enables cleaner code (compare this approach with a scenario where all dependencies needs to be imported  and referenced inside function bodies by hand).</p> <p>The <code>Controller</code> class implements methods to return values and offers <code>on_request</code> and <code>on_response</code> extensibility points.</p>"},{"location":"mvc-project-template/#server-side-templating-views-and-models","title":"Server side templating (views and models)","text":"<p>Server side templating refers to the ability of a web application to generate HTML pages from templates and dynamic variables. BlackSheep does this using the wondeful <code>Jinja2</code> library by the Pallets team.</p> <p>To see how this works in practice when using <code>Controllers</code>, add a new method to the new <code>Greetings</code> controller created previously to look like this:</p> <pre><code>from blacksheep.server.controllers import Controller, get\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-view\")\n    def hello(self):\n        return self.view()\n</code></pre> <p>Then, create a new folder inside <code>views</code> directory, called \"greetings\", and add an HTML file named \"hello.html\".</p> <p></p> <p>Copy the following contents into the <code>hello.html</code>:</p> <pre><code>&lt;div&gt;\n  &lt;h1&gt;Hello, There&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>Now navigate to http://localhost:44777/hello-view, to see the response from the new HTML view.</p> <p>Note how convention over configuration is used in this case, to determine that <code>./views/greetings/hello.html</code> file must be used, because of the convention: <code>./views/{CONTROLLER_NAME}/{METHOD_NAME}.html</code>.</p> <p>The view currently is an HTML fragment, not a full document. To make it a full page, modify <code>hello.html</code> to use the application layout:</p> <pre><code>{%- extends \"layout.html\" -%}\n{%- block title -%}\n  Hello Page!\n{%- endblock -%}\n{%- block description -%}\n  Project template to create web applications with MVC architecture using BlackSheep web framework.\n{%- endblock -%}\n{%- block css -%}\n  &lt;link rel=\"stylesheet\" href=\"/styles/public.css\" /&gt;\n{%- endblock -%}\n{%- block body -%}\n  &lt;div style=\"margin: 10em 2em;\"&gt;\n    &lt;h1&gt;Hello, There!&lt;/h1&gt;\n  &lt;/div&gt;\n{%- endblock -%}\n{%- block js -%}\n\n{%- endblock -%}\n</code></pre> <p>Refresh the page at http://localhost:44777/hello-view to see the result.</p> <p>In this case, a page layout is applied using: <code>{%- extends \"layout.html\" -%}</code>, with several blocks going in various area of <code>layout.html</code>. For more information on layouts and features of the templating library, refer to Jinja2 documentation.</p> <p>So far the tutorials only showed the Controller and the View part of the MVC architecture. A Model is a context for an HTML view. To include dynamic content into an HTML template, use mustaches <code>{{name}}</code> placeholders and pass a model having properties whose names match their key to the <code>view</code> function.</p> <p>For example, modify <code>hello.html</code> to use dynamic content from a model:</p> <pre><code>  &lt;div style=\"margin: 10em 2em;\"&gt;\n    &lt;h1&gt;Hello, {{name}}!&lt;/h1&gt;\n\n    &lt;ul&gt;\n      {% for sentence in sentences %}\n        &lt;li&gt;&lt;a href=\"{{ sentence.url }}\"&gt;{{ sentence.text }}&lt;/a&gt;&lt;/li&gt;\n      {% endfor %}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n</code></pre> <p>and <code>greetings.py</code> to contain the following code:</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\nfrom blacksheep.server.controllers import Controller, get\n\n\n@dataclass\nclass Sentence:\n    text: str\n    url: str\n\n\n@dataclass\nclass HelloModel:\n    name: str\n    sentences: List[Sentence]\n\n\nclass Greetings(Controller):\n\n    @get(\"/hello-view\")\n    def hello(self):\n        return self.view(\n            model=HelloModel(\n                \"World!\",\n                sentences=[\n                    Sentence(\n                        \"Check this out!\",\n                        \"https://github.com/RobertoPrevato/BlackSheep\",\n                    )\n                ],\n            )\n        )\n</code></pre> <p>Produces this result: </p> <p>Models can be defined as dictionaries, dataclasses, pydantic models, or regular classes implementing a constructor.</p>"},{"location":"mvc-project-template/#handling-parameters-in-controllers","title":"Handling parameters in controllers","text":"<p>The previous tutorial showed how request handlers support automatic injection of parameters read from the HTTP request. Controllers support the same, therefore it is possible to have parameters read automatically and injected to controller methods:</p> <pre><code>class Example(Controller):\n\n    @get(\"/example/{value}\")\n    def route_example(self, value: str):\n        return self.text(f\"Got: {value} in route\")\n\n    @get(\"/example\")\n    def query_example(self, value: str):\n        return self.text(f\"Got: {value} in query string\")\n</code></pre> <p>Controllers also support dependency injection for their constructor (<code>__init__</code> method), this will be explained in the next page.</p>"},{"location":"mvc-project-template/#serving-static-files","title":"Serving static files","text":"<p>This tutorial previously showed how the homepage of the MVC project template looks like, at the root of the web site:</p> <p></p> <p>The project template includes a folder for <code>static</code> files, including pictures, CSS, JavaScript files. Static files are served using a catch-all route, reading files whose path, relatively to the static folder, matches the URL path of the request.</p> <p>For example, if the <code>static</code> folder contains such file: <code>scripts/example.js</code>, web requests at <code>http://localhost:44777/scripts/example.js</code> will be resolved with this file and related information. When handling static files, BlackSheep automatically takes care of several details:</p> <ul> <li>it handles ETag response header, If-None-Match request header and HTTP 304 Not Modified   responses if files don't change on file system</li> <li>it handles HTTP GET requests returning file information</li> <li>it handles Range requests, to support pause and restore downloads out of the box   and enable optimal support for videos (videos can be downloaded from a certain   point in time)</li> </ul> <p>Try to add a file to the static folder, and download it writing the path in your browser.</p> <p>Relative paths are supported, but only files inside the root static folder are served, it is not possible to download files outside of the static folder (it would be a security issue if it worked otherwise!). Additionally, BlackSheep only handles certain files extensions:  by default only the most common file extensions used in web applications. Paths starting with \"/\" are always considered absolute paths starting from the root of the web site.</p>"},{"location":"mvc-project-template/#summary","title":"Summary","text":"<p>This tutorial covered some higher level topics of a BlackSheep application. The general concepts presented here apply to many kinds of web framework:</p> <ul> <li>server side templating of HTML views</li> <li>serving of static files</li> <li>use of MVC architecture</li> </ul> <p>The next pages describes the built-in support for dependency injection, and automatic generation of OpenAPI Documentation.</p> <p>Last modified on: 2023-04-17 16:50:15</p>T"},{"location":"openapi/","title":"OpenAPI Documentation","text":"<p>BlackSheep implements automatic generation of OpenAPI Documentation for most common scenarios, and provides methods to enrich the documentation with details. This page describes the following:</p> <ul> <li> An introduction to OpenAPI Documentation.</li> <li> Built-in support for OpenAPI Documentation.</li> <li> How to document endpoints.</li> <li> How to handle common responses.</li> <li> Expose the documentation for anonymous access.</li> <li> Support for ReDoc UI.</li> </ul>"},{"location":"openapi/#introduction-to-openapi-documentation","title":"Introduction to OpenAPI Documentation","text":"<p>Citing from the Swagger web site, at the time of this writing:</p> <p>The OpenAPI Specification (OAS) defines a standard {...} interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service {...}.</p> <p>An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p> <p>Since a web application knows by definition the paths it is handling, and since a certain amount of metadata can be inferred from the source code, BlackSheep implements automatic generation of OpenAPI Documentation, and offers an API to enrich the documentation with information that cannot be inferred from the source code.</p> <p>If you followed the Getting started: MVC tutorial, its project template is configured to include an example of OpenAPI Documentation and to expose a Swagger UI at <code>/docs</code> path.</p> <p></p>"},{"location":"openapi/#built-in-support-for-openapi-documentation","title":"Built-in support for OpenAPI Documentation","text":"<p>The following piece of code describes a minimal set-up to enable generation of OpenAPI Documentation and exposing a Swagger UI in BlackSheep:</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import Application\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\napp = Application()\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@dataclass\nclass Foo:\n    foo: str\n\n\n@app.route(\"/foo\")\nasync def get_foo() -&gt; Foo:\n    return Foo(\"Hello!\")\n</code></pre> <p>If you start this application and navigate to its <code>/docs</code> route, you will see a Swagger UI like this:</p> <p></p> <p>In this example, BlackSheep generates this specification file in JSON format, at <code>/openapi.json</code> path:</p> <pre><code>{\n\"openapi\": \"3.0.3\",\n\"info\": {\n\"title\": \"Example API\",\n\"version\": \"0.0.1\"\n},\n\"paths\": {\n\"/foo\": {\n\"get\": {\n\"responses\": {\n\"200\": {\n\"description\": \"Success response\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/Foo\"\n}\n}\n}\n}\n},\n\"operationId\": \"get_foo\"\n}\n}\n},\n\"servers\": [],\n\"components\": {\n\"schemas\": {\n\"Foo\": {\n\"type\": \"object\",\n\"required\": [\n\"foo\"\n],\n\"properties\": {\n\"foo\": {\n\"type\": \"string\",\n\"nullable\": false\n}\n}\n}\n}\n}\n}\n</code></pre> <p>Note how the <code>Foo</code> component schema is automatically documented. <code>BlackSheep</code> supports both <code>@dataclass</code> and <code>Pydantic</code> models for automatic generation of documentation.</p> <p>And also YAML format at <code>/openapi.yaml</code> path:</p> <pre><code>openapi: 3.0.3\ninfo:\ntitle: Example API\nversion: 0.0.1\npaths:\n/foo:\nget:\nresponses:\n'200':\ndescription: Success response\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Foo'\noperationId: get_foo\nservers: []\ncomponents:\nschemas:\nFoo:\ntype: object\nrequired:\n- foo\nproperties:\nfoo:\ntype: string\nnullable: false\n</code></pre> <p>To provide more details for api routes, decorate request handlers using the instance of <code>OpenAPIHandler</code> as a decorator:</p> <pre><code>@docs(responses={200: \"Returns a text saying OpenAPI Example\"})\n@app.route(\"/\")\ndef home():\n    return \"OpenAPI Example\"\n</code></pre> <p>After this change, the specification file includes the new information:</p> <pre><code>openapi: 3.0.3\ninfo:\ntitle: Example API\nversion: 0.0.1\npaths:\n/:\nget:\nresponses:\n'200':\ndescription: Returns a text saying OpenAPI Example\noperationId: home\ncomponents: {}\n</code></pre>"},{"location":"openapi/#adding-description-and-summary","title":"Adding description and summary","text":"<p>An endpoint description can be specified either using a <code>docstring</code>:</p> <pre><code>@docs(responses={200: \"Returns a text saying OpenAPI Example\"})\n@app.route(\"/\")\nasync def home():\n\"\"\"\n    This example is used to demonstrate support for OpenAPI in BlackSheep.\n    The endpoint itself doesn't do anything useful.\n    \"\"\"\n    return \"OpenAPI Example\"\n</code></pre> <p>Or in the <code>@docs</code> decorator: <pre><code>@docs(\n    summary=\"This example is used to demonstrate support for OpenAPI in BlackSheep.\",\n    description=\"The endpoint itself doesn't do anything useful.\",\n    responses={200: \"Returns a text saying OpenAPI Example\"},\n)\n@app.route(\"/\")\nasync def home():\n    return \"OpenAPI Example\"\n</code></pre></p> <p>When using <code>docstring</code>, the first line of the docstring is used as summary, and the whole docstring as description.</p> <p></p> <p>Info</p> <p>Most of the BlackSheep code base is typed using the <code>typing</code> module, thus IDEs and text editors like Visual Studio Code and PyCharm can provide user's friendly hints for code completion (see the screenshot below). </p>"},{"location":"openapi/#ignoring-endpoints","title":"Ignoring endpoints","text":"<p>To exclude certain endpoints from the API documentation, use <code>@docs.ignore()</code>:</p> <pre><code>@docs.ignore()\n@app.route(\"/hidden-from-docs\")\nasync def hidden_endpoint():\n    return \"This endpoint won't appear in documentation\"\n</code></pre>"},{"location":"openapi/#document-only-certain-routes","title":"Document only certain routes","text":"<p>To document only certain routes, use an include function like in the example below. For example, to include only those routes that starts with \"/api\":</p> <pre><code>docs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\n\n# include only endpoints whose path starts with \"/api/\"\ndocs.include = lambda path, _: path.startswith(\"/api/\")\n</code></pre>"},{"location":"openapi/#documenting-response-examples","title":"Documenting response examples","text":"<p>The following example shows how to describe examples for responses:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom uuid import UUID\n\nfrom blacksheep import Application, json\nfrom blacksheep.server.openapi.common import ContentInfo, ResponseExample, ResponseInfo\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\napp = Application()\n\ndocs = OpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@dataclass\nclass Cat:\n    id: UUID\n    name: str\n    creation_time: datetime\n\n\n@docs(\n    summary=\"Gets a cat by id\",\n    description=\"\"\"A sample API that uses a petstore as an\n          example to demonstrate features in the OpenAPI 3 specification\"\"\",\n    responses={\n        200: ResponseInfo(\n            \"A cat\",\n            content=[\n                ContentInfo(\n                    Cat,\n                    examples=[\n                        ResponseExample(\n                            Cat(\n                                id=UUID(\"3fa85f64-5717-4562-b3fc-2c963f66afa6\"),\n                                name=\"Foo\",\n                                creation_time=datetime.now(),\n                            )\n                        )\n                    ],\n                )\n            ],\n        ),\n        404: \"Cat not found\",\n    },\n)\n@app.route(\"/api/cats/{cat_id}\")\ndef get_cat_by_id(cat_id: UUID):\n    cat = ...  # TODO: implement the logic that fetches a cat by id\n    return json(cat)\n</code></pre> <p>If the code seems excessively verbose, consider that OpenAPI specification is designed to support documenting responses with different content types (e.g. JSON, XML, etc.) and having examples for each content type. Writing the documentation by hand would be much more time consuming!</p> <p>BlackSheep automatically generates components schemas by type (in this example, <code>Cat</code>) and reuses them in all API endpoints that use them:</p> <p></p>"},{"location":"openapi/#avoid-code-pollution-using-endpointdocs","title":"Avoid code pollution using EndpointDocs","text":"<p>If you are familiar with other libraries to produce OpenAPI Documentation and you consider the example above, you might notice that adding OpenAPI details to request handlers can pollute the source code and distract the programmer from the actual request handlers' logic.</p> <p>BlackSheep provides a way to avoid polluting the source code and keep the code for OpenAPI in dedicated files. Use the <code>blacksheep.server.openapi.common.EndpointDocs</code> class to define documentation in dedicated files and keep your request handlers code clean:</p> <pre><code>from apidocs.cats import get_cat_docs\n\n@docs(get_cat_docs)\n@app.route(\"/api/cats/{cat_id}\")\ndef get_cat_by_id(cat_id: UUID):\n    cat = ...  # TODO: implement the logic that fetches a cat by id\n    return json(cat)\n</code></pre> <p>To see a complete example, refer to the source code of the MVC project template, and see how documentation is organized and configured (in <code>app.docs</code>, <code>app.controllers.docs</code>).</p>"},{"location":"openapi/#deprecating-an-api","title":"Deprecating an API","text":"<p>To mark and endpoint as deprecated, use <code>@docs.deprecated()</code>:</p> <pre><code>@docs.deprecated()\n@app.route(\"/some-deprecated-api\")\nasync def deprecated_endpoint():\n    return \"This endpoint is deprecated\"\n</code></pre>"},{"location":"openapi/#altering-the-specification-upon-creation","title":"Altering the specification upon creation","text":"<p>To alter the specification file upon creation, define a subclass of <code>OpenAPIHandler</code> that overrides <code>on_docs_generated</code> method.</p> <pre><code>from blacksheep import Application, json\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info, OpenAPI, Server\n\napp = Application()\n\n\nclass MyOpenAPIHandler(OpenAPIHandler):\n    def on_docs_generated(self, docs: OpenAPI) -&gt; None:\n        docs.servers = [\n            Server(url=\"https://foo-example.org\"),\n            Server(url=\"https://test.foo-example.org\"),\n        ]\n\n\ndocs = MyOpenAPIHandler(info=Info(title=\"Example API\", version=\"0.0.1\"))\ndocs.bind_app(app)\n</code></pre>"},{"location":"openapi/#handling-common-responses","title":"Handling common responses","text":"<p>APIs often implement a common way to handle failures, to provide clients with details for web requests that cannot complete successfully. For example, an API might return a response body like the following, in case of a bad request for a certain endpoint:</p> <pre><code>{\"error\": \"The provided country code is not supported\", \"code\": \"InvalidCountryCode\"}\n</code></pre> <p>Such response body can be handled using a <code>dataclass</code>:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass ErrorInfo:\n    error: str\n    code: int\n</code></pre> <p><code>blacksheep</code> offers the following way to document common responses:</p> <pre><code>from openapidocs.v3 import MediaType, Response as ResponseDoc, Schema\n\n\nerror_info = docs.register_schema_for_type(ErrorInfo)\n\ndocs.common_responses = {\n    400: ResponseDoc(\n        \"Bad request\",\n        content={\n            \"application/json\": MediaType(\n                schema=Schema(\n                    any_of=[error_info],\n                    example=SafeException(error=\"Invalid argument\", code=1001),\n                )\n            )\n        },\n    ),\n    401: ResponseDoc(\n        \"Unauthorized\",\n        content={\n            \"application/json\": MediaType(\n                schema=Schema(\n                    any_of=[error_info],\n                    example=SafeException(\n                        error=\"The user is not authorized\", code=3\n                    ),\n                )\n            )\n        },\n    ),\n}\n</code></pre> <p>Common responses are configured for all endpoints.</p>"},{"location":"openapi/#support-for-generics","title":"Support for generics","text":"<p>The generation of OpenAPI Documentation supports handling of generic types. Consider the following example:</p> <ol> <li>a common task is to implement an API that returns a paginated subset of    elements, usually given some filters (e.g. textual search)</li> <li>clients needs to know the count of items that match the filters, to display    the total number of items and the number of pages that are necessary to    display all results (depending on page size)</li> <li>for such scenario, using a <code>Generic</code> type is a good solution, because many    kinds of objects can be paginated</li> </ol> <p>Example of generic class definition</p> <pre><code>from dataclasses import dataclass\nfrom typing import List, Generic, TypeVar\n\n\nT = TypeVar(\"T\")\n\n\n@dataclass\nclass PaginatedSet(Generic[T]):\n    items: List[T]\n    total: int\n</code></pre> <p>Full example illustrating OpenAPI Documentation for generics</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Generic, List, TypeVar\nfrom uuid import UUID\n\nfrom openapidocs.v3 import Info\n\nfrom blacksheep import Application, FromQuery\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\n\nT = TypeVar(\"T\")\n\n\n@dataclass\nclass PaginatedSet(Generic[T]):\n    items: List[T]\n    total: int\n\n\n@dataclass\nclass Order:\n    id: UUID\n    customer_id: UUID\n    creation_time: datetime\n\n\napp = Application()\n\n\n# enable OpenAPI Documentation\ndocs = OpenAPIHandler(info=Info(title=\"Example\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@app.router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n\"\"\"\n    Returns a paginated set of orders.\n    \"\"\"\n</code></pre> <p>In the example below, the generic type is handled properly and produces the following OpenAPI Documentation:</p> <pre><code>openapi: 3.0.3\ninfo:\ntitle: Example\nversion: 0.0.1\npaths:\n/api/orders:\nget:\nresponses:\n'200':\ndescription: Success response\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/PaginatedSetOfOrder'\noperationId: get_orders\nsummary: Returns a paginated set of orders.\ndescription: Returns a paginated set of orders.\nparameters:\n-   name: page\nin: query\nschema:\ntype: integer\nformat: int64\nnullable: false\ndescription: ''\n-   name: page_size\nin: query\nschema:\ntype: integer\nformat: int64\nnullable: false\ndescription: ''\n-   name: search\nin: query\nschema:\ntype: string\nnullable: false\ndescription: ''\nservers: []\ncomponents:\nschemas:\nOrder:\ntype: object\nrequired:\n- id\n- customer_id\n- creation_time\nproperties:\nid:\ntype: string\nformat: uuid\nnullable: false\ncustomer_id:\ntype: string\nformat: uuid\nnullable: false\ncreation_time:\ntype: string\nformat: date-time\nnullable: false\nPaginatedSetOfOrder:\ntype: object\nrequired:\n- items\n- total\nproperties:\nitems:\ntype: array\nnullable: false\nitems:\n$ref: '#/components/schemas/Order'\ntotal:\ntype: integer\nformat: int64\nnullable: false\n</code></pre> <p>Info</p> <p>Generic types, expressed in Python using <code>GenericType[T]</code>, are represented with <code>GenericTypeOfT</code> to respect OpenAPI specification, saying that <code>$ref values must be RFC3986-compliant percent-encoded URIs</code>. A generic type with more arguments, like <code>Foo[T, U, X]</code> gets represented with <code>FooOfTAndUAndX</code>.</p>"},{"location":"openapi/#describing-parameters","title":"Describing parameters","text":"<p>It is possible to describe parameters explicitly, using docstrings, or leveraging <code>Pydantic</code>.</p>"},{"location":"openapi/#documenting-parameters-explicitly","title":"Documenting parameters explicitly","text":"<p>To document parameters explicitly, use the <code>@docs</code> like in the following example (elaborating on the previous example about generics):</p> <pre><code>from blacksheep.server.openapi.common import ParameterInfo\n\n\napp = Application()\n\n\n# enable OpenAPI Documentation\ndocs = OpenAPIHandler(info=Info(title=\"Example\", version=\"0.0.1\"))\ndocs.bind_app(app)\n\n\n@app.router.get(\"/api/orders\")\n@docs(\n    parameters={\n        \"page\": ParameterInfo(description=\"Page number\"),\n        \"page_size\": ParameterInfo(\n            description=\"The number of items to display per page\"\n        ),\n        \"search\": ParameterInfo(description=\"Optional text search\"),\n    },\n)\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n\"\"\"\n    Returns a paginated set of orders.\n    \"\"\"\n</code></pre>"},{"location":"openapi/#documenting-parameters-using-docstrings","title":"Documenting parameters using docstrings","text":"<p>BlackSheep supports documenting parameters using docstrings, and the following styles are supported: Epytext, ReStructuredText, NumpyDoc. The following sections show the previous example re-written to use docstrings.</p> EpytextReStructuredTextNumpyDoc <pre><code>@app.router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n\"\"\"\n    Returns a paginated set of orders.\n\n    @param page: Page number\n    @param page_size: The number of items to display per page\n    @param search: Optional text search\n    \"\"\"\n</code></pre> <pre><code>@app.router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n\"\"\"\n    Returns a paginated set of orders.\n\n    :param page: Page number\n    :param page_size: The number of items to display per page\n    :param search: Optional text search\n    \"\"\"\n</code></pre> <pre><code>@app.router.get(\"/api/orders\")\nasync def get_orders(\n    page: FromQuery[int] = FromQuery(1),\n    page_size: FromQuery[int] = FromQuery(30),\n    search: FromQuery[str] = FromQuery(\"\"),\n) -&gt; PaginatedSet[Order]:\n\"\"\"\n    Returns a paginated set of orders.\n\n    Parameters\n    ----------\n    page : Page number\n    page_size : The number of items to display per page\n    search : Optional text search\n    \"\"\"\n</code></pre> <p>The logic that parses docstrings can also extract types information, but this is not documented because the recommended way is to use type annotations. Refer to the file <code>test_openapi_docstrings.py</code> for more examples on the information that can be extracted from docstrings.</p>"},{"location":"openapi/#anonymous-access","title":"Anonymous access","text":"<p>If the server uses a default authorization policy that requires an authenticated user, it is still possible to make the OpenAPI Documentation endpoint available for anonymous access, using the <code>anonymous_access</code> parameter:</p> <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Example API\", version=\"0.0.1\"), anonymous_access=True\n)\n\n# include only endpoints whose path starts with \"/api/\"\ndocs.include = lambda path, _: path.startswith(\"/api/\")\n</code></pre>"},{"location":"openapi/#support-for-redoc-ui","title":"Support for ReDoc UI","text":"<p>BlackSheep supports ReDoc UI, although this is disabled by default. It is also possible to implement custom UIs for the documentation endpoints, using the <code>ui_providers</code> property of the <code>OpenAPIHandler</code> class, and implementing a custom <code>UIProvider</code>.</p> <pre><code>from blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom blacksheep.server.openapi.ui import ReDocUIProvider\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Example API\", version=\"0.0.1\"),\n)\n\ndocs.ui_providers.append(ReDocUIProvider())\n\n# include only endpoints whose path starts with \"/api/\"\ndocs.include = lambda path, _: path.startswith(\"/api/\")\n</code></pre>"},{"location":"openapi/#changing-operations-ids","title":"Changing operations ids","text":"<p>When OpenAPI Documentation is generated, operation ids are obtained from the name of the Python function definitions.</p> <p>For example, having a <code>get_foo</code> request handler, generates an object having <code>operationId</code> equal to \"get_foo\":</p> <pre><code>@app.router.get(\"/foo\")\nasync def get_foo() -&gt; Foo:\n    return Foo(\"Hello!\")\n</code></pre> <pre><code>    \"paths\": {\n\"/foo\": {\n\"get\": {\n\u2026,\n\"operationId\": \"get_foo\"\n}\n}\n},\n</code></pre> <p>To change how <code>operationId</code> is generated for endpoints, define a custom type of <code>OpenAPIHandler</code> that overrides the <code>get_operation_id</code> method, to produce the desired result:</p> <pre><code>class CustomOpenAPIHandler(OpenAPIHandler):\n    def get_operation_id(self, docs: Optional[EndpointDocs], handler) -&gt; str:\n        return handler.__name__.capitalize().replace(\"_\", \" \")\n</code></pre>"},{"location":"openapi/#for-more-details","title":"For more details","text":"<p>For more details on the OpenAPI specification and understand some details such as security settings, refer to the official swagger.io web site, and the dedicated library to generate the specification file: essentials-openapi.</p> <p>Last modified on: 2023-07-16 08:51:27</p>RVT"},{"location":"openid-connect/","title":"OpenID Connect","text":"<p>BlackSheep implements built-in support for OpenID Connect authentication, meaning that it can be easily integrated with identity provider services such as:</p> <ul> <li>Auth0</li> <li>Azure Active Directory</li> <li>Azure Active Directory B2C</li> <li>Okta</li> </ul> <p>This page documents:</p> <ul> <li> How to use OpenID Connect integration to provide sign-in and sign-up features,   and to identify users who use the application</li> <li> How to use OpenID Connect integration to obtain <code>access_token</code>s to use APIs   (in addition, or instead of <code>id_token</code>s)</li> <li> How tokens are protected and how to configure applications to support   multiple instances and regions</li> </ul> <p>Warning</p> <p>Using JWT Bearer and OpenID integrations requires more dependencies: use <code>pip install blacksheep[full]</code> to use these features</p>"},{"location":"openid-connect/#basic-example","title":"Basic example","text":"<p>A basic example with any of the identity providers listed above, having implicit flow enabled for <code>id_token</code>, looks like the following:</p> <pre><code>from blacksheep import Application, html, pretty_json\nfrom blacksheep.server.authentication.oidc import OpenIDSettings, use_openid_connect\nfrom guardpost.authentication import Identity\n\napp = Application()\n\n\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"&lt;YOUR_AUTHORITY&gt;\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        callback_path=\"&lt;CALLBACK_PATH&gt;\",\n    ),\n)\n\n\n@app.route(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        response = pretty_json(user.claims)\n\n        return response\n\n    return html(\"&lt;a href='/sign-in'&gt;Sign in&lt;/a&gt;&lt;br/&gt;\")\n</code></pre> <p>When the application is configured with <code>use_openid_connect</code>, request handlers are automatically configured to handle users' sign-in, the redirect after a user signs-in, and signs-out. After a user signs-in successfully, a signed and encrypted cookie containing the claims of the <code>id_token</code> is set automatically for the client, having an expiration time matching the expiration time of the <code>id_token</code> itself. User's identity is automatically restored at each web request by an authentication middleware, and can be read as in the provided examples:</p> <pre><code>@app.route(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        ...\n</code></pre>"},{"location":"openid-connect/#use_openid_connect","title":"use_openid_connect","text":"Parameter Type, default Description app Application Instance of BlackSheep application. settings OpenIDSettings Instance of OpenIDSettings. tokens_store Optional[BaseTokensStore] = None Optional instance of <code>BaseTokensStore</code>, used to store and restore <code>access_token</code>s and <code>refresh_token</code>s. parameters_builder Optional[ParametersBuilder] = None Optional instance of <code>ParametersBuilder</code>, used to handle parameters configured in redirects and requests to the authorization server. is_default bool = True If default, clients are automatically redirected to the <code>sign-in</code> page when a non-authenticated user tries to access in <code>GET</code> a web page that requires authentication."},{"location":"openid-connect/#openidsettings","title":"OpenIDSettings","text":"<p>The <code>OpenIDSettings</code> class has the following properties:</p> Parameter Type, default Description client_id str ID of the application in the identity server. authority Optional[str] = None If specified, URL of the authorization server. audience Optional[str] = None If specified, the <code>audience</code> for requests using scopes to an API (ref.). client_secret Optional[str] = None For requests that use <code>Authorization Code Grant</code> flow, the secret of the client application in the identity server. discovery_endpoint Optional[str] = None If specified, the exact URL to the discovery point (useful with Okta when using custom scopes for an authorization server). entry_path str = \"/sign-in\" The local entry-path for sign-in (this redirects to the sign-in page of the identity server). logout_path str = \"/sign-out\" The local path to the sign-out endpoint (this removes authentication cookie). post_logout_redirect_path str = \"/\" The local path to which a user is redirected after signing-out. callback_path str = \"/authorization-callback\" The local path to handle the redirect after a user signs-in (the reply_url in the identity server must be configured accordingly). scope str = \"openid profile email\" The scope of the request, by default an <code>id_token</code> is obtained with email and profile. redirect_uri Optional[str] = None If specified, the redirect URL that must match the one configured for the application. If not provided, a redirect_url is obtained automatically (see note \ud83d\udde1\ufe0f). scheme_name str = \"OpenIDConnect\" The name of the authentication scheme, affecting the name of authentication cookies (see note \ud83c\udf52). error_redirect_path Optional[str] = None If specified, the local path to which a user is redirected in case of error. <p>Notes:</p> <ul> <li>\ud83d\udde1\ufe0f obtaining a redirect_url automatically can require handling of forward   headers, when an application is deployed behind a proxy. See   remotes for more information.</li> <li>\ud83c\udf52 this should be changed when configuring more than one OIDC identity   provider.</li> </ul> <p>Info</p> <p><code>access_token</code>s issued for APIs can be validated using JWT Bearer authentication</p>"},{"location":"openid-connect/#examples-using-custom-scopes","title":"Examples using custom scopes","text":"<p>An integration with a <code>Auth0</code> application that uses custom scopes, where the application obtains both an <code>id_token</code> and an <code>access_token</code> for an API, looks like the following:</p> <pre><code>import os\nfrom blacksheep import Application, html, pretty_json\nfrom blacksheep.server.authentication.oidc import (\n    OpenIDSettings,\n    use_openid_connect,\n    CookiesTokensStore,\n)\nfrom guardpost.authentication import Identity\n\napp = Application()\n\n\n# basic Auth0 integration that handles only an id_token\nuse_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"&lt;YOUR_AUTHORITY&gt;\",\n        audience=\"&lt;API_ID&gt;\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        client_secret=os.environ[\"AUTH0_APP_SECRET\"],\n        callback_path=\"&lt;CALLBACK_PATH&gt;\",\n        scope=\"openid profile custom_scope\",\n    ),\n    tokens_store=CookiesTokensStore(),\n)\n\n\n@app.route(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        response = pretty_json(user.claims)\n\n        return response\n\n    return html(\"&lt;a href='/sign-in'&gt;Sign in&lt;/a&gt;&lt;br/&gt;\")\n</code></pre> <p>An integration with <code>Azure Active Directory</code>:</p> <pre><code>use_openid_connect(\n    app,\n    OpenIDSettings(\n        authority=\"https://login.microsoftonline.com/&lt;YOUR_TENANT_ID&gt;/v2.0/\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        client_secret=os.environ[\"AAD_APP_SECRET\"],\n        scope=\"openid profile custom_scope\",\n    ),\n    tokens_store=CookiesTokensStore(),\n)\n</code></pre> <p>An integration with <code>Okta</code>, using the <code>default</code> authorization server:</p> <pre><code>use_openid_connect(\n    app,\n    OpenIDSettings(\n        discovery_endpoint=\"https://&lt;YOUR_DOMAIN&gt;.okta.com/oauth2/default/.well-known/oauth-authorization-server\",\n        client_id=\"&lt;CLIENT_ID&gt;\",\n        client_secret=os.environ[\"OKTA_APP_SECRET\"],\n        scope=\"openid email custom_scope\",\n    ),\n    tokens_store=CookiesTokensStore(),\n)\n</code></pre>"},{"location":"openid-connect/#events","title":"Events","text":"<p>The API exposes the following events:</p> <pre><code>from blacksheep.server.authentication.oidc import (\n    OpenIDSettings,\n    TokenResponse,\n    use_openid_connect\n)\n\n\noidc = use_openid_connect(...)\n\n\n@oidc.events.on_id_token_validated\nasync def id_token_callback(context, id_token_claims):\n\"\"\"\n    This callback is called after an id_token is received, successfully\n    verified using public RSA keys from the identity provider, and parsed\n\n    Using this event handler is possible to modify the claims obtained from the\n    id_token before they are set in the authentication cookie. For example to\n    remove certain claims, or add other information.\n    \"\"\"\n\n\n@oidc.events.on_tokens_received\nasync def on_tokens_received(context, token_response: TokenResponse):\n\"\"\"\n    This callback is called after a successful web request to the token\n    endpoint to exchange a code with an access_token, and eventually\n    refresh_token, and id_token.\n    \"\"\"\n\n\n@oidc.events.on_error\nasync def on_error(context, data: Dict[str, Any]):\n\"\"\"\n    This callback is called when an error is returned by the authorization\n    server in the redirect handler.\n    Note that this can happen for a common scenario, like the user refusing\n    to grant consent on the application.\n    \"\"\"\n</code></pre>"},{"location":"openid-connect/#storing-tokens","title":"Storing tokens","text":"<p>By default, <code>access_token</code>(s) and <code>refresh_token</code>(s) are not stored. To store them, the <code>use_openid_connect</code> function supports a <code>BaseTokensStore</code> parameter that will handle storing and restoring tokens. A concrete implementation is provided in <code>CookiesTokenStore</code>, storing tokens in cookies. It is possible to create custom implementations of the <code>BaseTokensStore</code>, to use other mechanisms, for example to store tokens in a Redis cache.</p> <p>When a user is authenticated, and has an <code>access_token</code> (and/or a <code>refresh_token</code>), they are accessible through the <code>Identity</code>:</p> <pre><code>@app.route(\"/\")\nasync def home(user: Identity):\n    if user.is_authenticated():\n        print(user.access_token)\n        print(user.refresh_token)\n        ...\n</code></pre> <p>To see how to use a <code>BaseTokensStore</code>, refer to the examples above that use the built-in <code>CookiesTokensStore</code>.</p>"},{"location":"openid-connect/#useful-references","title":"Useful references","text":"<ul> <li>https://auth0.com/docs/security/tokens/access-tokens</li> <li>https://www.oauth.com/oauth2-servers/server-side-apps/possible-errors/</li> <li>https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow</li> <li>https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc</li> <li>https://connect2id.com/learn/openid-connect</li> </ul>"},{"location":"openid-connect/#how-tokens-are-protected","title":"How tokens are protected","text":"<p>Tokens that are stored in cookies are signed and encrypted using <code>itsdangerous</code>, with symmetric encryption. This means that BlackSheep applications need secrets to protect sensitive data. When keys are not specified, they are generated automatically in memory, for best user's experience.</p> <p>Danger</p> <p>This means that keys are not persisted when applications restart, and not consistent when multiple instances of the same application are deployed across regions, or within a same server. This is acceptable during local development, but should not be the case in production environments.</p> <p>To use consistent keys, configure one or more environment variables like the following:</p> <ul> <li>APPSECRET_1=\"***\"</li> <li>APPSECRET_2=\"***\"</li> <li>APPSECRET_3=\"***\"</li> </ul> <p>Keys can be configured in a host environment, or fetched from a dedicated service such as <code>AWS Secrets Manager</code> or <code>Azure Key Vault</code> at application start-up, and configured as environment settings for the application. DO NOT store secrets that are meant to be used in production under source control.</p> <p>For more information, refer to data protection.</p> <p>Last modified on: 2022-11-20 10:54:13</p>RV"},{"location":"remotes/","title":"Remotes","text":"<p>The <code>blacksheep.server.remotes</code> namespace provides classes and functions to handle information related to remote proxies and clients.</p> <p>Web applications in production environments are commonly hosted behind other kinds of servers, such as Apache, IIS, or NGINX. Proxy servers usually obscure some of the information of the original web request before it reaches the web applications.</p> <p>For example:</p> <ul> <li>when HTTPS requests are proxied over HTTP, the original scheme (HTTPS) is   lost and must be forwarded in a header.</li> <li>when an app receives a request from a proxy and not its true source, the   original client IP address must also be forwarded in a header.</li> <li>the path of web requests can be changed while being proxied (e.g. NGINX   configured to proxy requests to <code>/example</code> to the root <code>/</code> of a web   application)</li> </ul> <p>This information may be important in request processing, for example in redirects, authentication, link generation when absolute URLs are needed, and client geolocation.</p> <p>This page documents how to configure BlackSheep to work with proxy servers and load balancers, using provided classes to handle:</p> <ul> <li> X-Forwarded headers</li> <li> Forwarded header</li> <li> Trusted hosts</li> <li> How to read information about the original clients in web requests</li> </ul>"},{"location":"remotes/#handling-x-forwarded-headers","title":"Handling X-Forwarded headers","text":"<p><code>X-Forwarded</code> headers are the de-facto standard headers to propagate information about original web requests to web applications.</p> Header Description X-Forwarded-For Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. X-Forwarded-Host Used to identify the original host requested by the client in the Host HTTP request header X-Forwarded-Proto Used to identify the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. <p>BlackSheep provides a <code>XForwardedHeadersMiddleware</code> class to handle these headers, providing:</p> <ul> <li>optional validation of trusted hosts</li> <li>optional validation of proxies cound and IP addresses by known IPs or known   networks</li> </ul> <p>To configure a BlackSheep web application to handle <code>X-Forwarded</code> headers and configure incoming web requests to expose the correct information about source protocol, client IP, and host:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.forwarding import XForwardedHeadersMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        XForwardedHeadersMiddleware(),\n    )\n</code></pre> <p>Options of the <code>XForwardedHeadersMiddleware</code> class:</p> Parameter Type, default Description allowed_hosts Optional[Sequence[str]] = None Sequence of allowed hosts. If configured, requests that send a different host in the <code>Host</code> header or <code>X-Forwarded-Host</code> header are replied with Bad Request. known_proxies Optional[Sequence[IPAddress]] = None Sequence of allowed proxies IP addresses. If configured, requests that send different proxies IPs in the request scope or <code>X-Forwarded-For</code> header are replied with Bad Request. known_networks Optional[Sequence[IPNetwork]] = None Sequence of allowed proxies networks. If configured, requests that send a foreign proxy IP in the request scope or <code>X-Forwarded-For</code> header are replied with Bad Request. forward_limit int = 1 Maximum number of allowed forwards, by default 1. <p>When <code>known_proxies</code> is not provided, it is set by default to handle <code>localhost</code>: <code>[ip_address(\"127.0.0.1\")]</code>.</p>"},{"location":"remotes/#handling-forwarded-header","title":"Handling Forwarded header","text":"<p>The <code>Forwarded</code> header is a standard header to propagate information about original web requests to web applications.</p> <p>To configure a BlackSheep web application to handle <code>Forwarded</code> headers:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.forwarding import ForwardedHeadersMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        ForwardedHeadersMiddleware(),\n    )\n</code></pre> <p>Options of the <code>ForwardedHeadersMiddleware</code> class:</p> Parameter Type, default Description allowed_hosts Optional[Sequence[str]] = None Sequence of allowed hosts. If configured, requests that send a different host in the <code>Host</code> header or <code>Forwarded</code> header are replied with Bad Request. known_proxies Optional[Sequence[IPAddress]] = None Sequence of allowed proxies IP addresses. If configured, requests that send different proxies IPs in the request scope or <code>Forwarded</code> header are replied with Bad Request. known_networks Optional[Sequence[IPNetwork]] = None Sequence of allowed proxies networks. If configured, requests that send a foreign proxy IP in the request scope or <code>Forwarded</code> header are replied with Bad Request. forward_limit int = 1 Maximum number of allowed forwards, by default 1. <p>When <code>known_proxies</code> is not provided, it is set by default to handle <code>localhost</code>: <code>[ip_address(\"127.0.0.1\")]</code>.</p>"},{"location":"remotes/#handling-trusted-hosts","title":"Handling trusted hosts","text":"<p>When forwarded headers middlewares are not used, but it is necessary to validate hosts, it is possible to use the <code>TrustedHostsMiddleware</code>:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.remotes.hosts import TrustedHostsMiddleware\n\n\napp = Application()\n\n\n@app.on_middlewares_configuration\ndef configure_forwarded_headers(app):\n    app.middlewares.insert(\n        0,\n        TrustedHostsMiddleware([\"www.neoteroi.dev\"]),\n    )\n</code></pre>"},{"location":"remotes/#reading-information-about-the-original-clients-in-web-requests","title":"Reading information about the original clients in web requests","text":"<p>Web requests expose information about the original clients in the following properties, that are updated by forwarded header middlewares:</p> <pre><code>from blacksheep import Request\n\nrequest: Request\n\nrequest.host\nrequest.scheme\nrequest.original_client_ip\n</code></pre> Property Description host Originating host. scheme Originating scheme (\"http\" or \"https\"). original_client_ip Originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer."},{"location":"remotes/#obtaining-the-web-request-absolute-url","title":"Obtaining the web request absolute URL","text":"<p>To obtain the original absolute URL of a web request, use the provided <code>get_absolute_url_to_path</code> and <code>get_request_absolute_url</code> functions:</p> <pre><code>from blacksheep.messages import get_absolute_url_to_path, get_request_absolute_url\n\n\n# examples\nabsolute_url = get_request_absolute_url(request)\n\nabsolute_url_to_path = get_absolute_url_to_path(request, \"/example\")\n</code></pre> <p>Warning</p> <p>When configuring OpenID Connect authentication, it can be necessary to handle forwarded headers, so that the application can generate correct <code>redirect_uri</code> for authorization servers.</p>"},{"location":"remotes/#asgi-root_path","title":"ASGI root_path","text":"<p>When the <code>ASGI</code> scope includes the <code>root_path</code> information, it is automatically used for the request <code>base_path</code> property.</p> <p>Last modified on: 2023-11-19 09:55:17</p>RVT"},{"location":"request-handlers/","title":"Request handlers","text":"<p>The previous pages describe that a request handler in BlackSheep is a function associated to a route,  having the responsibility of handling web requests. This page describes <code>request handlers</code> in detail, presenting the following:</p> <ul> <li> Request handler normalization.</li> <li> Using asynchronous and synchronous code.</li> </ul>"},{"location":"request-handlers/#request-handler-normalization","title":"Request handler normalization.","text":"<p>A normal request handler in BlackSheep is defined as an asynchronous function having the following signature:</p> <pre><code>from blacksheep import Request, Response\n\nasync def normal_handler(request: Request) -&gt; Response:\n    ...\n</code></pre> <p>To be a request handler, a function must be associated to a route:</p> <pre><code>from blacksheep import Application, Request, Response, text\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\nasync def normal_handler(request: Request) -&gt; Response:\n    return text(\"Example\")\n</code></pre> <p>A request handler defined this way is called directly to generate a response when a web request matches the route associated with the function (in this case, HTTP GET on the root of the website \"/\").</p> <p>However, to improve developer's experience and development speed, BlackSheep implements automatic normalization of request handlers. For example it is possible to define a request handler as a synchronous function, the framework automatically wraps the synchronous function into an asynchronous wrapper:</p> <pre><code>@get(\"/sync\")\ndef sync_handler(request: Request) -&gt; Response:\n    return text(\"Example\")\n</code></pre> <p>Similarly, request handlers are normalized when their function signature is different than the normal one. For example a request handler can be defined without arguments, and returning a plain <code>str</code> or an instance of an object (which gets serialized to <code>JSON</code> and configured as response content):</p> <pre><code>@get(\"/greetings\")\ndef hello_there() -&gt; str:\n    return \"Hello, There!\"\n</code></pre> <p>In the example below, the response content is JSON <code>{\"id\":1,\"name\":\"Celine\"}</code>:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Cat:\n    id: int\n    name: str\n\n\n@get(\"/example-cat\")\ndef get_example_cat() -&gt; Cat:\n    return Cat(1, \"Celine\")\n</code></pre>"},{"location":"request-handlers/#automatic-binding-of-parameters","title":"Automatic binding of parameters","text":"<p>An important feature enabled by function normalization is the automatic binding of request parameters, as described in the <code>Getting Started</code> pages. Common scenarios are using route parameters, and query string parameters:</p> <pre><code># in this case, a route parameter is passed directly to the request handler\n@get(\"/greetings/{name}\")\ndef hello(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\n\n# in this case, query string parameters by name are read from the request and\n# passed to the request handler\n@get(\"/api/cats\")\ndef get_cats(page: int = 1, page_size: int = 30, search: str = \"\") -&gt; Response:\n    ...\n</code></pre> <p>In the <code>get_cats</code> example above, function parameters are read automatically from the query string and parsed, if present, otherwise default values are used.</p>"},{"location":"request-handlers/#explicit-and-implicit-binding","title":"Explicit and implicit binding","text":"<p>All examples so far showed how to use implicit binding of request parameters. In the <code>get_cats</code> example above, all parameters are implicitly bound from the request query string. To enable more scenarios, <code>BlackSheep</code> provides also explicit bindings that let specifying the source of the parameter (e.g. request headers, cookies, route, query, body, application services). In the example below, <code>cat_input</code> is read automatically from the request payload as JSON and deserialized automatically into an instance of the <code>CreateCatInput</code> class.</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep.server.bindings import FromJSON\n\n\n@dataclass\nclass CreateCatInput:\n    name: str\n    ...\n\n\n@post(\"/cat\")\nasync def create_cat(\n    cat_input: FromJSON[CreateCatInput]\n):\n    data = cat_input.value\n    ...\n</code></pre> <p>More details about bindings are described in Binders.</p>"},{"location":"request-handlers/#normalization-and-openapi-documentation","title":"Normalization and OpenAPI Documentation","text":"<p>Request handler normalization enables also a more accurate generation of OpenAPI Documentation, since the web framework knows that request handlers need input from query string, routes, headers, cookies, etc.; and produce responses of a certain type.</p>"},{"location":"request-handlers/#using-asynchronous-and-synchronous-code","title":"Using asynchronous and synchronous code.","text":"<p>BlackSheep supports both asynchronous and synchronous request handlers. Request handlers don't need to be asynchronous in those scenarios when the response is well-known and can be produced without doing any I/O bound operation or any CPU intensive operation. This is the case for example of redirects, and the previous \"Hello, There!\" example:</p> <pre><code>from blacksheep import Application, Request, Response, text, redirect\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/sync\")\ndef sync_handler() -&gt; str:\n    return \"Example Sync\"\n\n@get(\"/redirect-me\")\ndef redirect_example() -&gt; Response:\n    return redirect(\"/sync\")\n</code></pre> <p>Request handlers that do I/O bound operations or CPU intensive operations should be instead <code>async</code>, to not impede the work of the web server's loop. For example, if information are fetched from a database or a remote API when handling a web request handler, it is a good practice to use asynchronous code to reduce RAM consumption and not impede the event loop of the web application.</p> <p>Warning</p> <p>If an operation is CPU intensive (e.g. involving file operations, resizing a picture), the request handlers that initiate such operation should be async, and use a thread or process pool to not block the web app's event loop. Similarly, request handlers that initiate I/O bound operations (e.g. web requests to external APIs, connecting to a database) should also be <code>async</code>.</p>"},{"location":"request-handlers/#next","title":"Next","text":"<p>The next pages describe requests and responses in detail.</p> <p>Last modified on: 2023-07-16 08:51:27</p>RV"},{"location":"requests/","title":"Requests","text":"<p>This page describes:</p> <ul> <li> Handling requests.</li> <li> Reading parameters from the request.</li> <li> Reading request headers and cookies.</li> <li> Reading request bodies.</li> </ul>"},{"location":"requests/#the-request-class","title":"The Request class","text":"<p>BlackSheep handles requests as instances of <code>blacksheep.Request</code> class. This class provides methods and properties to handle request headers, cookies, URL, route parameters, request body, user's identity, and other information like the content type of the request. Each web request results in the creation of a new instance of <code>Request</code>.</p>"},{"location":"requests/#reading-parameters-from-the-request-object","title":"Reading parameters from the request object","text":"<p>It is possible to read query and route parameters from an instance of <code>request</code>. The example below shows how query string, route parameters, and request headers can be read from the request:</p> <pre><code>from blacksheep import Application, Request, Response, text\n\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/{something}\")\ndef example(request: Request) -&gt; Response:\n    client_accept = request.headers.get_first(b\"Accept\")\n    # client_accept is None or bytes\n\n    hello = request.query.get(\"hello\")\n    # hello is None or a List[str]\n\n    something = request.route_values[\"something\"]\n    # something is str\n\n    return text(\n        f\"\"\"\n        Accept: {client_accept.decode()}\n        Hello: {hello}\n        Something: {something}\n        \"\"\"\n    )\n</code></pre> <p>However, the recommended approach is to use automatic bindings, which enable a more accurate generation of OpenAPI Documentation, automatic parsing of values into the desired type, and improve development experience and source code.</p> <p>The same example can be achieved in the following way:</p> <pre><code>from blacksheep import Application, Request, Response, text, FromHeader, FromQuery\n\n\napp = Application()\nget = app.router.get\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\n@get(\"/{something}\")\ndef example(\n    something: str, accept: FromAcceptHeader, hello: FromQuery[str]\n) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Hello: {hello.value}\n        Something: {something}\n        \"\"\"\n    )\n</code></pre> <p>HTTP GET <code>/example?hello=World</code>: <pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,mage/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nHello: World\nSomething: example\n</code></pre></p>"},{"location":"requests/#reading-request-headers-and-cookies","title":"Reading request headers and cookies","text":"<pre><code>from typing import Optional\n\nfrom blacksheep import Application, Response, text, FromHeader, FromCookie\n\napp = Application()\nget = app.router.get\n\n\nclass FromAcceptHeader(FromHeader[str]):\n    name = \"Accept\"\n\n\nclass FromFooCookie(FromCookie[Optional[str]]):\n    name = \"foo\"\n\n\n@get(\"/\")\ndef home(accept: FromAcceptHeader, foo: FromFooCookie) -&gt; Response:\n    return text(\n        f\"\"\"\n        Accept: {accept.value}\n        Foo: {foo.value}\n        \"\"\"\n    )\n</code></pre>"},{"location":"requests/#reading-request-body","title":"Reading request body","text":"<p>The request class offers several methods to read request bodies of different kinds.</p>"},{"location":"requests/#reading-json","title":"Reading JSON","text":"Using binders (recommended)Directly from the request <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import FromJSON\n\n\n@dataclass\nclass SomethingInput:\n    name: str\n    foo: bool\n\n\n@post(\"/something\")\nasync def create_something(input: FromJSON[SomethingInput]):\n    data = input.value\n\n    # data is already deserialized from JSON into an instance of\n    # `SomethingInput`\n</code></pre> <p>The type parameter for the <code>FromJSON</code> binder can be a dataclass, a model from <code>pydantic</code>, a regular class with an <code>__init__</code> method.</p> <p>Note that when mapping the request's payload to an instance of the desired type, the type's constructor with <code>cls(**data)</code> is used. If it necessary to parse dates or other complex types this must be done in the constructor of the class. To handle gracefully a payload with extra properties, use <code>*args</code> in your class constructor: <code>__init__(one, two, three, *args)__</code>.</p> <p>To read the JSON payload as a regular dictionary, use <code>dict</code> as type argument:</p> <pre><code>@post(\"/something\")\nasync def create_something(input: FromJSON[dict]):\n    ...\n</code></pre> <p>When the JSON is read from the request object, it is always treated as the raw deserialized object (usually a dictionary or a list).</p> <pre><code>@post(\"/something\")\nasync def create_something(request: Request):\n    data = await request.json()\n\n    # data is the deserialized object\n</code></pre>"},{"location":"requests/#reading-form","title":"Reading form","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromForm\n\n\nclass SomethingInput:\n    name: str\n    foo: bool\n\n    def __init__(self, name: str, foo: str) -&gt; None:\n        self.name = name\n        self.foo = bool(foo)\n\n\n@post(\"/something\")\nasync def create_something(input: FromForm[SomethingInput]):\n    data = input.value\n\n    # data is already deserialized from form into an instance of\n    # `SomethingInput` - however some properties need to be parsed\n    # from str into the desired type in the class definition -\n    # see __init__ above\n</code></pre> <pre><code>@post(\"/something\")\nasync def create_something(request: Request):\n    data = await request.form()\n\n    # data is a dictionary\n</code></pre>"},{"location":"requests/#reading-text","title":"Reading text","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromText\n\n\n@post(\"/something\")\nasync def store_text(text: FromText):\n    data = text.value\n</code></pre> <pre><code>@post(\"/text\")\nasync def create_text(request: Request):\n    data = await request.text()\n\n    # data is a string\n</code></pre>"},{"location":"requests/#reading-raw-bytes","title":"Reading raw bytes","text":"Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromBytes\n\n\n@post(\"/something\")\nasync def example(payload: FromBytes):\n    data = payload.value\n</code></pre> <pre><code>@post(\"/text\")\nasync def example(request: Request):\n    data = await request.read()\n\n    # data is bytes\n</code></pre>"},{"location":"requests/#reading-files","title":"Reading files","text":"<p>Files read from <code>multipart/form-data</code> payload.</p> Using binders (recommended)Directly from the request <pre><code>from blacksheep import FromFiles\n\n\n@post(\"/something\")\nasync def post_files(files: FromFiles):\n    data = files.value\n</code></pre> <pre><code>@post(\"/upload-files\")\nasync def upload_files(request: Request):\n    files = await request.files()\n\n    for part in files:\n        file_bytes = part.data\n        file_name = file.file_name.decode()\n\n    ...\n</code></pre>"},{"location":"requests/#reading-streams","title":"Reading streams","text":"<p>Reading streams enables reading bodies of big size using asynchronous generator. The example below saves a file of arbitrary size without blocking the event loop:</p> Directly from the request <pre><code>from blacksheep import created\n\n\n@post(\"/upload\")\nasync def save_big_file(request: Request):\n\n    with open(\"./data/0001.dat\", mode=\"wb\") as saved_file:\n        async for chunk in request.stream():\n            saved_file.write(chunk)\n\n    return created()\n</code></pre> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"responses/","title":"Responses","text":"<p>This page describes:</p> <ul> <li> How responses are handled.</li> <li> Helper functions to handle responses.</li> <li> Responses using asynchronous generators.</li> </ul>"},{"location":"responses/#the-response-class","title":"The Response class","text":"<p>A normal request handler in BlackSheep is expected to return an instance of the <code>blacksheep.Response</code> class. Users of the framework can define request handlers that return different kinds of objects, in such case they are normalized at application start-up, to return instances of <code>Response</code>.</p> <p>The following example shows how to use the low level objects to create a response with status 200 and body \"Hello, World\":</p> <pre><code>from blacksheep import Application, Response, Content\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    return Response(200, content=Content(b\"text/plain\", b\"Hello, World!\"))\n</code></pre> <p><code>BlackSheep</code> uses these exact types to benefit from static typing and compilation of <code>Cython</code> extensions. However, handling responses this way is not comfortable for regular use. For this reason a number of helper functions are provided to create <code>Response</code> objects with a simpler code API.</p> <p>For example, the <code>json</code> function in <code>blacksheep.server.responses</code> produces a response object having a JSON body.</p> <pre><code>from blacksheep import Application, json\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\ndef home():\n    return json({\"message\": \"Hello, World!\"})\n</code></pre> <p>Produces the following response body:</p> <pre><code>{\"message\":\"Hello, World!\"}\n</code></pre> <p>The framework also allows to define a request handler this way:</p> <pre><code>from blacksheep import Application\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\ndef home():\n    return {\"message\": \"Hello, World!\"}\n</code></pre> <p>Note that, when a request handler doesn't specify a <code>Response</code> return type with type annotations, the framework checks the function's return type at each call (causing a small performance fee!), and automatically prepares a <code>Response</code> if necessary.</p>"},{"location":"responses/#functions-in-blacksheepserverresponses","title":"Functions in <code>blacksheep.server.responses</code>","text":"<p>Info</p> <p>Note that you can import these functions from the <code>blacksheep</code> package itself.</p> <p>The table below describes the built-in functions to produce responses:</p> Method Description ok Returns an HTTP 200 OK response, with optional message; sent as plain text or JSON. status_code Returns a plain response with given status, with optional message; sent as plain text or JSON. created Returns an HTTP 201 Created response, to the given location and with optional JSON content. accepted Returns an HTTP 202 Accepted response, with optional message; sent as plain text or JSON. no_content Returns an HTTP 204 No Content response. json Returns a response with application/json content, and given status (default HTTP 200 OK). pretty_json Returns a response with indented application/json content, and given status (default HTTP 200 OK). text Returns a response with text/plain content, and given status (default HTTP 200 OK). moved_permanently Returns an HTTP 301 Moved Permanently response, to the given location. redirect Returns an HTTP 302 Found response (commonly called redirect), to the given location. see_other Returns an HTTP 303 See Other response, to the given location. not_modified Returns an HTTP 304 Not Modified response. temporary_redirect Returns an HTTP 307 Temporary Redirect response, to the given location. permanent_redirect Returns an HTTP 308 Permanent Redirect response, to the given location. bad_request Returns an HTTP 400 Bad Request response, with optional message; sent as plain text or JSON. unauthorized Returns an HTTP 401 Unauthorized response, with optional message; sent as plain text or JSON. forbidden Returns an HTTP 403 Forbidden response, with optional message; sent as plain text or JSON. not_found Returns an HTTP 404 Not Found response, with optional message; sent as plain text or JSON. view Returns a view rendered synchronously. view_async Returns a view rendered asynchronously. file Returns a binary file response with given content type and optional file name, for download (attachment) (default HTTP 200 OK). This method supports both call with bytes, or a generator yielding chunks. <p>For information on how to use these methods, refer to the type annotations provided in the code.</p> <p></p> <p>Info</p> <p>Using an IDE like JetBrains PyCharm, or Visual Studio Code (as in the screenshot above), enables automatic completion and hints thanks to type annotations.</p>"},{"location":"responses/#response-headers","title":"Response headers","text":"<p>To specify response headers use one of the following methods:</p> <pre><code>@get(\"/\")\ndef home():\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.add_header(b\"Example\", b\"Value\")\n\n    # add supports multiple headers with same name:\n    response.headers.add(b\"X-Foo\", b\"Foo\")\n\n    # set syntax overrides other headers with the same name:\n    response.headers[b\"Set-Header-Overriding\"] = b\"Foo\"\n\n    return response\n</code></pre> <p>Note that <code>BlackSheep</code> enforces specifying header names and values as <code>bytes</code>, not strings.</p> <p>Warning</p> <p>This might change in a future version.</p>"},{"location":"responses/#setting-cookies","title":"Setting cookies","text":"<p>To set a cookie, use the <code>set_cookie</code> method of the <code>Response</code> class:</p> <pre><code>from blacksheep import Application, json\nfrom blacksheep.cookies import Cookie\n\napp = Application()\nget = app.router.get\n\n\n@get(\"/\")\ndef home():\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookie(Cookie(\"foo\", \"value\"))\n\n    return response\n</code></pre> <p>The <code>set_cookie</code> method is an abstraction layer on top of the <code>Set-Cookie</code> response header.</p> <p>The following example shows how to set a cookie with <code>HttpOnly</code> and lasting 15 minutes.</p> <pre><code>from datetime import datetime, timedelta\n\nfrom blacksheep import Application, Response, json\nfrom blacksheep.cookies import Cookie\n\napp = Application(show_error_details=True)\nget = app.router.get\n\n\n@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookie(\n        Cookie(\n            \"foo2\",\n            \"value2\",\n            http_only=True,\n            expires=datetime.utcnow() + timedelta(minutes=15),\n        )\n    )\n\n    return response\n</code></pre> <p>Cookie's options:</p> Parameter Type (default value) Description name <code>str</code> Cookie's name. value <code>str</code> Cookie's value. expires <code>datetime | null</code> (<code>null</code>) The maximum lifetime of the cookie as an HTTP-date timestamp. If unspecified, the cookie becomes a session cookie. A session finishes when the client shuts down, and session cookies will be removed. domain <code>str | null</code> (<code>null</code>) Host to which the cookie will be sent. path <code>str | null</code> (<code>null</code>) Optional path to restrict access to the cookie. http_only <code>bool</code> (<code>False</code>) Optional boolean to forbid JavaScript access to the cookie. secure <code>bool</code> (<code>False</code>) Optionally instructs browsers to send the cookie only over HTTPS (or <code>localhost</code>). max_age <code>int</code> (<code>-1</code>) Optional number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. same_site <code>CookieSameSiteMode</code> (CookieSameSiteMode.UNDEFINED) Controls the cookie's <code>Same-Site</code> attribute."},{"location":"responses/#cookiesamesitemode-enum","title":"<code>CookieSameSiteMode</code> enum","text":"Value Description UNDEFINED Doesn't set the <code>Same-Site</code> attribute, leaving the default to the client. LAX Sets <code>Same-Site=Lax</code> attribute. STRICT Sets <code>Same-Site=Strict</code> attribute NONE Sets <code>Same-Site=None</code> attribute <ul> <li>Strict: The browser sends the cookie only for same-site requests (that is,   requests originating from the same site that set the cookie). If the request   originated from a different URL than the current one, no cookies with the   SameSite=Strict attribute are sent.</li> <li>Lax: The cookie is not sent on cross-site requests, such as calls to load   images or frames, but is sent when a user is navigating to the origin site   from an external site (e.g. if following a link). This is the default   behavior if the SameSite attribute is not specified.</li> <li>None: The browser sends the cookie with both cross-site and same-site   requests. The <code>Secure</code> attribute is automatically set when <code>SameSite=None</code>.</li> </ul>"},{"location":"responses/#setting-many-cookies","title":"Setting many cookies","text":"<p>Use the <code>Response.set_cookies</code> method to set several cookies at the same time.</p> <pre><code>@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.set_cookies(\n        [\n            Cookie(\"A\", \"lorem\"),\n            Cookie(\"B\", \"ipsum\"),\n        ]\n    )\n\n    return response\n</code></pre>"},{"location":"responses/#unsetting-cookies","title":"Unsetting cookies","text":"<p>Use the <code>Response.unset_cookie</code> method to delete a cookie that was previously sent to a client.</p> <pre><code>@get(\"/\")\ndef home() -&gt; Response:\n    response = json({\"message\": \"Hello, World!\"})\n\n    response.unset_cookie(\"foo\")\n\n    return response\n</code></pre> <p>The <code>unset_cookie</code> method is an abstraction layer, configuring a <code>Set-Cookie</code> response header containing an instruction to remove a cookie by name.</p>"},{"location":"responses/#removing-cookies","title":"Removing cookies","text":"<p>Use the <code>Response.remove_cookie</code> method to remove a cookie from the response object before it's sent to the client. Note that this method does not generate a <code>Set-Cookie</code> header.</p>"},{"location":"responses/#chunked-encoding","title":"Chunked encoding","text":"<p>The following example shows how chunked encoding can be used in responses, using a <code>StreamedContent</code> object bound to a generator yielding bytes.</p> <pre><code>import asyncio\nfrom blacksheep import Application, Response, StreamedContent\n\napp = Application(show_error_details=True)\n\n\n@app.router.get(\"/chunked-text\")\nasync def get_chunked_text(request):\n    async def provider():\n        yield b\"Lorem \"\n        await asyncio.sleep(0.01)\n        yield b\"ipsum\"\n        await asyncio.sleep(0.01)\n        yield b\" dolor\"\n        yield b\" sit\"\n        yield b\"\"\n\n    return Response(200, content=StreamedContent(b\"text/plain\", provider))\n</code></pre> <p>Alternatively, it is possible to use the <code>file</code> function from <code>blacksheep.server.responses</code> or directly from <code>blacksheep</code>:</p> <pre><code>import asyncio\nfrom blacksheep import Application, file, ContentDispositionType\n\napp = Application(show_error_details=True)\n\n\n@app.router.get(\"/chunked-text\")\nasync def get_chunked_text(request):\n    async def provider():\n        yield b\"Lorem \"\n        await asyncio.sleep(0.01)\n        yield b\"ipsum\"\n        await asyncio.sleep(0.01)\n        yield b\" dolor\"\n        yield b\" sit\"\n        yield b\"\"\n\n    return file(\n        provider, \"text/plain\", content_disposition=ContentDispositionType.INLINE\n    )\n</code></pre> <p>Info</p> <p>BlackSheep uses chunked encoding by default when serving static files.</p> <p>Last modified on: 2022-03-13 13:09:28</p>RV"},{"location":"routing/","title":"Routing","text":"<p>Server side routing refers to the ability of a web application to handle web requests using different functions, depending on URL path and HTTP method. Each <code>BlackSheep</code> application is bound to a router, which provides several ways to define routes. A function that is bound to a route is called \"request handler\", since its responsibility is to handle web requests and produce responses.</p> <p>This page describes:</p> <ul> <li> How to define request handlers.</li> <li> How to use route parameters.</li> <li> How to define a catch-all route.</li> <li> How to define a fallback route.</li> </ul>"},{"location":"routing/#defining-request-handlers","title":"Defining request handlers","text":"<p>A request handler is a function used to produce responses. To become request handlers, functions must be bound to a route, that represents a certain URL path pattern. The <code>Router</code> class provides several methods to define request handlers: with decorators (\ud83d\udde1\ufe0f in the table below) and without decorators (\ud83d\udee1\ufe0f):</p> Router method HTTP method Type head HEAD \ud83d\udde1\ufe0f get GET \ud83d\udde1\ufe0f post POST \ud83d\udde1\ufe0f put PUT \ud83d\udde1\ufe0f delete DELETE \ud83d\udde1\ufe0f trace TRACE \ud83d\udde1\ufe0f options OPTIONS \ud83d\udde1\ufe0f connect CONNECT \ud83d\udde1\ufe0f patch PATCH \ud83d\udde1\ufe0f add_head HEAD \ud83d\udee1\ufe0f add_get GET \ud83d\udee1\ufe0f add_post POST \ud83d\udee1\ufe0f add_put PUT \ud83d\udee1\ufe0f add_delete DELETE \ud83d\udee1\ufe0f add_trace TRACE \ud83d\udee1\ufe0f add_options OPTIONS \ud83d\udee1\ufe0f add_connect CONNECT \ud83d\udee1\ufe0f add_patch PATCH \ud83d\udee1\ufe0f"},{"location":"routing/#with-decorators","title":"With decorators","text":"<p>The following example shows how to define a request handler for the root path of a web application \"/\":</p> <pre><code>from blacksheep import Application, text\n\napp = Application(show_error_details=True)\n\n\n@app.router.get(\"/\")\ndef hello_world():\n    return \"Hello World\"\n</code></pre> <p>It is possible to assign router methods to variables, to reduce code verbosity:</p> <pre><code>from blacksheep import Application, text\n\napp = Application(show_error_details=True)\nget = app.router.get\npost = app.router.post\n\n\n@get(\"/\")\ndef hello_world():\n    return \"Hello World\"\n\n\n@post(\"/message\")\ndef create_message(text: str):\n    return \"TODO\"\n</code></pre> <p>Alternatively, the application offers a <code>route</code> method:</p> <pre><code>@app.route(\"/foo\")\nasync def example_foo():\n    # HTTP GET /foo\n    return \"Hello, World!\"\n\n\n@app.route(\"/example\", methods=[\"GET\", \"HEAD\", \"TRACE\"])\nasync def example():\n    # HTTP GET /example\n    # HTTP HEAD /example\n    # HTTP TRACE /example\n    return \"Hello, World!\"\n</code></pre>"},{"location":"routing/#without-decorators","title":"Without decorators","text":"<p>Request handlers can be registered without decorators:</p> <pre><code>def hello_world():\n    return \"Hello World\"\n\n\napp.router.add_get(\"/\", hello_world)\napp.router.add_options(\"/\", hello_world)\n</code></pre>"},{"location":"routing/#request-handlers-as-class-methods","title":"Request handlers as class methods","text":"<p>Request handlers can also be configured as class methods, defining classes that inherit the <code>blacksheep.server.controllers.Controller</code> class (name taken from the MVC architecture):</p> <pre><code>from dataclasses import dataclass\n\nfrom blacksheep import Application, text, json\nfrom blacksheep.server.controllers import Controller, get, post\n\n\napp = Application()\n\n\n# example input contract:\n@dataclass\nclass CreateFooInput:\n    name: str\n    nice: bool\n\n\nclass Home(Controller):\n\n    def greet(self):\n        return \"Hello World\"\n\n    @get(\"/\")\n    async def index(self):\n        # HTTP GET /\n        return text(self.greet())\n\n    @get(\"/foo\")\n    async def foo(self):\n        # HTTP GET /foo\n        return json({\"id\": 1, \"name\": \"foo\", \"nice\": True})\n\n    @post(\"/foo\")\n    async def create_foo(self, foo: CreateFooInput):\n        # HTTP POST /foo\n        # with foo instance automatically injected parsing the request body as JSON\n        # if the value cannot be parsed as CreateFooInput, Bad Request is returned automatically\n        return json({\"status\": True})\n</code></pre>"},{"location":"routing/#route-parameters","title":"Route parameters","text":"<p>BlackSheep supports three ways to define route parameters:</p> <ul> <li><code>\"/:example\"</code> - using a single colon after a slash</li> <li><code>\"/{example}\"</code> - using curly braces</li> <li><code>\"/&lt;example&gt;\"</code> - using angle brackets (i.e. Flask notation)</li> </ul> <p>Route parameters can be read from <code>request.route_values</code>, or injected automatically by request handler's function signature:</p> <pre><code>@get(\"/{example}\")\ndef handler(request):\n    # reading route values from the request object:\n    value = request.route_values[\"example\"]\n\n    return text(value)\n\n\n@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id):\n    # cat_id is injected automatically\n    ...\n</code></pre> <p>It is also possible to specify the expected type, using standard <code>typing</code> annotations:</p> <pre><code>@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id: int):\n    ...\n</code></pre> <pre><code>from uuid import UUID\n\n\n@get(\"/api/cats/{cat_id}\")\ndef get_cat(cat_id: UUID):\n    ...\n</code></pre> <p>In this case, BlackSheep will automatically produce an <code>HTTP 400 Bad Request</code> response if the input cannot be parsed into the expected type, producing a response body similar to this one:</p> <pre><code>Bad Request: Invalid value ['asdas'] for parameter `cat_id`; expected a valid\nUUID.\n</code></pre>"},{"location":"routing/#value-patterns","title":"Value patterns","text":"<p>By default, route parameters are matched by any string until the next slash \"/\" character. Having the following route:</p> <pre><code>@get(\"/api/movies/{movie_id}/actors/{actor_id}\")\ndef get_movie_actor_details(movie_id: str, actor_id: str):\n    ...\n</code></pre> <p>HTTP GET requests having the following paths are all matched:</p> <pre><code>/api/movies/12345/actors/200587\n\n/api/movies/Trading-Places/actors/Denholm-Elliott\n\n/api/movies/b5317165-ad31-47e2-8a2d-42dba8619b31/actors/a601d8f2-a1ab-4f20-aebf-60eda8e89df0\n</code></pre> <p>However, the framework supports more granular control on the expected value pattern. For example, to specify that <code>movie_id</code> and <code>actor_id</code> must be integers, it is possible to define route parameters this way:</p> <pre><code>\"/api/movies/{int:movie_id}/actors/{int:actor_id}\"\n</code></pre> <p>Warning</p> <p>Value patterns only affect the regular expression used to match requests' URLs. They don't affect the type of the parameter after a web request is matched. Use type annotations as described above to enforce types of the variables as they are passed to the request handler.</p> <p>The following value patterns are built-in:</p> Value pattern Description str Any value that doesn't contain a slash \"/\". int Any value that contains only numeric characters. float Any value that contains only numeric characters and eventually a dot with digits. path Any value to the end of the path. uuid Any value that matches the UUID value pattern. <p>To define custom value patterns, extend the <code>Route.value_patterns</code> dictionary. The key of the dictionary is the name used by the parameter, while the value is a regular expression used to match the parameter's fragment. For example, to define a custom value pattern for route parameters composed of exactly two letters between <code>a-z</code> and <code>A-Z</code>:</p> <pre><code>Route.value_patterns[\"example\"] = r\"[a-zA-Z]{2}\"\n</code></pre> <p>And then use it in routes:</p> <pre><code>\"/{example:foo}\"\n</code></pre>"},{"location":"routing/#catch-all-routes","title":"Catch-all routes","text":"<p>To define a catch-all route that will match every request, use a route parameter with path value pattern, like:</p> <ul> <li><code>{path:name}</code>, or <code>&lt;path:name&gt;</code></li> </ul> <pre><code>from blacksheep import text\n\n\n@get(\"/catch-all/{path:sub_path}\")\ndef catch_all(sub_path: str):\n    return text(sub_path)\n</code></pre> <p>For example, a request at <code>/catch-all/anything/really.js</code> would be matched by the route above, and the <code>sub_path</code> value would be <code>anything/really.js</code>.</p> <p>It is also possible to define a catch-all route using a star sign <code>*</code>. To read the portion of the path catched by the star sign from the request object, read the \"tail\" property of <code>request.route_values</code>. But in this case the value of the catched path can only be read from the request object.</p> <pre><code>@get(\"/catch-all/*\")\ndef catch_all(request):\n    sub_path = request.route_values[\"tail\"]\n</code></pre>"},{"location":"routing/#defining-a-fallback-route","title":"Defining a fallback route","text":"<p>To define a fallback route that handles web requests not handled by any other route, use <code>app.router.fallback</code>:</p> <pre><code>def fallback():\n    return \"OOPS! Nothing was found here!\"\n\n\napp.router.fallback = fallback\n</code></pre> <p>Last modified on: 2023-04-14 19:58:39</p>RVT"},{"location":"sessions/","title":"Sessions","text":"<p>BlackSheep implements built-in support for sessions, which are handled through digitally signed cookies. This page describes how to use sessions with the built-in classes.</p>"},{"location":"sessions/#enabling-sessions","title":"Enabling sessions","text":"<p>To enable sessions, use the <code>app.use_sessions</code> method as in the example below:</p> <pre><code>from blacksheep import Application, Request, text\n\napp = Application()\n\n\napp.use_sessions(\"&lt;SIGNING_KEY&gt;\")\n\n\n@app.route(\"/\")\ndef home(request: Request):\n    session = request.session\n\n    session[\"example\"] = \"Lorem ipsum\"\n\n    return text(session[\"example\"])\n</code></pre> <p>The <code>use_sessions</code> method accepts the following parameters:</p> Name Description Defaults to secret_key required secret key used for signing N/A session_cookie optional session cookie name \"session\" serializer optional <code>blacksheep.sessions.Serializer</code> to serialize and deserialize session values <code>blacksheep.sessions.JSONSerializer</code> signer optional <code>itsdangerous.Serializer</code> to sign and encrypt the session cookie <code>itsdangerous.URLSafeTimedSerializer</code> encryptor (deprecated) optional <code>blacksheep.sessions.Encryptor</code> to encrypt the session cookie <code>None</code> session_max_age Optional session max age, in seconds <code>None</code> <pre><code>    def use_sessions(\n        self,\n        secret_key: str,\n        *,\n        session_cookie: str = \"session\",\n        serializer: Optional[SessionSerializer] = None,\n        signer: Optional[Signer] = None,\n        encryptor: Optional[Encryptor] = None,\n        session_max_age: Optional[int] = None,\n    ) -&gt; None:\n        ...\n</code></pre> <p>The built-in sessions middleware uses <code>itsdangerous</code> to sign, encrypt, and verify session cookies. Refer to data protection for more information on how tokens are signed and encrypted.</p>"},{"location":"sessions/#using-sessions","title":"Using sessions","text":"<p>When sessions are enabled, they are always populated for the <code>request</code> object, and can be accessed through the <code>request.session</code> property.</p> <p>The sessions middleware takes care of setting a response cookie whenever the session is modified, session cookies are signed and encrypted by default.</p> <pre><code>@app.route(\"/\")\ndef home(request: Request):\n    session = request.session\n\n    # setting a value\n    session[\"example\"] = \"Lorem ipsum\"\n\n    # getting a value\n    foo = session.get(\"foo\")\n\n    # getting a value with default\n    foo = session.get(\"foo\", 100)\n\n    # getting a value (can produce KeyError)\n    foo = session[\"foo\"]\n\n    # checking if a key is set\n    if \"something\" in session:\n        ...\n\n    # deleting a key\n    del session[\"something\"]\n\n    # update with many values\n    session.update({\"a\": 1, \"b\": 2})\n\n    return text(session[\"example\"])\n</code></pre> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"settings/","title":"Settings","text":"<p>While most settings are described in sections that are dedicated to other topics, this page describes other settings that can be used in BlackSheep. This page describes:</p> <ul> <li> features to describe the environment of a BlackSheep web applications.</li> <li> features to control JSON serialization and deserialization</li> </ul>"},{"location":"settings/#environmental-variables","title":"Environmental variables","text":"Name Category Description APP_ENV Settings This environment variable is read to determine the environment of the application. For more information, refer to Defining application environment. APP_SHOW_ERROR_DETAILS Settings If \"1\" or \"true\", configures the application to display web pages with error details in case of HTTP 500 Internal Server Error. APP_MOUNT_AUTO_EVENTS Settings If \"1\" or \"true\", automatically binds lifecycle events of mounted apps between children and parents BlackSheep applications. APP_SECRET_i Secrets Allows to configure the secrets used by the application to protect data. BLACKSHEEP_SECRET_PREFIX Secrets Allows to specify the prefix of environment variables used to configure application secrets, defaults to \"APP_SECRET\" if not specified."},{"location":"settings/#defining-application-environment","title":"Defining application environment","text":"<p>BlackSheep implements a strategy to configure the environment of the application. This configuration is useful to support enabling certain features depending on the environment. For example:</p> <ul> <li>HTTP Strict Transport Security can be disabled for local development.</li> <li>Displaying error details can be enabled only when developing locally.</li> <li>When developing locally, application settings can be read from the user's   folder.</li> </ul> <p>The module <code>blacksheep.server.env</code> offers two functions that can be used to control behavior depending on app environment:</p> Function True if <code>APP_ENV</code> is... Description <code>is_development</code> \"local\", \"dev\", or \"development\" Returns a value indicating whether the application is running for a development environment. <code>is_production</code> <code>None</code>, \"prod\", or \"production\" Returns a value indicating whether the application is running for a production environment. <p>The two functions read the environment variable <code>APP_ENV</code>. If <code>APP_ENV</code> is not specified, the application defaults to production.</p> <p>In the following example, the error details page displayed for unhandled exceptions is enabled only for development, while HTTP Strict Transport Security is only enabled for all other environments.</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.env import is_development\nfrom blacksheep.server.security.hsts import HSTSMiddleware\n\napp = Application()\n\n\nif is_development():\n    app.show_error_details = True\nelse:\n    app.middlewares.append(HSTSMiddleware())\n</code></pre>"},{"location":"settings/#configuring-json-settings","title":"Configuring JSON settings","text":"<p>BlackSheep supports configuring the functions that are used for JSON serialization and deserialization in the web framework.</p> <p>By default, the built-in <code>json</code> module is used for serializing and deserializing objects, but this can be changed in the way illustrated below.</p> <pre><code>from blacksheep.plugins import json\n\n\ndef custom_loads(value):\n\"\"\"\n    This function is responsible of parsing JSON into instances of objects.\n    \"\"\"\n\n\ndef custom_dumps(value):\n\"\"\"\n    This function is responsible of creating JSON representations of objects.\n    \"\"\"\n\n\njson.use(\n    loads=custom_loads,\n    dumps=custom_dumps,\n)\n</code></pre> <p>Info</p> <p>BlackSheep uses by default a friendlier handling of <code>json.dumps</code> that supports serialization of common objects such as <code>UUID</code>, <code>date</code>, <code>datetime</code>, <code>bytes</code>, <code>@dataclass</code>, <code>pydantic</code> models, etc.</p>"},{"location":"settings/#example-using-orjson","title":"Example: using orjson","text":"<p>To use <code>orjson</code> for JSON serialization and deserialization with the built-in <code>responses</code> and <code>JSONContent</code> class, it can be configured this way:</p> <pre><code>import orjson\n\nfrom blacksheep.plugins import json\n\n\ndef serialize(value) -&gt; str:\n    return orjson.dumps(value).decode(\"utf8\")\n\n\njson.use(\n    loads=orjson.loads,\n    dumps=serialize,\n)\n</code></pre> <p>Note: the <code>decode(\"utf8\")</code> call is required when configuring <code>orjson</code> for the built-in <code>responses</code> functions and the <code>JSONContent</code> class. This is because <code>orjson.dumps</code> function returns <code>bytes</code> instead of <code>str</code>, and this is something specific to <code>orjson</code> implementation, different than the behavior of the built-in <code>json</code> package and other libraries like <code>rapidjson</code>, <code>UltraJSON</code>, and <code>fast-json</code>. The API implemented in <code>blacksheep</code> expects a JSON serialize function that returns a <code>str</code> like in the built-in package.</p> <p>For users using <code>orjson</code> who want to achieve the best performance and avoid the fee of the superfluous <code>decode -&gt; encode</code> passage, it is recommended to:</p> <ul> <li>not use the built-in <code>responses</code> functions and the built-in <code>JSONContent</code>   class</li> <li>use a custom defined function for JSON responses like the following example:</li> </ul> <pre><code>def my_json(data: Any, status: int = 200) -&gt; Response:\n\"\"\"\n    Returns a response with application/json content,\n    and given status (default HTTP 200 OK).\n    \"\"\"\n    return Response(\n        status,\n        None,\n        Content(\n            b\"application/json\",\n            orjson.dumps(data),\n        ),\n    )\n</code></pre>"},{"location":"settings/#example-applying-transformations-during-json-operations","title":"Example: applying transformations during JSON operations","text":"<p>The example below illustrates how to apply transformations to objects while they are serialized and deserialized. Beware that the example only illustrates this possibility, it doesn't handle objects inside lists, <code>@dataclass</code>, or <code>pydantic</code> models!</p> <pre><code>import json\nfrom typing import Any\n\nfrom blacksheep.plugins import json as json_plugin\nfrom essentials.json import dumps\n\n\ndef default_json_dumps(obj):\n    return dumps(obj, separators=(\",\", \":\"))\n\n\ndef custom_loads(value: str) -&gt; Any:\n    # example: applies a transformation when deserializing an object from JSON\n    # this can be used for example to change property names upon deserialization\n\n    obj = json.loads(value)\n\n    if isinstance(obj, dict) and \"@\" in obj:\n        obj[\"modified_key\"] = obj[\"@\"]\n        del obj[\"@\"]\n\n    return obj\n\n\ndef custom_dumps(value: Any) -&gt; str:\n    # example: applies a transformation when serializing an object into JSON\n    # this can be used for example to change property names upon serialization\n\n    if isinstance(value, dict) and \"@\" in value:\n        value[\"modified_key\"] = value[\"@\"]\n        del value[\"@\"]\n\n    return default_json_dumps(value)\n\n\njson_plugin.use(\n    loads=custom_loads,\n    dumps=custom_dumps,\n)\n</code></pre> <p>Last modified on: 2023-04-17 19:20:50</p>"},{"location":"static-files/","title":"Serving static files","text":"<p>This page covers:</p> <ul> <li> How to serve static files.</li> <li> Options for static files.</li> <li> Non-obvious features handled when serving static files.</li> <li> How to serve a Single Page Application (SPA) that uses the HTML5 History API</li> </ul> <p>To serve static files, use the method <code>app.serve_files</code> as in the following example:</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\n# serve files contained in a \"static\" folder relative to the server cwd\napp.serve_files(\"static\")\n</code></pre> <p>The path can be a relative one compared to the application <code>cwd</code>, or an absolute path.</p> <p>When serving files this way, a match-all route (\"*\") is configured in the application router for <code>GET</code> and <code>HEAD</code>, and files are read from the configured folder upon web requests.</p> <p>It is also possible to serve static files from sub-folders:</p> <pre><code>app.serve_files(\"app/static\")\n</code></pre> <p>Enable file discovery (in such case, requests for directories will generate an HTML response with a list of files):</p> <pre><code>app.serve_files(\"app/static\", discovery=True)\n</code></pre> <p>BlackSheep also supports serving static files from multiple folders, and specifying a prefix for the route path:</p> <pre><code>app = Application()\n\n# serve files contained in a \"static\" folder relative to the server cwd\napp.serve_files(\"app/images\", root_path=\"images\")\napp.serve_files(\"app/videos\", root_path=\"videos\")\n</code></pre>"},{"location":"static-files/#file-extensions","title":"File extensions","text":"<p>Only files with configured extension are served to the client. By default, only files with these extensions are served (case insensitive check):</p> <pre><code>'.txt',\n'.css',\n'.js',\n'.jpeg',\n'.jpg',\n'.html',\n'.ico',\n'.png',\n'.woff',\n'.woff2',\n'.ttf',\n'.eot',\n'.svg',\n'.mp4',\n'.mp3'\n</code></pre> <p>To configure extensions, use the dedicated parameter:</p> <pre><code>app.serve_files(\"static\", extensions={'.foo', '.config'})\n</code></pre>"},{"location":"static-files/#accept-ranges-and-range-requests","title":"Accept-Ranges and Range requests","text":"<p>Range requests are enabled and handled by default (since version <code>0.2.1</code>), meaning that BlackSheep supports serving big files with pause and resume feature, and serving videos with the possibility to jump to specific points.</p>"},{"location":"static-files/#etag-and-if-none-match","title":"ETag and If-None-Match","text":"<p><code>ETag</code>, <code>If-None-Match</code> and HTTP Status 304 Not Modified are handled automatically, as well as support for <code>HEAD</code> requests returning only headers with information about the files.</p>"},{"location":"static-files/#configurable-cache-control","title":"Configurable Cache-Control","text":"<p>To control <code>Cache-Control</code> <code>max-age</code> HTTP header, use <code>cache_time</code> parameter (defaults to 10800 seconds).</p> <pre><code>app.serve_files(\"static\", cache_time=90000)\n</code></pre>"},{"location":"static-files/#how-to-serve-spas-that-use-html5-history-api","title":"How to serve SPAs that use HTML5 History API","text":"<p>To serve an SPA that uses HTML5 History API, configure files serving with a <code>fallback_document=\"index.html\"</code> if the index file is called \"index.html\" (like it happens in most scenarios).</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\napp.serve_files(\n    \"/path/to/folder/containing/spa\",\n    fallback_document=\"index.html\",\n)\n</code></pre> <p>If the SPA uses a file with a different name, specify both index file name and fallback document to be the same:</p> <pre><code>from blacksheep import Application\n\napp = Application()\n\napp.serve_files(\n    \"/path/to/folder/containing/spa\",\n    index_document=\"example.html\",\n    fallback_document=\"example.html\",\n)\n</code></pre> <p>Last modified on: 2022-02-16 07:52:42</p>RV"},{"location":"templating/","title":"Server Side Rendering (SSR)","text":"<p>Server side templating refers to the ability of a web application to generate HTML pages from templates and dynamic variables. BlackSheep does this using the wondeful <code>Jinja2</code> library by the Pallets team.</p> <p>This page describes:</p> <ul> <li> How to configure server side templating.</li> <li> Returning views using response functions.</li> <li> Returning views using the MVC features.</li> </ul> <p>Info</p> <p>The BlackSheep MVC project template includes a ready-to-use solution having an application with templates and layout configured.</p>"},{"location":"templating/#configuration","title":"Configuration","text":"<p>This example shows how to use Jinja2 templating engine with BlackSheep:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\napp = Application(show_error_details=True, debug=True)\nget = app.router.get\n\n# NB: this example requires a package called \"app\";\n# containing a 'templates' folder\n# The server file must be in the same folder that contains \"app\"\nview = use_templates(app, loader=PackageLoader(\"app\", \"templates\"))\n\n\n@get(\"/\")\ndef home():\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre> <p>The expected folder structure for this example: <pre><code>\u2b11 app\n     \u2b11 templates\n          home.html   &lt;-- template file loaded by `view` function\n     __init__.py\n\nserver.py\n</code></pre></p> <pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt;\n  &lt;meta name=\"description\" content=\"Example.\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{example}}&lt;/h1&gt;\n  &lt;p&gt;{{foo}}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>If the <code>use_templates</code> function is called more than once, the Jinja2 environment is configured only once, but new <code>view</code> functions are returned. It is recommended to keep this setup in a single file, and import the <code>view</code> function in files that define routes for the application.</p>"},{"location":"templating/#async-mode","title":"Async mode","text":"<p>It is possible to enable Jinja2 async mode, using the parameter <code>enable_async</code>. When <code>enable_async</code> is true, the function returned by <code>use_templates</code> is asynchronous:</p> <pre><code>from blacksheep import Application\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader\n\napp = Application(show_error_details=True, debug=True)\nget = app.router.get\n\n# NB: this example requires a package called \"app\";\n# containing a 'templates' folder\n# The server file must be in the same folder that contains \"app\"\nview = use_templates(app, loader=PackageLoader(\"app\", \"templates\"), enable_async=True)\n\n\n@get(\"/\")\nasync def home():\n    return await view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre>"},{"location":"templating/#loading-templates","title":"Loading templates","text":"<p>It is possible to load templates by name including '.html', or without file extension; '.html' extension is added automatically. Extension must be lower case.</p> <pre><code>@get(\"/\")\nasync def home(request):\n    return view(\"home.html\", {\"example\": \"Hello\", \"foo\": \"World\"})\n\n\n# or...\n\n\n@get(\"/\")\nasync def home(request):\n    return view(\"home\", {\"example\": \"Hello\", \"foo\": \"World\"})\n</code></pre>"},{"location":"templating/#helpers-and-filters","title":"Helpers and filters","text":"<p>To configure custom helpers and filters for Jinja, it is possible to access its <code>Environment</code> using the <code>templates_environment</code> property of the application, once server side templating is configured.</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.html\n\u2514\u2500\u2500 server.py\n</code></pre> <pre><code># server.py\nfrom blacksheep import Application\nfrom blacksheep.server.templating import use_templates\nfrom jinja2 import PackageLoader, Environment\n\napp = Application(show_error_details=True)\n\nview = use_templates(app, PackageLoader(\"app\", \"views\"))\n\n\ndef example():\n    return \"This is an example\"\n\n\napp.templates_environment.globals.update({\"my_function\": example})  # &lt;&lt;&lt;\n\n\n@app.route(\"/\")\nasync def home():\n    return view(\"index.html\", {})\n</code></pre> <pre><code>&lt;!-- index.html --&gt;\n&lt;p&gt;Hello, World!&lt;/p&gt;\n{{ my_function() }}\n</code></pre> <p>Last modified on: 2023-07-16 08:51:27</p>RV"},{"location":"testing/","title":"Testing a BlackSheep app","text":"<p>This page describes how a BlackSheep web application can be tested, documenting the built-in <code>TestClient</code> class and providing a tutorial that shows how it can be used with <code>pytest</code> to test an API. It covers the following:</p> <ul> <li> How to use the provided <code>TestClient</code>.</li> <li> How to configure tests using <code>pytest</code>.</li> <li> How to run integration tests using a server process.</li> </ul> <p>TL;DR A complete example with testing configured for <code>pytest</code> is available at: ./testing-api. Those who don't want to follow the tutorial on this page can read the code in the example.</p>"},{"location":"testing/#overview-of-the-testclient-class","title":"Overview of the TestClient class","text":"<p>The <code>TestClient</code> class provides useful methods to test a <code>blacksheep</code> application, simulating web requests from an <code>ASGI</code> server. Simulating web requests has the benefit that tests execute fast and don't require a real HTTP Server and actual HTTP client-server interactions. At the same time, they recreate a full end-to-end scenario of how requests are handled by an application server.</p> <p>A basic example of the <code>TestClient</code> would look like this:</p> <pre><code>import asyncio\nfrom blacksheep import Application\nfrom blacksheep.testing import TestClient\n\napp = Application()\n\n\n@app.route(\"/\")\nasync def hello(name: str = \"World\"):\n    return f\"Hello, {name}!\"\n\n\nasync def test():\n    # the application needs to handle its start event, to recreate a valid scenario\n    await app.start()\n\n    client = TestClient(app)\n\n    response = await client.get(\"/\")\n    text = await response.text()\n\n    assert response.status == 200\n    assert text == \"Hello, World!\"\n\n    response = await client.get(\"/\", query={\"name\": \"Foo\"})\n    text = await response.text()\n\n    assert response.status == 200\n    assert text == \"Hello, Foo!\"\n\n    print(\"OK\")\n\n\nasyncio.run(test())\n</code></pre> <p>A test client provides the following methods:</p> Method Description get Simulates an HTTP GET request. post Simulates an HTTP POST request. put Simulates an HTTP PUT request. patch Simulates an HTTP PATCH request. delete Simulates an HTTP DELETE request. head Simulates an HTTP HEAD request. options Simulates an HTTP OPTIONS request. trace Simulates an HTTP TRACE request. <p>Info</p> <p>By default a <code>TestClient</code> simulates web requests creating <code>ASGI</code> scopes, however it can be configured with a custom implementation of <code>AbstractTestSimulator</code> to generate real HTTP requests against a real HTTP server. For simplicity, this is not documented here.</p>"},{"location":"testing/#tutorial","title":"Tutorial","text":"<p>This tutorial illustrates how to create a basic TODOs API and prepare tests for it, step by step.</p>"},{"location":"testing/#requirements","title":"Requirements","text":"<ul> <li>The requirements described for the getting started tutorial</li> <li>Familiarity with test frameworks and common concepts like <code>fixtures</code>; if you   are not familiar with this subject, read <code>pytest</code> documentation for an   overview (e.g. pytest home, what are   fixtures)</li> <li>Basic knowledge about <code>pydantic</code>   models is a plus, however, the same principles can be applied to Python   built-in <code>dataclasses</code></li> </ul>"},{"location":"testing/#preparing-the-project-structure","title":"Preparing the project structure","text":"<p>Prepare a Python virtual environment, as described in the getting started tutorial. In addition to <code>blacksheep</code> and <code>uvicorn</code>, install the following packages in the virtual environment:</p> <pre><code>pip install pytest pytest-asyncio pydantic\n</code></pre> <p>Then create a basic folder structure, like described by the following tree:</p> <pre><code>.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 routes\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 domain.py\n\u2514\u2500\u2500 server.py\n</code></pre> <p>For example, using GNU Bash:</p> <pre><code>mkdir app\ntouch app/app.py\ntouch app/__init__.py\n\nmkdir app/routes\ntouch app/routes/__init__.py\n\ntouch domain.py\ntouch server.py\n</code></pre> <p>Edit <code>domain.py</code> file, to define two domain classes:</p> <pre><code>from pydantic import BaseModel\n\n\nclass ToDo(BaseModel):\n    id: int\n    title: str\n    description: str\n\n\nclass CreateToDoInput(BaseModel):\n    title: str\n    description: str\n</code></pre> <p>To define the API, create a <code>router.py</code> file in the <code>app.routes</code> package and copy the following contents into it:</p> <pre><code># ./app/routes/router.py\n\nfrom blacksheep.server.routing import Router\n\n\nrouter = Router()\n\nget = router.get\npost = router.post\ndelete = router.delete\n</code></pre> <p>Info</p> <p>\ud83d\udca1 Declaring the router in a dedicated file is useful to reduce code verbosity when defining request handlers.</p> <p>Then create a <code>todos.py</code> file in <code>app.routes</code> package, that will contain the definition of the TODOs API. Start with the following contents:</p> <pre><code># ./app/routes/todos.py\n\nfrom .router import get, post, delete\nfrom domain import ToDo, CreateToDoInput\nfrom typing import List, Optional\n\n\n@get(\"/api/todos\")\nasync def get_todos() -&gt; List[ToDo]:\n    ...\n\n\n@get(\"/api/todos/{todo_id}\")\nasync def get_todo(todo_id) -&gt; Optional[ToDo]:\n    ...\n\n\n@post(\"/api/todos\")\nasync def create_todo(data: CreateToDoInput) -&gt; ToDo:\n    ...\n\n\n@delete(\"/api/todos/{todo_id}\")\nasync def delete_todo(todo_id) -&gt; None:\n    ...\n</code></pre> <p>Edit the <code>__init__.py</code> file in <code>app.routes</code> package, to load the API definition:</p> <pre><code># ./app/routes/__init__.py\n\nfrom .router import *\nfrom .todos import *\n</code></pre> <p>Create a <code>main.py</code> file in <code>app</code> package, that declares an application:</p> <pre><code># ./app/main.py\nfrom blacksheep import Application\n\nfrom .routes import router\n\n\napp = Application(router=router)\n</code></pre> <p>And finally a <code>server.py</code> file at the project's root:</p> <pre><code># ./server.py\n\nfrom app.main import app\n</code></pre>"},{"location":"testing/#navigating-the-api-using-openapi-documentation","title":"Navigating the API using OpenAPI Documentation","text":"<p>At this point the application can already be started. The API methods are not implemented, yet, so they cannot do anything interesting. However, the framework can generate OpenAPI Documentation and expose a documentation UI.</p> <p>To do so, create a <code>docs.py</code> file in the <code>app</code> package:</p> <pre><code># ./app/docs.py\n\nfrom blacksheep.server.openapi.v3 import OpenAPIHandler\nfrom openapidocs.v3 import Info\n\ndocs = OpenAPIHandler(\n    info=Info(title=\"Demo API\", version=\"0.0.1\"), anonymous_access=True\n)\n\n# include only endpoints whose path starts with \"/api/\"\ndocs.include = lambda path, _: path.startswith(\"/api/\")\n</code></pre> <p>And modify <code>/app/main.py</code> file to configure the generation of OpenAPI Documentation:</p> <pre><code>from blacksheep import Application\n\nfrom .routes import router\nfrom .docs import docs  # +++\n\n\napp = Application(router=router)\ndocs.bind_app(app)  # +++\n</code></pre> <p>Start the application using the following command:</p> <pre><code>uvicorn server:app --reload --port=44555\n</code></pre> <p>And navigate to the http://127.0.0.1:44555/docs to see the documentation generated automatically by BlackSheep:</p> <p></p> <p>Note how, thanks to type annotations and support for <code>pydantic</code>, blacksheep generates automatically OpenAPI Documentation version 3 for all responses and input request bodies and parameters.</p>"},{"location":"testing/#creating-a-mocked-todos-api","title":"Creating a mocked TODOs API","text":"<p>For the sake of the testing demo, let's mock the implementation of the TODOs API to work with data stored in memory:</p> <pre><code># ./app/routes/todos.py\n\nfrom typing import Dict, List, Optional\n\nfrom blacksheep import not_found\nfrom domain import CreateToDoInput, ToDo\n\nfrom .router import delete, get, post\n\n\n_MOCKED: Dict[int, ToDo] = {\n    1: ToDo(\n        id=1,\n        title=\"BlackSheep Documentation\",\n        description=\"Update the documentation with information about the new features.\",\n    ),\n    2: ToDo(\n        id=2,\n        title=\"Transfer the documentation\",\n        description=\"Transfer the documentation from Azure DevOps to GitHub.\",\n    ),\n    3: ToDo(\n        id=3,\n        title=\"Mow the grass\",\n        description=\"Like in title.\",\n    ),\n}\n\n\n@get(\"/api/todos\")\nasync def get_todos() -&gt; List[ToDo]:\n    return list(_MOCKED.values())\n\n\n@get(\"/api/todos/{todo_id}\")\nasync def get_todo(todo_id: int) -&gt; Optional[ToDo]:\n    try:\n        return _MOCKED[todo_id]\n    except KeyError:\n        return not_found()\n\n\n@post(\"/api/todos\")\nasync def create_todo(data: CreateToDoInput) -&gt; ToDo:\n    item = ToDo(id=len(_MOCKED) + 1, title=data.title, description=data.description)\n    _MOCKED[item.id] = item\n    return item\n\n\n@delete(\"/api/todos/{todo_id}\")\nasync def delete_todo(todo_id: int) -&gt; None:\n    try:\n        del _MOCKED[todo_id]\n    except KeyError:\n        pass\n</code></pre> <p>Now that the API is mocked, let's see how to add tests for it.</p>"},{"location":"testing/#using-the-testclient-with-pytest","title":"Using the TestClient with pytest","text":"<p>Create a <code>tests</code> package and the following files:</p> <pre><code>\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 conftest.py\n    \u2514\u2500\u2500 test_todos_api.py\n</code></pre> <p><code>conftest.py</code> is a special file used by <code>pytest</code> to arrange fixtures. Edit this file to include fixtures definition to arrange tests for the web application:</p> <pre><code># ./tests/conftest.py\n\nimport asyncio\n\nimport pytest\nimport pytest_asyncio\nfrom blacksheep.testing import TestClient\nfrom server import app as app_server\n\n\n@pytest.fixture(scope=\"session\")\ndef event_loop(request):\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n\n@pytest_asyncio.fixture(scope=\"session\")\nasync def api():\n    await app_server.start()\n    yield app_server\n    await app_server.stop()\n\n\n@pytest_asyncio.fixture(scope=\"session\")\nasync def test_client(api):\n    return TestClient(api)\n</code></pre> <p>Note how the file contains three fixtures:</p> <ol> <li><code>event_loop</code>, for asyncio: it needs to be redefined to support <code>session</code>    scope</li> <li><code>api</code>, which yields an instance of the started web application</li> <li><code>test_client</code>, which returns the instance of <code>TestClient</code> that can be used    to fire web requests on the web application</li> </ol> <p>These fixtures enable testing all request handlers defined in the application.</p> <p>Info</p> <p>\ud83d\udca1 It is possible to apply special configuration to the application server, for example overriding services in the DI container just for tests, for example replacing a class that interacts with a PostgreSQL Server to use instead SQLite for tests.</p> <p>Finally, define a first test for the TODOs API:</p> <pre><code># ./tests/test_todos_api.py\n\nfrom typing import Any\n\nimport pytest\nfrom blacksheep.contents import Content\nfrom blacksheep.testing import TestClient\nfrom domain import CreateToDoInput, ToDo\nfrom essentials.json import dumps\n\n\ndef json_content(data: Any) -&gt; Content:\n    return Content(\n        b\"application/json\",\n        dumps(data, separators=(\",\", \":\")).encode(\"utf8\"),\n    )\n\n\n@pytest.mark.asyncio\nasync def test_create_and_get_todo(test_client: TestClient) -&gt; None:\n\n    create_input = CreateToDoInput(\n        title=\"Update documentation\",\n        description=\"Update blacksheep's documentation to describe all new features.\",\n    )\n\n    response = await test_client.post(\n        \"/api/todos\",\n        content=json_content(create_input),\n    )\n\n    assert response is not None\n\n    data = await response.json()\n\n    assert data is not None\n    assert \"id\" in data\n\n    todo_id = data[\"id\"]\n    response = await test_client.get(f\"/api/todos/{todo_id}\")\n\n    assert response is not None\n    data = await response.json()\n\n    assert data is not None\n\n    todo = ToDo(**data)\n\n    assert todo.title == create_input.title\n    assert todo.description == create_input.description\n</code></pre> <p>Now it's possible to start the tests using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> <p>If the steps above were done correctly, the test succeeds and <code>pytest</code> produces a feedback like in the following picture (using the verbose flag <code>-v</code>):</p> <p></p>"},{"location":"testing/#how-to-run-integration-tests-using-a-server-process","title":"How to run integration tests using a server process.","text":"<p>The following example shows how to configure a <code>@pytest.fixture</code> that starts an <code>uvicorn</code> process in memory to run integration tests against a real <code>ASGI</code> server:</p> <pre><code># example server fixture\n\nimport os\nfrom multiprocessing import Process\nfrom time import sleep\n\nimport pytest\nimport uvicorn\nfrom server import app\n\n\ndef get_sleep_time():\n    # when starting a server process,\n    # a longer sleep time is necessary on Windows\n    if os.name == \"nt\":\n        return 1.5\n    return 0.5\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\ndef _start_server():\n    uvicorn.run(app, host=server_host, port=server_port, log_level=\"debug\")\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef server():\n    server_process = Process(target=_start_server)\n    server_process.start()\n    sleep(get_sleep_time())\n\n    if not server_process.is_alive():\n        raise TypeError(\"The server process did not start!\")\n\n    yield 1\n\n    sleep(1.2)\n    server_process.terminate()\n</code></pre> <p>The same server <code>host</code> and <code>port</code> can then be used with the desired HTTP Client implementation to run tests on the server, to recreate a full HTTP client-server communication.</p> <p>The following code shows an example of <code>@pytest.fixture</code> returning an HTTP client that can make requests to the running servers, using requests library:</p> <pre><code>import requests\nfrom urllib.parse import urljoin\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\nclass ClientSession(requests.Session):\n    def __init__(self, base_url):\n        self.base_url = base_url\n        super().__init__()\n\n    def request(self, method, url, *args, **kwargs):\n        return super().request(method, urljoin(self.base_url, url), *args, **kwargs)\n\n\n@pytest.fixture(scope=\"session\")\ndef session_two(server_host, server_port_two):\n    return ClientSession(f\"http://{server_host}:{server_port_two}\")\n</code></pre> <p>And a full example for the TODO API described in the tutorial could look like the following (the example requires <code>requests</code> library):</p> <pre><code>import os\nfrom multiprocessing import Process\nfrom time import sleep\nfrom urllib.parse import urljoin\n\nimport pytest\nimport requests\nimport uvicorn\nfrom server import app\n\n\nclass ClientSession(requests.Session):\n    def __init__(self, base_url):\n        self.base_url = base_url\n        super().__init__()\n\n    def request(self, method, url, *args, **kwargs):\n        return super().request(method, urljoin(self.base_url, url), *args, **kwargs)\n\n\ndef get_sleep_time():\n    # when starting a server process,\n    # a longer sleep time is necessary on Windows\n    if os.name == \"nt\":\n        return 1.5\n    return 0.5\n\n\nserver_host = \"127.0.0.1\"\nserver_port = 44555\n\n\n@pytest.fixture(scope=\"session\")\ndef client_session():\n    return ClientSession(f\"http://{server_host}:{server_port}\")\n\n\ndef _start_server():\n    uvicorn.run(app, host=server_host, port=server_port, log_level=\"debug\")\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef server():\n    server_process = Process(target=_start_server)\n    server_process.start()\n    sleep(get_sleep_time())\n\n    if not server_process.is_alive():\n        raise TypeError(\"The server process did not start!\")\n\n    yield 1\n\n    sleep(1.2)\n    server_process.terminate()\n\n\n@pytest.mark.asyncio\nasync def test_get(client_session):\n    response = client_session.get(\"/api/todos/1\")\n\n    assert response.status_code == 200\n</code></pre> <p>Info</p> <p>Fixtures can be defined in a dedicated module, to keep the tests code clean.</p> <p>Last modified on: 2023-11-19 09:53:58</p>ARV"},{"location":"websocket/","title":"WebSocket","text":"<p>WebSocket is a technology that allows creating a persistent, bi-directional connection between a client and a server. It's mostly used in real-time apps, chat apps, etc.</p> <p>BlackSheep is able to handle incoming WebSocket connections if you're using an ASGI server that supports WebSocket protocol (for example Uvicorn or Hypercorn).</p>"},{"location":"websocket/#creating-a-websocket-route","title":"Creating a WebSocket route","text":"<p>If you want your request handler to act as a WebSocket handler, use the <code>ws</code> decorator or a corresponding <code>add_ws</code> method provided by the app router. Note that the <code>ws</code> decorator doesn't have a default path pattern, so you must pass it.</p> <p>You can use route parameters just like with the regular request handlers.</p> Using <code>ws</code> decoratorUsing <code>add_ws</code> method <pre><code>from blacksheep import Application, WebSocket\n\napp = Application()\n\n\n@app.router.ws(\"/ws/{client_id}\")\nasync def ws(websocket: WebSocket, client_id: str):\n    ...\n</code></pre> <pre><code>from blacksheep import Application, WebSocket\n\napp = Application()\n\n\nasync def ws(websocket: WebSocket, client_id: str):\n    ...\n\n\napp.router.add_ws(\"/ws/{client_id}\", ws)\n</code></pre> <p>A <code>WebSocket</code> object will be bound to a parameter injected into your handler function when the client will try to connect to the endpoint.</p> <p>Be careful</p> <p>Make sure that your function either has a parameter named websocket or a parameter with an arbitrary name, annotated with the <code>WebSocket</code> class. Otherwise, the route will not function properly.</p>"},{"location":"websocket/#accepting-the-connection","title":"Accepting the connection","text":"<p>The <code>WebSocket</code> class provides the <code>accept</code> method to accept a connection, passing optional parameters  to the client. These optional parameters are headers which will be sent back to the client with the handshake response and subprotocol that your application agrees to accept.</p> <p>Info</p> <p>The MDN article on writing WebSocket servers has some additional information regarding subprotocols and response headers.</p> <pre><code>@app.router.ws(\"/ws\")\nasync def ws(websocket: WebSocket):\n    # Parameters are purely optional.\n    await websocket.accept(\n        headers=[(b\"x-custom-header\", b\"custom-value\")],\n        subprotocol=\"custom-protocol\"\n    )\n</code></pre> <p>As soon as the connection is accepted, you can start receiving and sending messages.</p>"},{"location":"websocket/#communicating-with-the-client","title":"Communicating with the client","text":"<p>There are 3 helper method pairs to communicate with the client: <code>receive_text</code>/<code>send_text</code>, <code>receive_bytes</code>/<code>send_bytes</code> and <code>receive_json</code>/<code>send_json</code>.</p> <p>There is also the <code>receive</code> method that allows for receiving raw WebSocket messages. Although most of the time you'll want to use one of the helper methods.</p> <p>All send methods accept an argument of data to be sent. <code>receive_json</code>/<code>send_json</code> also accepts a mode argument. It defaults to <code>MessageMode.TEXT</code> and can be set to <code>MessageMode.BYTES</code> if, for example, your client sends you encoded JSON strings.</p> <p>Below is a simple example of an echo WebSocket handler.</p> <p>This function will receive a text message sent by the client and echo it back until either the client disconnects or the server shut down.</p> TextBytesJSON <pre><code>@app.router.ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_text()\n        # \"Hello world!\"\n        await websocket.send_text(msg)\n</code></pre> <pre><code>@app.router.ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_bytes()\n        # b\"Hello world\"\n        await websocket.send_bytes(msg)\n</code></pre> <pre><code>@app.router.ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    while True:\n        msg = await websocket.receive_json()\n        # {'msg': 'Hello world!'}\n        await websocket.send_json(msg)\n</code></pre>"},{"location":"websocket/#handling-client-disconnect","title":"Handling client disconnect","text":"<p>In event of client disconnect, the ASGI server will close the connection and send the corresponding message to your app. Upon receiving this message <code>WebSocket</code> object will raise the <code>WebSocketDisconnectError</code> exception.</p> <p>You'll likely want to catch it and handle it somehow.</p> <pre><code>from blacksheep import WebSocket, WebSocketDisconnectError\n\n...\n\n@app.router.ws(\"/ws\")\nasync def echo(websocket: WebSocket):\n    await websocket.accept()\n\n    try:\n        while True:\n            msg = await websocket.receive_text()\n            await websocket.send_text(msg)\n    except WebSocketDisconnectError:\n        ... # Handle the disconnect.\n</code></pre>"},{"location":"websocket/#example-chat-application","title":"Example: chat application","text":"<p>Here you can find the example app using BlackSheep and VueJS. It implements a naive chat application.</p> <p>Warning</p> <p>This code is just an example! It would be much more complex if you would like to build a real chat app.</p> <p>Last modified on: 2022-11-20 11:01:11</p>RV"},{"location":"examples/marshmallow/","title":"Using Marshmallow","text":"<p>The following example describes how <code>Marshmallow</code> can be used to implement validation of input bodies from the client. For the sake of simplicity, the example shows a case in which an array of items is validated (the marshmallow scheme is validated using <code>(many=True)</code>). A similar approach can be used with <code>msgspec</code></p> <p>Implementing a generic solution to validate input and produce user friendly error messages is not in the scope of BlackSheep, but the framework offers ways to integrate with other libraries.</p> <p>This is possible defining a couple of custom binders, a custom exception, and a custom exception handler like in the example below.</p> <pre><code>from typing import Any, TypeVar\n\nfrom marshmallow import Schema, ValidationError, fields\n\nfrom blacksheep import Application\nfrom blacksheep.messages import Request\nfrom blacksheep.server.bindings import Binder, BoundValue\nfrom blacksheep.server.responses import pretty_json\n\nSchemaType = TypeVar(\"SchemaType\", bound=Schema)\n\n\nclass InvalidBodyError(Exception):\n\"\"\"\n    Kind of BadRequest exception that include error details as complex objects.\n    \"\"\"\n\n    def __init__(self, data: Any):\n        super().__init__(\"Invalid payload\")\n        self.details = data\n\n\n# Example Marshmallow schema, from the marshmallow documentation\nclass BandMemberSchema(Schema):\n    name = fields.String(required=True)\n    email = fields.Email()\n\n\n# Example binding for a Marshmallow schema, to be used to obtain list of objects\nclass FromMultiSchema(BoundValue[SchemaType]):\n\"\"\"\n    Custom bound value that can be used to describe a list of objects validated using a\n    Marshmallow schema.\n    \"\"\"\n\n\nclass MultiSchemaBinder(Binder):\n\"\"\"\n    Binder that handles a FromMultiSchema, returning list of objects from a\n    Marshmallow schema.\n    \"\"\"\n\n    handle = FromMultiSchema\n\n    async def get_value(self, request: Request) -&gt; Any:\n        data = await request.json()\n        try:\n            return self.expected_type(many=True).load(data)\n        except ValidationError as err:\n            raise InvalidBodyError(err.messages)\n\n\napp = Application()\n\n\n@app.exception_handler(InvalidBodyError)\nasync def invalid_body_handler(app, request, exc: InvalidBodyError):\n    return pretty_json(exc.details, 400)\n\n\n@app.router.post(\"/\")\ndef example(data: FromMultiSchema[BandMemberSchema]):\n    return pretty_json(data.value)\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(app, port=44555, lifespan=\"on\")\n</code></pre> <pre><code>curl -X POST http://127.0.0.1:44555 -H \"Content-Type: application/json\" -d '[{\"id\": 1, \"name\": \"foo\", \"permissions\": []}]'\n{\n\"0\": {\n\"permissions\": [\n\"Unknown field.\"\n],\n        \"id\": [\n\"Unknown field.\"\n]\n}\n}\n\ncurl -X POST http://127.0.0.1:44555 -H \"Content-Type: application/json\" -d '[{\"id\": 1, \"name\": \"foo\", \"email\": \"wrong-value\"}]'\n{\n\"0\": {\n\"email\": [\n\"Not a valid email address.\"\n],\n        \"id\": [\n\"Unknown field.\"\n]\n}\n}\n</code></pre> <p>Last modified on: 2023-11-19 09:55:03</p>T"}]}